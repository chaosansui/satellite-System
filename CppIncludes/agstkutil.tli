// Created by Microsoft (R) C/C++ Compiler Version 14.16.27026.1 (3cc217aa).
//
// d:\dev\r_stk_prod_x64\source\lib\release.x64\tlhbuilder\agstkutil.tli
//
// Wrapper implementations for type library AgStkUtil.tlb
// compiler-generated file created 03/29/19 at 20:37:36 - DO NOT EDIT!

#pragma once

namespace STKUtil {

//
// interface IAgOrbitState wrapper method implementations
//

IAgOrbitStatePtr IAgOrbitState::ConvertTo ( enum AgEOrbitStateType Type ) {
    struct IAgOrbitState * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrbitStatePtr(_result, false);
}

enum AgEOrbitStateType IAgOrbitState::GetOrbitStateType ( ) {
    enum AgEOrbitStateType _result;
    HRESULT _hr = get_OrbitStateType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IAgOrbitState::Assign ( struct IAgOrbitState * pOrbitState ) {
    HRESULT _hr = raw_Assign(pOrbitState);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgOrbitState::AssignClassical ( enum AgECoordinateSystem ECoordinateSystem, double SemiMajorAxis, double Eccentricity, double Inclination, double ArgOfPerigee, double RAAN, double MeanAnomaly ) {
    HRESULT _hr = raw_AssignClassical(ECoordinateSystem, SemiMajorAxis, Eccentricity, Inclination, ArgOfPerigee, RAAN, MeanAnomaly);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgOrbitState::AssignCartesian ( enum AgECoordinateSystem ECoordinateSystem, double XPosition, double YPosition, double ZPosition, double XVelocity, double YVelocity, double ZVelocity ) {
    HRESULT _hr = raw_AssignCartesian(ECoordinateSystem, XPosition, YPosition, ZPosition, XVelocity, YVelocity, ZVelocity);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgOrbitState::AssignGeodetic ( enum AgECoordinateSystem ECoordinateSystem, double Latitude, double Longitude, double Altitude, double LatitudeRate, double LongitudeRate, double AltitudeRate ) {
    HRESULT _hr = raw_AssignGeodetic(ECoordinateSystem, Latitude, Longitude, Altitude, LatitudeRate, LongitudeRate, AltitudeRate);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgOrbitState::AssignEquinoctialPosigrade ( enum AgECoordinateSystem ECoordinateSystem, double SemiMajorAxis, double H, double K, double P, double Q, double MeanLon ) {
    HRESULT _hr = raw_AssignEquinoctialPosigrade(ECoordinateSystem, SemiMajorAxis, H, K, P, Q, MeanLon);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgOrbitState::AssignEquinoctialRetrograde ( enum AgECoordinateSystem ECoordinateSystem, double SemiMajorAxis, double H, double K, double P, double Q, double MeanLon ) {
    HRESULT _hr = raw_AssignEquinoctialRetrograde(ECoordinateSystem, SemiMajorAxis, H, K, P, Q, MeanLon);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgOrbitState::AssignMixedSpherical ( enum AgECoordinateSystem ECoordinateSystem, double Latitude, double Longitude, double Altitude, double HorFlightPathAngle, double FlightPathAzimuth, double Velocity ) {
    HRESULT _hr = raw_AssignMixedSpherical(ECoordinateSystem, Latitude, Longitude, Altitude, HorFlightPathAngle, FlightPathAzimuth, Velocity);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgOrbitState::AssignSpherical ( enum AgECoordinateSystem ECoordinateSystem, double RightAscension, double Declination, double Radius, double HorFlightPathAngle, double FlightPathAzimuth, double Velocity ) {
    HRESULT _hr = raw_AssignSpherical(ECoordinateSystem, RightAscension, Declination, Radius, HorFlightPathAngle, FlightPathAzimuth, Velocity);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t IAgOrbitState::GetCentralBodyName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CentralBodyName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_variant_t IAgOrbitState::GetEpoch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Epoch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgOrbitState::PutEpoch ( const _variant_t & pRetVal ) {
    HRESULT _hr = put_Epoch(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgOrbitState wrapper method implementations
//

IAgOrbitStatePtr _IAgOrbitState::ConvertTo ( enum AgEOrbitStateType Type ) {
    struct IAgOrbitState * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrbitStatePtr(_result, false);
}

enum AgEOrbitStateType _IAgOrbitState::GetOrbitStateType ( ) {
    enum AgEOrbitStateType _result;
    HRESULT _hr = get_OrbitStateType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgOrbitState::Assign ( struct IAgOrbitState * pOrbitState ) {
    HRESULT _hr = raw_Assign(pOrbitState);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitState::AssignClassical ( enum AgECoordinateSystem ECoordinateSystem, double SemiMajorAxis, double Eccentricity, double Inclination, double ArgOfPerigee, double RAAN, double MeanAnomaly ) {
    HRESULT _hr = raw_AssignClassical(ECoordinateSystem, SemiMajorAxis, Eccentricity, Inclination, ArgOfPerigee, RAAN, MeanAnomaly);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitState::AssignCartesian ( enum AgECoordinateSystem ECoordinateSystem, double XPosition, double YPosition, double ZPosition, double XVelocity, double YVelocity, double ZVelocity ) {
    HRESULT _hr = raw_AssignCartesian(ECoordinateSystem, XPosition, YPosition, ZPosition, XVelocity, YVelocity, ZVelocity);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitState::AssignGeodetic ( enum AgECoordinateSystem ECoordinateSystem, double Latitude, double Longitude, double Altitude, double LatitudeRate, double LongitudeRate, double AltitudeRate ) {
    HRESULT _hr = raw_AssignGeodetic(ECoordinateSystem, Latitude, Longitude, Altitude, LatitudeRate, LongitudeRate, AltitudeRate);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitState::AssignEquinoctialPosigrade ( enum AgECoordinateSystem ECoordinateSystem, double SemiMajorAxis, double H, double K, double P, double Q, double MeanLon ) {
    HRESULT _hr = raw_AssignEquinoctialPosigrade(ECoordinateSystem, SemiMajorAxis, H, K, P, Q, MeanLon);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitState::AssignEquinoctialRetrograde ( enum AgECoordinateSystem ECoordinateSystem, double SemiMajorAxis, double H, double K, double P, double Q, double MeanLon ) {
    HRESULT _hr = raw_AssignEquinoctialRetrograde(ECoordinateSystem, SemiMajorAxis, H, K, P, Q, MeanLon);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitState::AssignMixedSpherical ( enum AgECoordinateSystem ECoordinateSystem, double Latitude, double Longitude, double Altitude, double HorFlightPathAngle, double FlightPathAzimuth, double Velocity ) {
    HRESULT _hr = raw_AssignMixedSpherical(ECoordinateSystem, Latitude, Longitude, Altitude, HorFlightPathAngle, FlightPathAzimuth, Velocity);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrbitState::AssignSpherical ( enum AgECoordinateSystem ECoordinateSystem, double RightAscension, double Declination, double Radius, double HorFlightPathAngle, double FlightPathAzimuth, double Velocity ) {
    HRESULT _hr = raw_AssignSpherical(ECoordinateSystem, RightAscension, Declination, Radius, HorFlightPathAngle, FlightPathAzimuth, Velocity);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t _IAgOrbitState::GetCentralBodyName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CentralBodyName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_variant_t _IAgOrbitState::GetEpoch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Epoch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgOrbitState::PutEpoch ( const _variant_t & pRetVal ) {
    HRESULT _hr = put_Epoch(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgExecCmdResult wrapper method implementations
//

long IAgExecCmdResult::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t IAgExecCmdResult::GetItem ( long Index ) {
    BSTR _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

IUnknownPtr IAgExecCmdResult::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

SAFEARRAY * IAgExecCmdResult::Range ( long StartIndex, long StopIndex ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_Range(StartIndex, StopIndex, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IAgExecCmdResult::GetIsSucceeded ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsSucceeded(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgExecMultiCmdResult wrapper method implementations
//

long IAgExecMultiCmdResult::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgExecCmdResultPtr IAgExecMultiCmdResult::GetItem ( long Index ) {
    struct IAgExecCmdResult * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgExecCmdResultPtr(_result, false);
}

IUnknownPtr IAgExecMultiCmdResult::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface IAgQuantity wrapper method implementations
//

_bstr_t IAgQuantity::GetDimension ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Dimension(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t IAgQuantity::GetUnit ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Unit(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT IAgQuantity::ConvertToUnit ( _bstr_t UnitAbbrv ) {
    HRESULT _hr = raw_ConvertToUnit(UnitAbbrv);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

double IAgQuantity::GetValue ( ) {
    double _result = 0;
    HRESULT _hr = get_Value(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgQuantity::PutValue ( double pValue ) {
    HRESULT _hr = put_Value(pValue);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgQuantityPtr IAgQuantity::Add ( struct IAgQuantity * Quantity ) {
    struct IAgQuantity * _result = 0;
    HRESULT _hr = raw_Add(Quantity, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgQuantityPtr(_result, false);
}

IAgQuantityPtr IAgQuantity::Subtract ( struct IAgQuantity * Quantity ) {
    struct IAgQuantity * _result = 0;
    HRESULT _hr = raw_Subtract(Quantity, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgQuantityPtr(_result, false);
}

IAgQuantityPtr IAgQuantity::MultiplyQty ( struct IAgQuantity * Quantity ) {
    struct IAgQuantity * _result = 0;
    HRESULT _hr = raw_MultiplyQty(Quantity, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgQuantityPtr(_result, false);
}

IAgQuantityPtr IAgQuantity::DivideQty ( struct IAgQuantity * Quantity ) {
    struct IAgQuantity * _result = 0;
    HRESULT _hr = raw_DivideQty(Quantity, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgQuantityPtr(_result, false);
}

//
// interface IAgDate wrapper method implementations
//

_bstr_t IAgDate::Format ( _bstr_t Unit ) {
    BSTR _result = 0;
    HRESULT _hr = raw_Format(Unit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT IAgDate::SetDate ( _bstr_t Unit, _bstr_t Value ) {
    HRESULT _hr = raw_SetDate(Unit, Value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

DATE IAgDate::GetOLEDate ( ) {
    DATE _result = 0;
    HRESULT _hr = get_OLEDate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgDate::PutOLEDate ( DATE pDate ) {
    HRESULT _hr = put_OLEDate(pDate);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long IAgDate::GetWholeDays ( ) {
    long _result = 0;
    HRESULT _hr = get_WholeDays(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgDate::PutWholeDays ( long pVal ) {
    HRESULT _hr = put_WholeDays(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgDate::GetSecIntoDay ( ) {
    double _result = 0;
    HRESULT _hr = get_SecIntoDay(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgDate::PutSecIntoDay ( double pVal ) {
    HRESULT _hr = put_SecIntoDay(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long IAgDate::GetWholeDaysUTC ( ) {
    long _result = 0;
    HRESULT _hr = get_WholeDaysUTC(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgDate::PutWholeDaysUTC ( long pVal ) {
    HRESULT _hr = put_WholeDaysUTC(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgDate::GetSecIntoDayUTC ( ) {
    double _result = 0;
    HRESULT _hr = get_SecIntoDayUTC(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgDate::PutSecIntoDayUTC ( double pVal ) {
    HRESULT _hr = put_SecIntoDayUTC(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgDatePtr IAgDate::Add ( _bstr_t Unit, double Value ) {
    struct IAgDate * _result = 0;
    HRESULT _hr = raw_Add(Unit, Value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgDatePtr(_result, false);
}

IAgDatePtr IAgDate::Subtract ( _bstr_t Unit, double Value ) {
    struct IAgDate * _result = 0;
    HRESULT _hr = raw_Subtract(Unit, Value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgDatePtr(_result, false);
}

IAgQuantityPtr IAgDate::Span ( struct IAgDate * Date ) {
    struct IAgQuantity * _result = 0;
    HRESULT _hr = raw_Span(Date, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgQuantityPtr(_result, false);
}

//
// interface IAgPosition wrapper method implementations
//

IAgPositionPtr IAgPosition::ConvertTo ( enum AgEPositionType Type ) {
    struct IAgPosition * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgPositionPtr(_result, false);
}

enum AgEPositionType IAgPosition::GetPosType ( ) {
    enum AgEPositionType _result;
    HRESULT _hr = get_PosType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IAgPosition::Assign ( struct IAgPosition * pPosition ) {
    HRESULT _hr = raw_Assign(pPosition);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgPosition::AssignGeocentric ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignGeocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgPosition::AssignGeodetic ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignGeodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgPosition::AssignSpherical ( const _variant_t & Lat, const _variant_t & Lon, double Radius ) {
    HRESULT _hr = raw_AssignSpherical(Lat, Lon, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgPosition::AssignCylindrical ( double Radius, double Z, const _variant_t & Lon ) {
    HRESULT _hr = raw_AssignCylindrical(Radius, Z, Lon);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgPosition::AssignCartesian ( double X, double Y, double Z ) {
    HRESULT _hr = raw_AssignCartesian(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgPosition::AssignPlanetocentric ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignPlanetocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgPosition::AssignPlanetodetic ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignPlanetodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgPosition::QueryPlanetocentric ( VARIANT * Lat, VARIANT * Lon, double * Alt ) {
    HRESULT _hr = raw_QueryPlanetocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgPosition::QueryPlanetodetic ( VARIANT * Lat, VARIANT * Lon, double * Alt ) {
    HRESULT _hr = raw_QueryPlanetodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgPosition::QuerySpherical ( VARIANT * Lat, VARIANT * Lon, double * Radius ) {
    HRESULT _hr = raw_QuerySpherical(Lat, Lon, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgPosition::QueryCylindrical ( double * Radius, VARIANT * Lon, double * Z ) {
    HRESULT _hr = raw_QueryCylindrical(Radius, Lon, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgPosition::QueryCartesian ( double * X, double * Y, double * Z ) {
    HRESULT _hr = raw_QueryCartesian(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t IAgPosition::GetCentralBodyName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CentralBodyName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

SAFEARRAY * IAgPosition::QueryPlanetocentricArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPlanetocentricArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgPosition::QueryPlanetodeticArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPlanetodeticArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgPosition::QuerySphericalArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuerySphericalArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgPosition::QueryCylindricalArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryCylindricalArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgPosition::QueryCartesianArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryCartesianArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgDirection wrapper method implementations
//

IAgDirectionPtr IAgDirection::ConvertTo ( enum AgEDirectionType Type ) {
    struct IAgDirection * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgDirectionPtr(_result, false);
}

enum AgEDirectionType IAgDirection::GetDirectionType ( ) {
    enum AgEDirectionType _result;
    HRESULT _hr = get_DirectionType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IAgDirection::Assign ( struct IAgDirection * pDirection ) {
    HRESULT _hr = raw_Assign(pDirection);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgDirection::AssignEuler ( const _variant_t & B, const _variant_t & C, enum AgEEulerDirectionSequence Sequence ) {
    HRESULT _hr = raw_AssignEuler(B, C, Sequence);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgDirection::AssignPR ( const _variant_t & Pitch, const _variant_t & Roll ) {
    HRESULT _hr = raw_AssignPR(Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgDirection::AssignRADec ( const _variant_t & RA, const _variant_t & Dec ) {
    HRESULT _hr = raw_AssignRADec(RA, Dec);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgDirection::AssignXYZ ( double X, double Y, double Z ) {
    HRESULT _hr = raw_AssignXYZ(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgDirection::QueryEuler ( enum AgEEulerDirectionSequence Sequence, VARIANT * B, VARIANT * C ) {
    HRESULT _hr = raw_QueryEuler(Sequence, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgDirection::QueryPR ( enum AgEPRSequence Sequence, VARIANT * Pitch, VARIANT * Roll ) {
    HRESULT _hr = raw_QueryPR(Sequence, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgDirection::QueryRADec ( VARIANT * RA, VARIANT * Dec ) {
    HRESULT _hr = raw_QueryRADec(RA, Dec);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgDirection::QueryXYZ ( double * X, double * Y, double * Z ) {
    HRESULT _hr = raw_QueryXYZ(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * IAgDirection::QueryEulerArray ( enum AgEEulerDirectionSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryEulerArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgDirection::QueryPRArray ( enum AgEPRSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPRArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgDirection::QueryRADecArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryRADecArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgDirection::QueryXYZArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryXYZArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgOrientation wrapper method implementations
//

IAgOrientationPtr IAgOrientation::ConvertTo ( enum AgEOrientationType Type ) {
    struct IAgOrientation * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrientationPtr(_result, false);
}

enum AgEOrientationType IAgOrientation::GetOrientationType ( ) {
    enum AgEOrientationType _result;
    HRESULT _hr = get_OrientationType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IAgOrientation::Assign ( struct IAgOrientation * pOrientation ) {
    HRESULT _hr = raw_Assign(pOrientation);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgOrientation::AssignAzEl ( const _variant_t & Azimuth, const _variant_t & Elevation, enum AgEAzElAboutBoresight AboutBoresight ) {
    HRESULT _hr = raw_AssignAzEl(Azimuth, Elevation, AboutBoresight);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgOrientation::AssignEulerAngles ( enum AgEEulerOrientationSequence Sequence, const _variant_t & A, const _variant_t & B, const _variant_t & C ) {
    HRESULT _hr = raw_AssignEulerAngles(Sequence, A, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgOrientation::AssignQuaternion ( double QX, double QY, double QZ, double QS ) {
    HRESULT _hr = raw_AssignQuaternion(QX, QY, QZ, QS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgOrientation::AssignYPRAngles ( enum AgEYPRAnglesSequence Sequence, const _variant_t & Yaw, const _variant_t & Pitch, const _variant_t & Roll ) {
    HRESULT _hr = raw_AssignYPRAngles(Sequence, Yaw, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgOrientation::QueryAzEl ( VARIANT * Azimuth, VARIANT * Elevation, enum AgEAzElAboutBoresight * AboutBoresight ) {
    HRESULT _hr = raw_QueryAzEl(Azimuth, Elevation, AboutBoresight);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgOrientation::QueryEulerAngles ( enum AgEEulerOrientationSequence Sequence, VARIANT * A, VARIANT * B, VARIANT * C ) {
    HRESULT _hr = raw_QueryEulerAngles(Sequence, A, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgOrientation::QueryQuaternion ( double * QX, double * QY, double * QZ, double * QS ) {
    HRESULT _hr = raw_QueryQuaternion(QX, QY, QZ, QS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgOrientation::QueryYPRAngles ( enum AgEYPRAnglesSequence Sequence, VARIANT * Yaw, VARIANT * Pitch, VARIANT * Roll ) {
    HRESULT _hr = raw_QueryYPRAngles(Sequence, Yaw, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * IAgOrientation::QueryAzElArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryAzElArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgOrientation::QueryEulerAnglesArray ( enum AgEEulerOrientationSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryEulerAnglesArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgOrientation::QueryQuaternionArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryQuaternionArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgOrientation::QueryYPRAnglesArray ( enum AgEYPRAnglesSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryYPRAnglesArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCartesian3Vector wrapper method implementations
//

double IAgCartesian3Vector::GetX ( ) {
    double _result = 0;
    HRESULT _hr = get_X(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCartesian3Vector::PutX ( double pRetVal ) {
    HRESULT _hr = put_X(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCartesian3Vector::GetY ( ) {
    double _result = 0;
    HRESULT _hr = get_Y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCartesian3Vector::PutY ( double pRetVal ) {
    HRESULT _hr = put_Y(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCartesian3Vector::GetZ ( ) {
    double _result = 0;
    HRESULT _hr = get_Z(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCartesian3Vector::PutZ ( double pRetVal ) {
    HRESULT _hr = put_Z(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgCartesian3Vector::Get ( double * X, double * Y, double * Z ) {
    HRESULT _hr = raw_Get(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgCartesian3Vector::Set ( double X, double Y, double Z ) {
    HRESULT _hr = raw_Set(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * IAgCartesian3Vector::ToArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_ToArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgConversionUtility wrapper method implementations
//

double _IAgConversionUtility::ConvertQuantity ( _bstr_t DimensionName, _bstr_t FromUnit, _bstr_t ToUnit, double Value ) {
    double _result = 0;
    HRESULT _hr = raw_ConvertQuantity(DimensionName, FromUnit, ToUnit, Value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgConversionUtility::ConvertDate ( _bstr_t FromUnit, _bstr_t ToUnit, _bstr_t FromValue ) {
    BSTR _result = 0;
    HRESULT _hr = raw_ConvertDate(FromUnit, ToUnit, FromValue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

SAFEARRAY * _IAgConversionUtility::ConvertQuantityArray ( _bstr_t DimensionName, _bstr_t FromUnit, _bstr_t ToUnit, SAFEARRAY * * Values ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_ConvertQuantityArray(DimensionName, FromUnit, ToUnit, Values, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgConversionUtility::ConvertDateArray ( _bstr_t FromUnit, _bstr_t ToUnit, SAFEARRAY * * FromValues ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_ConvertDateArray(FromUnit, ToUnit, FromValues, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgQuantityPtr _IAgConversionUtility::NewQuantity ( _bstr_t Dimension, _bstr_t UnitAbbrv, double Value ) {
    struct IAgQuantity * _result = 0;
    HRESULT _hr = raw_NewQuantity(Dimension, UnitAbbrv, Value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgQuantityPtr(_result, false);
}

IAgDatePtr _IAgConversionUtility::NewDate ( _bstr_t UnitAbbrv, _bstr_t Value ) {
    struct IAgDate * _result = 0;
    HRESULT _hr = raw_NewDate(UnitAbbrv, Value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgDatePtr(_result, false);
}

IAgPositionPtr _IAgConversionUtility::NewPositionOnEarth ( ) {
    struct IAgPosition * _result = 0;
    HRESULT _hr = raw_NewPositionOnEarth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgPositionPtr(_result, false);
}

SAFEARRAY * _IAgConversionUtility::ConvertPositionArray ( enum AgEPositionType PositionType, SAFEARRAY * * PositionArray, enum AgEPositionType ConvertTo ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_ConvertPositionArray(PositionType, PositionArray, ConvertTo, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgDirectionPtr _IAgConversionUtility::NewDirection ( ) {
    struct IAgDirection * _result = 0;
    HRESULT _hr = raw_NewDirection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgDirectionPtr(_result, false);
}

IAgOrientationPtr _IAgConversionUtility::NewOrientation ( ) {
    struct IAgOrientation * _result = 0;
    HRESULT _hr = raw_NewOrientation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrientationPtr(_result, false);
}

IAgOrbitStatePtr _IAgConversionUtility::NewOrbitStateOnEarth ( ) {
    struct IAgOrbitState * _result = 0;
    HRESULT _hr = raw_NewOrbitStateOnEarth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrbitStatePtr(_result, false);
}

IAgPositionPtr _IAgConversionUtility::NewPositionOnCB ( _bstr_t CentralBodyName ) {
    struct IAgPosition * _result = 0;
    HRESULT _hr = raw_NewPositionOnCB(CentralBodyName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgPositionPtr(_result, false);
}

IAgOrbitStatePtr _IAgConversionUtility::NewOrbitStateOnCB ( _bstr_t CentralBodyName ) {
    struct IAgOrbitState * _result = 0;
    HRESULT _hr = raw_NewOrbitStateOnCB(CentralBodyName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrbitStatePtr(_result, false);
}

HRESULT _IAgConversionUtility::QueryDirectionCosineMatrix ( struct IAgOrientation * InputOrientation, struct IAgCartesian3Vector * * pX, struct IAgCartesian3Vector * * pY, struct IAgCartesian3Vector * * pZ ) {
    HRESULT _hr = raw_QueryDirectionCosineMatrix(InputOrientation, pX, pY, pZ);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgConversionUtility::QueryDirectionCosineMatrixArray ( struct IAgOrientation * InputOrientation ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryDirectionCosineMatrixArray(InputOrientation, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCartesian3VectorPtr _IAgConversionUtility::NewCartesian3Vector ( ) {
    struct IAgCartesian3Vector * _result = 0;
    HRESULT _hr = raw_NewCartesian3Vector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCartesian3VectorPtr(_result, false);
}

IAgCartesian3VectorPtr _IAgConversionUtility::NewCartesian3VectorFromDirection ( struct IAgDirection * InputDirection ) {
    struct IAgCartesian3Vector * _result = 0;
    HRESULT _hr = raw_NewCartesian3VectorFromDirection(InputDirection, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCartesian3VectorPtr(_result, false);
}

IAgCartesian3VectorPtr _IAgConversionUtility::NewCartesian3VectorFromPosition ( struct IAgPosition * InputPosition ) {
    struct IAgCartesian3Vector * _result = 0;
    HRESULT _hr = raw_NewCartesian3VectorFromPosition(InputPosition, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCartesian3VectorPtr(_result, false);
}

//
// interface IAgConversionUtility wrapper method implementations
//

double IAgConversionUtility::ConvertQuantity ( _bstr_t DimensionName, _bstr_t FromUnit, _bstr_t ToUnit, double FromValue ) {
    double _result = 0;
    HRESULT _hr = raw_ConvertQuantity(DimensionName, FromUnit, ToUnit, FromValue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t IAgConversionUtility::ConvertDate ( _bstr_t FromUnit, _bstr_t ToUnit, _bstr_t FromValue ) {
    BSTR _result = 0;
    HRESULT _hr = raw_ConvertDate(FromUnit, ToUnit, FromValue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

SAFEARRAY * IAgConversionUtility::ConvertQuantityArray ( _bstr_t DimensionName, _bstr_t FromUnit, _bstr_t ToUnit, SAFEARRAY * * QuantityValues ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_ConvertQuantityArray(DimensionName, FromUnit, ToUnit, QuantityValues, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgConversionUtility::ConvertDateArray ( _bstr_t FromUnit, _bstr_t ToUnit, SAFEARRAY * * FromValues ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_ConvertDateArray(FromUnit, ToUnit, FromValues, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgQuantityPtr IAgConversionUtility::NewQuantity ( _bstr_t Dimension, _bstr_t UnitAbbrv, double Value ) {
    struct IAgQuantity * _result = 0;
    HRESULT _hr = raw_NewQuantity(Dimension, UnitAbbrv, Value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgQuantityPtr(_result, false);
}

IAgDatePtr IAgConversionUtility::NewDate ( _bstr_t UnitAbbrv, _bstr_t Value ) {
    struct IAgDate * _result = 0;
    HRESULT _hr = raw_NewDate(UnitAbbrv, Value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgDatePtr(_result, false);
}

IAgPositionPtr IAgConversionUtility::NewPositionOnEarth ( ) {
    struct IAgPosition * _result = 0;
    HRESULT _hr = raw_NewPositionOnEarth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgPositionPtr(_result, false);
}

SAFEARRAY * IAgConversionUtility::ConvertPositionArray ( enum AgEPositionType PositionType, SAFEARRAY * * PositionArray, enum AgEPositionType ConvertTo ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_ConvertPositionArray(PositionType, PositionArray, ConvertTo, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgDirectionPtr IAgConversionUtility::NewDirection ( ) {
    struct IAgDirection * _result = 0;
    HRESULT _hr = raw_NewDirection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgDirectionPtr(_result, false);
}

IAgOrientationPtr IAgConversionUtility::NewOrientation ( ) {
    struct IAgOrientation * _result = 0;
    HRESULT _hr = raw_NewOrientation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrientationPtr(_result, false);
}

IAgOrbitStatePtr IAgConversionUtility::NewOrbitStateOnEarth ( ) {
    struct IAgOrbitState * _result = 0;
    HRESULT _hr = raw_NewOrbitStateOnEarth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrbitStatePtr(_result, false);
}

IAgPositionPtr IAgConversionUtility::NewPositionOnCB ( _bstr_t CentralBodyName ) {
    struct IAgPosition * _result = 0;
    HRESULT _hr = raw_NewPositionOnCB(CentralBodyName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgPositionPtr(_result, false);
}

IAgOrbitStatePtr IAgConversionUtility::NewOrbitStateOnCB ( _bstr_t CentralBodyName ) {
    struct IAgOrbitState * _result = 0;
    HRESULT _hr = raw_NewOrbitStateOnCB(CentralBodyName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrbitStatePtr(_result, false);
}

HRESULT IAgConversionUtility::QueryDirectionCosineMatrix ( struct IAgOrientation * InputOrientation, struct IAgCartesian3Vector * * pX, struct IAgCartesian3Vector * * pY, struct IAgCartesian3Vector * * pZ ) {
    HRESULT _hr = raw_QueryDirectionCosineMatrix(InputOrientation, pX, pY, pZ);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * IAgConversionUtility::QueryDirectionCosineMatrixArray ( struct IAgOrientation * InputOrientation ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryDirectionCosineMatrixArray(InputOrientation, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCartesian3VectorPtr IAgConversionUtility::NewCartesian3Vector ( ) {
    struct IAgCartesian3Vector * _result = 0;
    HRESULT _hr = raw_NewCartesian3Vector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCartesian3VectorPtr(_result, false);
}

IAgCartesian3VectorPtr IAgConversionUtility::NewCartesian3VectorFromDirection ( struct IAgDirection * InputDirection ) {
    struct IAgCartesian3Vector * _result = 0;
    HRESULT _hr = raw_NewCartesian3VectorFromDirection(InputDirection, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCartesian3VectorPtr(_result, false);
}

IAgCartesian3VectorPtr IAgConversionUtility::NewCartesian3VectorFromPosition ( struct IAgPosition * InputPosition ) {
    struct IAgCartesian3Vector * _result = 0;
    HRESULT _hr = raw_NewCartesian3VectorFromPosition(InputPosition, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCartesian3VectorPtr(_result, false);
}

//
// interface _IAgQuantity wrapper method implementations
//

_bstr_t _IAgQuantity::GetDimension ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Dimension(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgQuantity::GetUnit ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Unit(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT _IAgQuantity::ConvertToUnit ( _bstr_t UnitAbbrv ) {
    HRESULT _hr = raw_ConvertToUnit(UnitAbbrv);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

double _IAgQuantity::GetValue ( ) {
    double _result = 0;
    HRESULT _hr = get_Value(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgQuantity::PutValue ( double pValue ) {
    HRESULT _hr = put_Value(pValue);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgQuantityPtr _IAgQuantity::Add ( struct IAgQuantity * Quantity ) {
    struct IAgQuantity * _result = 0;
    HRESULT _hr = raw_Add(Quantity, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgQuantityPtr(_result, false);
}

IAgQuantityPtr _IAgQuantity::Subtract ( struct IAgQuantity * Quantity ) {
    struct IAgQuantity * _result = 0;
    HRESULT _hr = raw_Subtract(Quantity, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgQuantityPtr(_result, false);
}

IAgQuantityPtr _IAgQuantity::MultiplyQty ( struct IAgQuantity * Quantity ) {
    struct IAgQuantity * _result = 0;
    HRESULT _hr = raw_MultiplyQty(Quantity, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgQuantityPtr(_result, false);
}

IAgQuantityPtr _IAgQuantity::DivideQty ( struct IAgQuantity * Quantity ) {
    struct IAgQuantity * _result = 0;
    HRESULT _hr = raw_DivideQty(Quantity, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgQuantityPtr(_result, false);
}

//
// interface _IAgDate wrapper method implementations
//

_bstr_t _IAgDate::Format ( _bstr_t Unit ) {
    BSTR _result = 0;
    HRESULT _hr = raw_Format(Unit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT _IAgDate::SetDate ( _bstr_t Unit, _bstr_t Value ) {
    HRESULT _hr = raw_SetDate(Unit, Value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

DATE _IAgDate::GetOLEDate ( ) {
    DATE _result = 0;
    HRESULT _hr = get_OLEDate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgDate::PutOLEDate ( DATE pDate ) {
    HRESULT _hr = put_OLEDate(pDate);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long _IAgDate::GetWholeDays ( ) {
    long _result = 0;
    HRESULT _hr = get_WholeDays(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgDate::PutWholeDays ( long pVal ) {
    HRESULT _hr = put_WholeDays(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgDate::GetSecIntoDay ( ) {
    double _result = 0;
    HRESULT _hr = get_SecIntoDay(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgDate::PutSecIntoDay ( double pVal ) {
    HRESULT _hr = put_SecIntoDay(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

long _IAgDate::GetWholeDaysUTC ( ) {
    long _result = 0;
    HRESULT _hr = get_WholeDaysUTC(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgDate::PutWholeDaysUTC ( long pVal ) {
    HRESULT _hr = put_WholeDaysUTC(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgDate::GetSecIntoDayUTC ( ) {
    double _result = 0;
    HRESULT _hr = get_SecIntoDayUTC(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgDate::PutSecIntoDayUTC ( double pVal ) {
    HRESULT _hr = put_SecIntoDayUTC(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgDatePtr _IAgDate::Add ( _bstr_t Unit, double Value ) {
    struct IAgDate * _result = 0;
    HRESULT _hr = raw_Add(Unit, Value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgDatePtr(_result, false);
}

IAgDatePtr _IAgDate::Subtract ( _bstr_t Unit, double Value ) {
    struct IAgDate * _result = 0;
    HRESULT _hr = raw_Subtract(Unit, Value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgDatePtr(_result, false);
}

IAgQuantityPtr _IAgDate::Span ( struct IAgDate * Date ) {
    struct IAgQuantity * _result = 0;
    HRESULT _hr = raw_Span(Date, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgQuantityPtr(_result, false);
}

//
// interface _IAgPosition wrapper method implementations
//

IAgPositionPtr _IAgPosition::ConvertTo ( enum AgEPositionType Type ) {
    struct IAgPosition * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgPositionPtr(_result, false);
}

enum AgEPositionType _IAgPosition::GetPosType ( ) {
    enum AgEPositionType _result;
    HRESULT _hr = get_PosType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgPosition::Assign ( struct IAgPosition * pPosition ) {
    HRESULT _hr = raw_Assign(pPosition);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPosition::AssignGeocentric ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignGeocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPosition::AssignGeodetic ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignGeodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPosition::AssignSpherical ( const _variant_t & Lat, const _variant_t & Lon, double Radius ) {
    HRESULT _hr = raw_AssignSpherical(Lat, Lon, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPosition::AssignCylindrical ( double Radius, double Z, const _variant_t & Lon ) {
    HRESULT _hr = raw_AssignCylindrical(Radius, Z, Lon);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPosition::AssignCartesian ( double X, double Y, double Z ) {
    HRESULT _hr = raw_AssignCartesian(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPosition::AssignPlanetocentric ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignPlanetocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPosition::AssignPlanetodetic ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignPlanetodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPosition::QueryPlanetocentric ( VARIANT * Lat, VARIANT * Lon, double * Alt ) {
    HRESULT _hr = raw_QueryPlanetocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPosition::QueryPlanetodetic ( VARIANT * Lat, VARIANT * Lon, double * Alt ) {
    HRESULT _hr = raw_QueryPlanetodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPosition::QuerySpherical ( VARIANT * Lat, VARIANT * Lon, double * Radius ) {
    HRESULT _hr = raw_QuerySpherical(Lat, Lon, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPosition::QueryCylindrical ( double * Radius, VARIANT * Lon, double * Z ) {
    HRESULT _hr = raw_QueryCylindrical(Radius, Lon, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPosition::QueryCartesian ( double * X, double * Y, double * Z ) {
    HRESULT _hr = raw_QueryCartesian(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t _IAgPosition::GetCentralBodyName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CentralBodyName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

SAFEARRAY * _IAgPosition::QueryPlanetocentricArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPlanetocentricArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgPosition::QueryPlanetodeticArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPlanetodeticArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgPosition::QuerySphericalArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuerySphericalArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgPosition::QueryCylindricalArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryCylindricalArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgPosition::QueryCartesianArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryCartesianArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCartesian wrapper method implementations
//

double _IAgCartesian::GetX ( ) {
    double _result = 0;
    HRESULT _hr = get_X(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCartesian::PutX ( double pVal ) {
    HRESULT _hr = put_X(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCartesian::GetY ( ) {
    double _result = 0;
    HRESULT _hr = get_Y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCartesian::PutY ( double pVal ) {
    HRESULT _hr = put_Y(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCartesian::GetZ ( ) {
    double _result = 0;
    HRESULT _hr = get_Z(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCartesian::PutZ ( double pVal ) {
    HRESULT _hr = put_Z(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgCartesian::SetValues ( double X, double Y, double Z ) {
    HRESULT _hr = raw_SetValues(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgPositionPtr _IAgCartesian::ConvertTo ( enum AgEPositionType Type ) {
    struct IAgPosition * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgPositionPtr(_result, false);
}

enum AgEPositionType _IAgCartesian::GetPosType ( ) {
    enum AgEPositionType _result;
    HRESULT _hr = get_PosType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgCartesian::Assign ( struct IAgPosition * pPosition ) {
    HRESULT _hr = raw_Assign(pPosition);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCartesian::AssignGeocentric ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignGeocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCartesian::AssignGeodetic ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignGeodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCartesian::AssignSpherical ( const _variant_t & Lat, const _variant_t & Lon, double Radius ) {
    HRESULT _hr = raw_AssignSpherical(Lat, Lon, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCartesian::AssignCylindrical ( double Radius, double Z, const _variant_t & Lon ) {
    HRESULT _hr = raw_AssignCylindrical(Radius, Z, Lon);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCartesian::AssignCartesian ( double X, double Y, double Z ) {
    HRESULT _hr = raw_AssignCartesian(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCartesian::AssignPlanetocentric ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignPlanetocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCartesian::AssignPlanetodetic ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignPlanetodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCartesian::QueryPlanetocentric ( VARIANT * Lat, VARIANT * Lon, double * Alt ) {
    HRESULT _hr = raw_QueryPlanetocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCartesian::QueryPlanetodetic ( VARIANT * Lat, VARIANT * Lon, double * Alt ) {
    HRESULT _hr = raw_QueryPlanetodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCartesian::QuerySpherical ( VARIANT * Lat, VARIANT * Lon, double * Radius ) {
    HRESULT _hr = raw_QuerySpherical(Lat, Lon, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCartesian::QueryCylindrical ( double * Radius, VARIANT * Lon, double * Z ) {
    HRESULT _hr = raw_QueryCylindrical(Radius, Lon, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCartesian::QueryCartesian ( double * X, double * Y, double * Z ) {
    HRESULT _hr = raw_QueryCartesian(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t _IAgCartesian::GetCentralBodyName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CentralBodyName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

SAFEARRAY * _IAgCartesian::QueryPlanetocentricArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPlanetocentricArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCartesian::QueryPlanetodeticArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPlanetodeticArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCartesian::QuerySphericalArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuerySphericalArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCartesian::QueryCylindricalArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryCylindricalArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCartesian::QueryCartesianArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryCartesianArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCartesian wrapper method implementations
//

double IAgCartesian::GetX ( ) {
    double _result = 0;
    HRESULT _hr = get_X(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCartesian::PutX ( double pVal ) {
    HRESULT _hr = put_X(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCartesian::GetY ( ) {
    double _result = 0;
    HRESULT _hr = get_Y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCartesian::PutY ( double pVal ) {
    HRESULT _hr = put_Y(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCartesian::GetZ ( ) {
    double _result = 0;
    HRESULT _hr = get_Z(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCartesian::PutZ ( double pVal ) {
    HRESULT _hr = put_Z(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgCartesian::SetValues ( double X, double Y, double Z ) {
    HRESULT _hr = raw_SetValues(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgGeodetic wrapper method implementations
//

_variant_t _IAgGeodetic::GetLat ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lat(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgGeodetic::PutLat ( const _variant_t & pLat ) {
    HRESULT _hr = put_Lat(pLat);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgGeodetic::GetLon ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgGeodetic::PutLon ( const _variant_t & pLon ) {
    HRESULT _hr = put_Lon(pLon);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgGeodetic::GetAlt ( ) {
    double _result = 0;
    HRESULT _hr = get_Alt(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgGeodetic::PutAlt ( double pAlt ) {
    HRESULT _hr = put_Alt(pAlt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgGeodetic::SetValues ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_SetValues(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgPositionPtr _IAgGeodetic::ConvertTo ( enum AgEPositionType Type ) {
    struct IAgPosition * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgPositionPtr(_result, false);
}

enum AgEPositionType _IAgGeodetic::GetPosType ( ) {
    enum AgEPositionType _result;
    HRESULT _hr = get_PosType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgGeodetic::Assign ( struct IAgPosition * pPosition ) {
    HRESULT _hr = raw_Assign(pPosition);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeodetic::AssignGeocentric ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignGeocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeodetic::AssignGeodetic ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignGeodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeodetic::AssignSpherical ( const _variant_t & Lat, const _variant_t & Lon, double Radius ) {
    HRESULT _hr = raw_AssignSpherical(Lat, Lon, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeodetic::AssignCylindrical ( double Radius, double Z, const _variant_t & Lon ) {
    HRESULT _hr = raw_AssignCylindrical(Radius, Z, Lon);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeodetic::AssignCartesian ( double X, double Y, double Z ) {
    HRESULT _hr = raw_AssignCartesian(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeodetic::AssignPlanetocentric ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignPlanetocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeodetic::AssignPlanetodetic ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignPlanetodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeodetic::QueryPlanetocentric ( VARIANT * Lat, VARIANT * Lon, double * Alt ) {
    HRESULT _hr = raw_QueryPlanetocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeodetic::QueryPlanetodetic ( VARIANT * Lat, VARIANT * Lon, double * Alt ) {
    HRESULT _hr = raw_QueryPlanetodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeodetic::QuerySpherical ( VARIANT * Lat, VARIANT * Lon, double * Radius ) {
    HRESULT _hr = raw_QuerySpherical(Lat, Lon, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeodetic::QueryCylindrical ( double * Radius, VARIANT * Lon, double * Z ) {
    HRESULT _hr = raw_QueryCylindrical(Radius, Lon, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeodetic::QueryCartesian ( double * X, double * Y, double * Z ) {
    HRESULT _hr = raw_QueryCartesian(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t _IAgGeodetic::GetCentralBodyName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CentralBodyName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

SAFEARRAY * _IAgGeodetic::QueryPlanetocentricArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPlanetocentricArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgGeodetic::QueryPlanetodeticArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPlanetodeticArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgGeodetic::QuerySphericalArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuerySphericalArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgGeodetic::QueryCylindricalArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryCylindricalArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgGeodetic::QueryCartesianArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryCartesianArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgGeodetic wrapper method implementations
//

_variant_t IAgGeodetic::GetLat ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lat(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgGeodetic::PutLat ( const _variant_t & pLat ) {
    HRESULT _hr = put_Lat(pLat);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t IAgGeodetic::GetLon ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgGeodetic::PutLon ( const _variant_t & pLon ) {
    HRESULT _hr = put_Lon(pLon);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgGeodetic::GetAlt ( ) {
    double _result = 0;
    HRESULT _hr = get_Alt(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgGeodetic::PutAlt ( double pAlt ) {
    HRESULT _hr = put_Alt(pAlt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgGeodetic::SetValues ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_SetValues(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgGeocentric wrapper method implementations
//

_variant_t _IAgGeocentric::GetLat ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lat(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgGeocentric::PutLat ( const _variant_t & pVal ) {
    HRESULT _hr = put_Lat(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgGeocentric::GetLon ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgGeocentric::PutLon ( const _variant_t & pVal ) {
    HRESULT _hr = put_Lon(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgGeocentric::GetAlt ( ) {
    double _result = 0;
    HRESULT _hr = get_Alt(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgGeocentric::PutAlt ( double pVal ) {
    HRESULT _hr = put_Alt(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgGeocentric::SetValues ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_SetValues(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgPositionPtr _IAgGeocentric::ConvertTo ( enum AgEPositionType Type ) {
    struct IAgPosition * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgPositionPtr(_result, false);
}

enum AgEPositionType _IAgGeocentric::GetPosType ( ) {
    enum AgEPositionType _result;
    HRESULT _hr = get_PosType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgGeocentric::Assign ( struct IAgPosition * pPosition ) {
    HRESULT _hr = raw_Assign(pPosition);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeocentric::AssignGeocentric ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignGeocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeocentric::AssignGeodetic ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignGeodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeocentric::AssignSpherical ( const _variant_t & Lat, const _variant_t & Lon, double Radius ) {
    HRESULT _hr = raw_AssignSpherical(Lat, Lon, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeocentric::AssignCylindrical ( double Radius, double Z, const _variant_t & Lon ) {
    HRESULT _hr = raw_AssignCylindrical(Radius, Z, Lon);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeocentric::AssignCartesian ( double X, double Y, double Z ) {
    HRESULT _hr = raw_AssignCartesian(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeocentric::AssignPlanetocentric ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignPlanetocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeocentric::AssignPlanetodetic ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignPlanetodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeocentric::QueryPlanetocentric ( VARIANT * Lat, VARIANT * Lon, double * Alt ) {
    HRESULT _hr = raw_QueryPlanetocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeocentric::QueryPlanetodetic ( VARIANT * Lat, VARIANT * Lon, double * Alt ) {
    HRESULT _hr = raw_QueryPlanetodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeocentric::QuerySpherical ( VARIANT * Lat, VARIANT * Lon, double * Radius ) {
    HRESULT _hr = raw_QuerySpherical(Lat, Lon, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeocentric::QueryCylindrical ( double * Radius, VARIANT * Lon, double * Z ) {
    HRESULT _hr = raw_QueryCylindrical(Radius, Lon, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgGeocentric::QueryCartesian ( double * X, double * Y, double * Z ) {
    HRESULT _hr = raw_QueryCartesian(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t _IAgGeocentric::GetCentralBodyName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CentralBodyName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

SAFEARRAY * _IAgGeocentric::QueryPlanetocentricArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPlanetocentricArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgGeocentric::QueryPlanetodeticArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPlanetodeticArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgGeocentric::QuerySphericalArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuerySphericalArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgGeocentric::QueryCylindricalArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryCylindricalArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgGeocentric::QueryCartesianArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryCartesianArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgGeocentric wrapper method implementations
//

_variant_t IAgGeocentric::GetLat ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lat(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgGeocentric::PutLat ( const _variant_t & pVal ) {
    HRESULT _hr = put_Lat(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t IAgGeocentric::GetLon ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgGeocentric::PutLon ( const _variant_t & pVal ) {
    HRESULT _hr = put_Lon(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgGeocentric::GetAlt ( ) {
    double _result = 0;
    HRESULT _hr = get_Alt(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgGeocentric::PutAlt ( double pVal ) {
    HRESULT _hr = put_Alt(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgGeocentric::SetValues ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_SetValues(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgPlanetodetic wrapper method implementations
//

_variant_t _IAgPlanetodetic::GetLat ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lat(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgPlanetodetic::PutLat ( const _variant_t & pLat ) {
    HRESULT _hr = put_Lat(pLat);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgPlanetodetic::GetLon ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgPlanetodetic::PutLon ( const _variant_t & pLon ) {
    HRESULT _hr = put_Lon(pLon);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgPlanetodetic::GetAlt ( ) {
    double _result = 0;
    HRESULT _hr = get_Alt(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgPlanetodetic::PutAlt ( double pAlt ) {
    HRESULT _hr = put_Alt(pAlt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgPositionPtr _IAgPlanetodetic::ConvertTo ( enum AgEPositionType Type ) {
    struct IAgPosition * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgPositionPtr(_result, false);
}

enum AgEPositionType _IAgPlanetodetic::GetPosType ( ) {
    enum AgEPositionType _result;
    HRESULT _hr = get_PosType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgPlanetodetic::Assign ( struct IAgPosition * pPosition ) {
    HRESULT _hr = raw_Assign(pPosition);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetodetic::AssignGeocentric ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignGeocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetodetic::AssignGeodetic ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignGeodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetodetic::AssignSpherical ( const _variant_t & Lat, const _variant_t & Lon, double Radius ) {
    HRESULT _hr = raw_AssignSpherical(Lat, Lon, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetodetic::AssignCylindrical ( double Radius, double Z, const _variant_t & Lon ) {
    HRESULT _hr = raw_AssignCylindrical(Radius, Z, Lon);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetodetic::AssignCartesian ( double X, double Y, double Z ) {
    HRESULT _hr = raw_AssignCartesian(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetodetic::AssignPlanetocentric ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignPlanetocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetodetic::AssignPlanetodetic ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignPlanetodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetodetic::QueryPlanetocentric ( VARIANT * Lat, VARIANT * Lon, double * Alt ) {
    HRESULT _hr = raw_QueryPlanetocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetodetic::QueryPlanetodetic ( VARIANT * Lat, VARIANT * Lon, double * Alt ) {
    HRESULT _hr = raw_QueryPlanetodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetodetic::QuerySpherical ( VARIANT * Lat, VARIANT * Lon, double * Radius ) {
    HRESULT _hr = raw_QuerySpherical(Lat, Lon, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetodetic::QueryCylindrical ( double * Radius, VARIANT * Lon, double * Z ) {
    HRESULT _hr = raw_QueryCylindrical(Radius, Lon, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetodetic::QueryCartesian ( double * X, double * Y, double * Z ) {
    HRESULT _hr = raw_QueryCartesian(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t _IAgPlanetodetic::GetCentralBodyName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CentralBodyName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

SAFEARRAY * _IAgPlanetodetic::QueryPlanetocentricArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPlanetocentricArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgPlanetodetic::QueryPlanetodeticArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPlanetodeticArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgPlanetodetic::QuerySphericalArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuerySphericalArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgPlanetodetic::QueryCylindricalArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryCylindricalArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgPlanetodetic::QueryCartesianArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryCartesianArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgPlanetodetic wrapper method implementations
//

_variant_t IAgPlanetodetic::GetLat ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lat(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgPlanetodetic::PutLat ( const _variant_t & pLat ) {
    HRESULT _hr = put_Lat(pLat);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t IAgPlanetodetic::GetLon ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgPlanetodetic::PutLon ( const _variant_t & pLon ) {
    HRESULT _hr = put_Lon(pLon);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgPlanetodetic::GetAlt ( ) {
    double _result = 0;
    HRESULT _hr = get_Alt(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgPlanetodetic::PutAlt ( double pAlt ) {
    HRESULT _hr = put_Alt(pAlt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgPlanetocentric wrapper method implementations
//

_variant_t _IAgPlanetocentric::GetLat ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lat(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgPlanetocentric::PutLat ( const _variant_t & pVal ) {
    HRESULT _hr = put_Lat(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgPlanetocentric::GetLon ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgPlanetocentric::PutLon ( const _variant_t & pVal ) {
    HRESULT _hr = put_Lon(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgPlanetocentric::GetAlt ( ) {
    double _result = 0;
    HRESULT _hr = get_Alt(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgPlanetocentric::PutAlt ( double pVal ) {
    HRESULT _hr = put_Alt(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgPositionPtr _IAgPlanetocentric::ConvertTo ( enum AgEPositionType Type ) {
    struct IAgPosition * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgPositionPtr(_result, false);
}

enum AgEPositionType _IAgPlanetocentric::GetPosType ( ) {
    enum AgEPositionType _result;
    HRESULT _hr = get_PosType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgPlanetocentric::Assign ( struct IAgPosition * pPosition ) {
    HRESULT _hr = raw_Assign(pPosition);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetocentric::AssignGeocentric ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignGeocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetocentric::AssignGeodetic ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignGeodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetocentric::AssignSpherical ( const _variant_t & Lat, const _variant_t & Lon, double Radius ) {
    HRESULT _hr = raw_AssignSpherical(Lat, Lon, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetocentric::AssignCylindrical ( double Radius, double Z, const _variant_t & Lon ) {
    HRESULT _hr = raw_AssignCylindrical(Radius, Z, Lon);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetocentric::AssignCartesian ( double X, double Y, double Z ) {
    HRESULT _hr = raw_AssignCartesian(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetocentric::AssignPlanetocentric ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignPlanetocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetocentric::AssignPlanetodetic ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignPlanetodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetocentric::QueryPlanetocentric ( VARIANT * Lat, VARIANT * Lon, double * Alt ) {
    HRESULT _hr = raw_QueryPlanetocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetocentric::QueryPlanetodetic ( VARIANT * Lat, VARIANT * Lon, double * Alt ) {
    HRESULT _hr = raw_QueryPlanetodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetocentric::QuerySpherical ( VARIANT * Lat, VARIANT * Lon, double * Radius ) {
    HRESULT _hr = raw_QuerySpherical(Lat, Lon, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetocentric::QueryCylindrical ( double * Radius, VARIANT * Lon, double * Z ) {
    HRESULT _hr = raw_QueryCylindrical(Radius, Lon, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgPlanetocentric::QueryCartesian ( double * X, double * Y, double * Z ) {
    HRESULT _hr = raw_QueryCartesian(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t _IAgPlanetocentric::GetCentralBodyName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CentralBodyName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

SAFEARRAY * _IAgPlanetocentric::QueryPlanetocentricArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPlanetocentricArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgPlanetocentric::QueryPlanetodeticArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPlanetodeticArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgPlanetocentric::QuerySphericalArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuerySphericalArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgPlanetocentric::QueryCylindricalArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryCylindricalArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgPlanetocentric::QueryCartesianArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryCartesianArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgPlanetocentric wrapper method implementations
//

_variant_t IAgPlanetocentric::GetLat ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lat(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgPlanetocentric::PutLat ( const _variant_t & pVal ) {
    HRESULT _hr = put_Lat(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t IAgPlanetocentric::GetLon ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgPlanetocentric::PutLon ( const _variant_t & pVal ) {
    HRESULT _hr = put_Lon(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgPlanetocentric::GetAlt ( ) {
    double _result = 0;
    HRESULT _hr = get_Alt(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgPlanetocentric::PutAlt ( double pVal ) {
    HRESULT _hr = put_Alt(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgSpherical wrapper method implementations
//

_variant_t _IAgSpherical::GetLat ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lat(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgSpherical::PutLat ( const _variant_t & pVal ) {
    HRESULT _hr = put_Lat(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgSpherical::GetLon ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgSpherical::PutLon ( const _variant_t & pVal ) {
    HRESULT _hr = put_Lon(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgSpherical::GetRadius ( ) {
    double _result = 0;
    HRESULT _hr = get_Radius(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgSpherical::PutRadius ( double pVal ) {
    HRESULT _hr = put_Radius(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgSpherical::SetValues ( const _variant_t & Lat, const _variant_t & Lon, double Radius ) {
    HRESULT _hr = raw_SetValues(Lat, Lon, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgPositionPtr _IAgSpherical::ConvertTo ( enum AgEPositionType Type ) {
    struct IAgPosition * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgPositionPtr(_result, false);
}

enum AgEPositionType _IAgSpherical::GetPosType ( ) {
    enum AgEPositionType _result;
    HRESULT _hr = get_PosType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgSpherical::Assign ( struct IAgPosition * pPosition ) {
    HRESULT _hr = raw_Assign(pPosition);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgSpherical::AssignGeocentric ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignGeocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgSpherical::AssignGeodetic ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignGeodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgSpherical::AssignSpherical ( const _variant_t & Lat, const _variant_t & Lon, double Radius ) {
    HRESULT _hr = raw_AssignSpherical(Lat, Lon, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgSpherical::AssignCylindrical ( double Radius, double Z, const _variant_t & Lon ) {
    HRESULT _hr = raw_AssignCylindrical(Radius, Z, Lon);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgSpherical::AssignCartesian ( double X, double Y, double Z ) {
    HRESULT _hr = raw_AssignCartesian(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgSpherical::AssignPlanetocentric ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignPlanetocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgSpherical::AssignPlanetodetic ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignPlanetodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgSpherical::QueryPlanetocentric ( VARIANT * Lat, VARIANT * Lon, double * Alt ) {
    HRESULT _hr = raw_QueryPlanetocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgSpherical::QueryPlanetodetic ( VARIANT * Lat, VARIANT * Lon, double * Alt ) {
    HRESULT _hr = raw_QueryPlanetodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgSpherical::QuerySpherical ( VARIANT * Lat, VARIANT * Lon, double * Radius ) {
    HRESULT _hr = raw_QuerySpherical(Lat, Lon, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgSpherical::QueryCylindrical ( double * Radius, VARIANT * Lon, double * Z ) {
    HRESULT _hr = raw_QueryCylindrical(Radius, Lon, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgSpherical::QueryCartesian ( double * X, double * Y, double * Z ) {
    HRESULT _hr = raw_QueryCartesian(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t _IAgSpherical::GetCentralBodyName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CentralBodyName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

SAFEARRAY * _IAgSpherical::QueryPlanetocentricArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPlanetocentricArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgSpherical::QueryPlanetodeticArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPlanetodeticArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgSpherical::QuerySphericalArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuerySphericalArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgSpherical::QueryCylindricalArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryCylindricalArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgSpherical::QueryCartesianArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryCartesianArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgSpherical wrapper method implementations
//

_variant_t IAgSpherical::GetLat ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lat(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgSpherical::PutLat ( const _variant_t & pVal ) {
    HRESULT _hr = put_Lat(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t IAgSpherical::GetLon ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgSpherical::PutLon ( const _variant_t & pVal ) {
    HRESULT _hr = put_Lon(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgSpherical::GetRadius ( ) {
    double _result = 0;
    HRESULT _hr = get_Radius(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgSpherical::PutRadius ( double pVal ) {
    HRESULT _hr = put_Radius(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgSpherical::SetValues ( const _variant_t & Lat, const _variant_t & Lon, double Radius ) {
    HRESULT _hr = raw_SetValues(Lat, Lon, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCylindrical wrapper method implementations
//

double _IAgCylindrical::GetRadius ( ) {
    double _result = 0;
    HRESULT _hr = get_Radius(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCylindrical::PutRadius ( double pVal ) {
    HRESULT _hr = put_Radius(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCylindrical::GetZ ( ) {
    double _result = 0;
    HRESULT _hr = get_Z(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCylindrical::PutZ ( double pVal ) {
    HRESULT _hr = put_Z(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgCylindrical::GetLon ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgCylindrical::PutLon ( const _variant_t & pVal ) {
    HRESULT _hr = put_Lon(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgCylindrical::SetValues ( double Radius, double Z, const _variant_t & Lon ) {
    HRESULT _hr = raw_SetValues(Radius, Z, Lon);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgPositionPtr _IAgCylindrical::ConvertTo ( enum AgEPositionType Type ) {
    struct IAgPosition * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgPositionPtr(_result, false);
}

enum AgEPositionType _IAgCylindrical::GetPosType ( ) {
    enum AgEPositionType _result;
    HRESULT _hr = get_PosType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgCylindrical::Assign ( struct IAgPosition * pPosition ) {
    HRESULT _hr = raw_Assign(pPosition);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCylindrical::AssignGeocentric ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignGeocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCylindrical::AssignGeodetic ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignGeodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCylindrical::AssignSpherical ( const _variant_t & Lat, const _variant_t & Lon, double Radius ) {
    HRESULT _hr = raw_AssignSpherical(Lat, Lon, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCylindrical::AssignCylindrical ( double Radius, double Z, const _variant_t & Lon ) {
    HRESULT _hr = raw_AssignCylindrical(Radius, Z, Lon);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCylindrical::AssignCartesian ( double X, double Y, double Z ) {
    HRESULT _hr = raw_AssignCartesian(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCylindrical::AssignPlanetocentric ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignPlanetocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCylindrical::AssignPlanetodetic ( const _variant_t & Lat, const _variant_t & Lon, double Alt ) {
    HRESULT _hr = raw_AssignPlanetodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCylindrical::QueryPlanetocentric ( VARIANT * Lat, VARIANT * Lon, double * Alt ) {
    HRESULT _hr = raw_QueryPlanetocentric(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCylindrical::QueryPlanetodetic ( VARIANT * Lat, VARIANT * Lon, double * Alt ) {
    HRESULT _hr = raw_QueryPlanetodetic(Lat, Lon, Alt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCylindrical::QuerySpherical ( VARIANT * Lat, VARIANT * Lon, double * Radius ) {
    HRESULT _hr = raw_QuerySpherical(Lat, Lon, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCylindrical::QueryCylindrical ( double * Radius, VARIANT * Lon, double * Z ) {
    HRESULT _hr = raw_QueryCylindrical(Radius, Lon, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCylindrical::QueryCartesian ( double * X, double * Y, double * Z ) {
    HRESULT _hr = raw_QueryCartesian(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t _IAgCylindrical::GetCentralBodyName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CentralBodyName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

SAFEARRAY * _IAgCylindrical::QueryPlanetocentricArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPlanetocentricArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCylindrical::QueryPlanetodeticArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPlanetodeticArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCylindrical::QuerySphericalArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuerySphericalArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCylindrical::QueryCylindricalArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryCylindricalArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCylindrical::QueryCartesianArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryCartesianArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCylindrical wrapper method implementations
//

double IAgCylindrical::GetRadius ( ) {
    double _result = 0;
    HRESULT _hr = get_Radius(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCylindrical::PutRadius ( double pVal ) {
    HRESULT _hr = put_Radius(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCylindrical::GetZ ( ) {
    double _result = 0;
    HRESULT _hr = get_Z(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCylindrical::PutZ ( double pVal ) {
    HRESULT _hr = put_Z(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t IAgCylindrical::GetLon ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Lon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgCylindrical::PutLon ( const _variant_t & pVal ) {
    HRESULT _hr = put_Lon(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgCylindrical::SetValues ( double Radius, double Z, const _variant_t & Lon ) {
    HRESULT _hr = raw_SetValues(Radius, Z, Lon);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgDirection wrapper method implementations
//

IAgDirectionPtr _IAgDirection::ConvertTo ( enum AgEDirectionType Type ) {
    struct IAgDirection * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgDirectionPtr(_result, false);
}

enum AgEDirectionType _IAgDirection::GetDirectionType ( ) {
    enum AgEDirectionType _result;
    HRESULT _hr = get_DirectionType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgDirection::Assign ( struct IAgDirection * pDirection ) {
    HRESULT _hr = raw_Assign(pDirection);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirection::AssignEuler ( const _variant_t & B, const _variant_t & C, enum AgEEulerDirectionSequence Sequence ) {
    HRESULT _hr = raw_AssignEuler(B, C, Sequence);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirection::AssignPR ( const _variant_t & Pitch, const _variant_t & Roll ) {
    HRESULT _hr = raw_AssignPR(Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirection::AssignRADec ( const _variant_t & RA, const _variant_t & Dec ) {
    HRESULT _hr = raw_AssignRADec(RA, Dec);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirection::AssignXYZ ( double X, double Y, double Z ) {
    HRESULT _hr = raw_AssignXYZ(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirection::QueryEuler ( enum AgEEulerDirectionSequence Sequence, VARIANT * B, VARIANT * C ) {
    HRESULT _hr = raw_QueryEuler(Sequence, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirection::QueryPR ( enum AgEPRSequence Sequence, VARIANT * Pitch, VARIANT * Roll ) {
    HRESULT _hr = raw_QueryPR(Sequence, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirection::QueryRADec ( VARIANT * RA, VARIANT * Dec ) {
    HRESULT _hr = raw_QueryRADec(RA, Dec);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirection::QueryXYZ ( double * X, double * Y, double * Z ) {
    HRESULT _hr = raw_QueryXYZ(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgDirection::QueryEulerArray ( enum AgEEulerDirectionSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryEulerArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgDirection::QueryPRArray ( enum AgEPRSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPRArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgDirection::QueryRADecArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryRADecArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgDirection::QueryXYZArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryXYZArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgDirectionEuler wrapper method implementations
//

_variant_t _IAgDirectionEuler::GetB ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_B(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgDirectionEuler::PutB ( const _variant_t & pVal ) {
    HRESULT _hr = put_B(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgDirectionEuler::GetC ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_C(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgDirectionEuler::PutC ( const _variant_t & pVal ) {
    HRESULT _hr = put_C(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgEEulerDirectionSequence _IAgDirectionEuler::GetSequence ( ) {
    enum AgEEulerDirectionSequence _result;
    HRESULT _hr = get_Sequence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgDirectionEuler::PutSequence ( enum AgEEulerDirectionSequence pVal ) {
    HRESULT _hr = put_Sequence(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgDirectionEuler::SetValues ( const _variant_t & B, const _variant_t & C, enum AgEEulerDirectionSequence Sequence ) {
    HRESULT _hr = raw_SetValues(B, C, Sequence);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgDirectionPtr _IAgDirectionEuler::ConvertTo ( enum AgEDirectionType Type ) {
    struct IAgDirection * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgDirectionPtr(_result, false);
}

enum AgEDirectionType _IAgDirectionEuler::GetDirectionType ( ) {
    enum AgEDirectionType _result;
    HRESULT _hr = get_DirectionType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgDirectionEuler::Assign ( struct IAgDirection * pDirection ) {
    HRESULT _hr = raw_Assign(pDirection);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionEuler::AssignEuler ( const _variant_t & B, const _variant_t & C, enum AgEEulerDirectionSequence Sequence ) {
    HRESULT _hr = raw_AssignEuler(B, C, Sequence);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionEuler::AssignPR ( const _variant_t & Pitch, const _variant_t & Roll ) {
    HRESULT _hr = raw_AssignPR(Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionEuler::AssignRADec ( const _variant_t & RA, const _variant_t & Dec ) {
    HRESULT _hr = raw_AssignRADec(RA, Dec);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionEuler::AssignXYZ ( double X, double Y, double Z ) {
    HRESULT _hr = raw_AssignXYZ(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionEuler::QueryEuler ( enum AgEEulerDirectionSequence Sequence, VARIANT * B, VARIANT * C ) {
    HRESULT _hr = raw_QueryEuler(Sequence, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionEuler::QueryPR ( enum AgEPRSequence Sequence, VARIANT * Pitch, VARIANT * Roll ) {
    HRESULT _hr = raw_QueryPR(Sequence, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionEuler::QueryRADec ( VARIANT * RA, VARIANT * Dec ) {
    HRESULT _hr = raw_QueryRADec(RA, Dec);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionEuler::QueryXYZ ( double * X, double * Y, double * Z ) {
    HRESULT _hr = raw_QueryXYZ(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgDirectionEuler::QueryEulerArray ( enum AgEEulerDirectionSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryEulerArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgDirectionEuler::QueryPRArray ( enum AgEPRSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPRArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgDirectionEuler::QueryRADecArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryRADecArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgDirectionEuler::QueryXYZArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryXYZArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgDirectionEuler wrapper method implementations
//

_variant_t IAgDirectionEuler::GetB ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_B(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgDirectionEuler::PutB ( const _variant_t & pVal ) {
    HRESULT _hr = put_B(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t IAgDirectionEuler::GetC ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_C(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgDirectionEuler::PutC ( const _variant_t & pVal ) {
    HRESULT _hr = put_C(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgEEulerDirectionSequence IAgDirectionEuler::GetSequence ( ) {
    enum AgEEulerDirectionSequence _result;
    HRESULT _hr = get_Sequence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgDirectionEuler::PutSequence ( enum AgEEulerDirectionSequence pVal ) {
    HRESULT _hr = put_Sequence(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgDirectionEuler::SetValues ( const _variant_t & B, const _variant_t & C, enum AgEEulerDirectionSequence Sequence ) {
    HRESULT _hr = raw_SetValues(B, C, Sequence);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgDirectionPR wrapper method implementations
//

_variant_t _IAgDirectionPR::GetPitch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Pitch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgDirectionPR::PutPitch ( const _variant_t & pVal ) {
    HRESULT _hr = put_Pitch(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgDirectionPR::GetRoll ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Roll(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgDirectionPR::PutRoll ( const _variant_t & pVal ) {
    HRESULT _hr = put_Roll(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgEPRSequence _IAgDirectionPR::GetSequence ( ) {
    enum AgEPRSequence _result;
    HRESULT _hr = get_Sequence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgDirectionPR::PutSequence ( enum AgEPRSequence pVal ) {
    HRESULT _hr = put_Sequence(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgDirectionPR::SetValues ( const _variant_t & Pitch, const _variant_t & Roll ) {
    HRESULT _hr = raw_SetValues(Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgDirectionPtr _IAgDirectionPR::ConvertTo ( enum AgEDirectionType Type ) {
    struct IAgDirection * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgDirectionPtr(_result, false);
}

enum AgEDirectionType _IAgDirectionPR::GetDirectionType ( ) {
    enum AgEDirectionType _result;
    HRESULT _hr = get_DirectionType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgDirectionPR::Assign ( struct IAgDirection * pDirection ) {
    HRESULT _hr = raw_Assign(pDirection);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionPR::AssignEuler ( const _variant_t & B, const _variant_t & C, enum AgEEulerDirectionSequence Sequence ) {
    HRESULT _hr = raw_AssignEuler(B, C, Sequence);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionPR::AssignPR ( const _variant_t & Pitch, const _variant_t & Roll ) {
    HRESULT _hr = raw_AssignPR(Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionPR::AssignRADec ( const _variant_t & RA, const _variant_t & Dec ) {
    HRESULT _hr = raw_AssignRADec(RA, Dec);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionPR::AssignXYZ ( double X, double Y, double Z ) {
    HRESULT _hr = raw_AssignXYZ(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionPR::QueryEuler ( enum AgEEulerDirectionSequence Sequence, VARIANT * B, VARIANT * C ) {
    HRESULT _hr = raw_QueryEuler(Sequence, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionPR::QueryPR ( enum AgEPRSequence Sequence, VARIANT * Pitch, VARIANT * Roll ) {
    HRESULT _hr = raw_QueryPR(Sequence, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionPR::QueryRADec ( VARIANT * RA, VARIANT * Dec ) {
    HRESULT _hr = raw_QueryRADec(RA, Dec);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionPR::QueryXYZ ( double * X, double * Y, double * Z ) {
    HRESULT _hr = raw_QueryXYZ(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgDirectionPR::QueryEulerArray ( enum AgEEulerDirectionSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryEulerArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgDirectionPR::QueryPRArray ( enum AgEPRSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPRArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgDirectionPR::QueryRADecArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryRADecArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgDirectionPR::QueryXYZArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryXYZArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgDirectionPR wrapper method implementations
//

_variant_t IAgDirectionPR::GetPitch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Pitch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgDirectionPR::PutPitch ( const _variant_t & pVal ) {
    HRESULT _hr = put_Pitch(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t IAgDirectionPR::GetRoll ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Roll(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgDirectionPR::PutRoll ( const _variant_t & pVal ) {
    HRESULT _hr = put_Roll(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgEPRSequence IAgDirectionPR::GetSequence ( ) {
    enum AgEPRSequence _result;
    HRESULT _hr = get_Sequence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgDirectionPR::PutSequence ( enum AgEPRSequence pVal ) {
    HRESULT _hr = put_Sequence(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgDirectionPR::SetValues ( const _variant_t & Pitch, const _variant_t & Roll ) {
    HRESULT _hr = raw_SetValues(Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgDirectionRADec wrapper method implementations
//

_variant_t _IAgDirectionRADec::GetDec ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Dec(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgDirectionRADec::PutDec ( const _variant_t & pVal ) {
    HRESULT _hr = put_Dec(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgDirectionRADec::GetRA ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_RA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgDirectionRADec::PutRA ( const _variant_t & pVal ) {
    HRESULT _hr = put_RA(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgDirectionRADec::SetValues ( const _variant_t & RA, const _variant_t & Dec ) {
    HRESULT _hr = raw_SetValues(RA, Dec);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgDirectionPtr _IAgDirectionRADec::ConvertTo ( enum AgEDirectionType Type ) {
    struct IAgDirection * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgDirectionPtr(_result, false);
}

enum AgEDirectionType _IAgDirectionRADec::GetDirectionType ( ) {
    enum AgEDirectionType _result;
    HRESULT _hr = get_DirectionType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgDirectionRADec::Assign ( struct IAgDirection * pDirection ) {
    HRESULT _hr = raw_Assign(pDirection);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionRADec::AssignEuler ( const _variant_t & B, const _variant_t & C, enum AgEEulerDirectionSequence Sequence ) {
    HRESULT _hr = raw_AssignEuler(B, C, Sequence);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionRADec::AssignPR ( const _variant_t & Pitch, const _variant_t & Roll ) {
    HRESULT _hr = raw_AssignPR(Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionRADec::AssignRADec ( const _variant_t & RA, const _variant_t & Dec ) {
    HRESULT _hr = raw_AssignRADec(RA, Dec);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionRADec::AssignXYZ ( double X, double Y, double Z ) {
    HRESULT _hr = raw_AssignXYZ(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionRADec::QueryEuler ( enum AgEEulerDirectionSequence Sequence, VARIANT * B, VARIANT * C ) {
    HRESULT _hr = raw_QueryEuler(Sequence, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionRADec::QueryPR ( enum AgEPRSequence Sequence, VARIANT * Pitch, VARIANT * Roll ) {
    HRESULT _hr = raw_QueryPR(Sequence, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionRADec::QueryRADec ( VARIANT * RA, VARIANT * Dec ) {
    HRESULT _hr = raw_QueryRADec(RA, Dec);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionRADec::QueryXYZ ( double * X, double * Y, double * Z ) {
    HRESULT _hr = raw_QueryXYZ(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgDirectionRADec::QueryEulerArray ( enum AgEEulerDirectionSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryEulerArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgDirectionRADec::QueryPRArray ( enum AgEPRSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPRArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgDirectionRADec::QueryRADecArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryRADecArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgDirectionRADec::QueryXYZArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryXYZArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

double _IAgDirectionRADec::GetMagnitude ( ) {
    double _result = 0;
    HRESULT _hr = get_Magnitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgDirectionRADec::PutMagnitude ( double pVal ) {
    HRESULT _hr = put_Magnitude(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgDirectionRADec wrapper method implementations
//

_variant_t IAgDirectionRADec::GetDec ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Dec(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgDirectionRADec::PutDec ( const _variant_t & pVal ) {
    HRESULT _hr = put_Dec(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t IAgDirectionRADec::GetRA ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_RA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgDirectionRADec::PutRA ( const _variant_t & pVal ) {
    HRESULT _hr = put_RA(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgDirectionRADec::SetValues ( const _variant_t & RA, const _variant_t & Dec ) {
    HRESULT _hr = raw_SetValues(RA, Dec);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

double IAgDirectionRADec::GetMagnitude ( ) {
    double _result = 0;
    HRESULT _hr = get_Magnitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgDirectionRADec::PutMagnitude ( double pVal ) {
    HRESULT _hr = put_Magnitude(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgDirectionXYZ wrapper method implementations
//

double _IAgDirectionXYZ::GetX ( ) {
    double _result = 0;
    HRESULT _hr = get_X(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgDirectionXYZ::PutX ( double pVal ) {
    HRESULT _hr = put_X(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgDirectionXYZ::GetY ( ) {
    double _result = 0;
    HRESULT _hr = get_Y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgDirectionXYZ::PutY ( double pVal ) {
    HRESULT _hr = put_Y(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgDirectionXYZ::GetZ ( ) {
    double _result = 0;
    HRESULT _hr = get_Z(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgDirectionXYZ::PutZ ( double pVal ) {
    HRESULT _hr = put_Z(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgDirectionXYZ::SetValues ( double X, double Y, double Z ) {
    HRESULT _hr = raw_SetValues(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgDirectionPtr _IAgDirectionXYZ::ConvertTo ( enum AgEDirectionType Type ) {
    struct IAgDirection * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgDirectionPtr(_result, false);
}

enum AgEDirectionType _IAgDirectionXYZ::GetDirectionType ( ) {
    enum AgEDirectionType _result;
    HRESULT _hr = get_DirectionType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgDirectionXYZ::Assign ( struct IAgDirection * pDirection ) {
    HRESULT _hr = raw_Assign(pDirection);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionXYZ::AssignEuler ( const _variant_t & B, const _variant_t & C, enum AgEEulerDirectionSequence Sequence ) {
    HRESULT _hr = raw_AssignEuler(B, C, Sequence);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionXYZ::AssignPR ( const _variant_t & Pitch, const _variant_t & Roll ) {
    HRESULT _hr = raw_AssignPR(Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionXYZ::AssignRADec ( const _variant_t & RA, const _variant_t & Dec ) {
    HRESULT _hr = raw_AssignRADec(RA, Dec);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionXYZ::AssignXYZ ( double X, double Y, double Z ) {
    HRESULT _hr = raw_AssignXYZ(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionXYZ::QueryEuler ( enum AgEEulerDirectionSequence Sequence, VARIANT * B, VARIANT * C ) {
    HRESULT _hr = raw_QueryEuler(Sequence, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionXYZ::QueryPR ( enum AgEPRSequence Sequence, VARIANT * Pitch, VARIANT * Roll ) {
    HRESULT _hr = raw_QueryPR(Sequence, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionXYZ::QueryRADec ( VARIANT * RA, VARIANT * Dec ) {
    HRESULT _hr = raw_QueryRADec(RA, Dec);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgDirectionXYZ::QueryXYZ ( double * X, double * Y, double * Z ) {
    HRESULT _hr = raw_QueryXYZ(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgDirectionXYZ::QueryEulerArray ( enum AgEEulerDirectionSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryEulerArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgDirectionXYZ::QueryPRArray ( enum AgEPRSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryPRArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgDirectionXYZ::QueryRADecArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryRADecArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgDirectionXYZ::QueryXYZArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryXYZArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgDirectionXYZ wrapper method implementations
//

double IAgDirectionXYZ::GetX ( ) {
    double _result = 0;
    HRESULT _hr = get_X(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgDirectionXYZ::PutX ( double pVal ) {
    HRESULT _hr = put_X(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgDirectionXYZ::GetY ( ) {
    double _result = 0;
    HRESULT _hr = get_Y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgDirectionXYZ::PutY ( double pVal ) {
    HRESULT _hr = put_Y(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgDirectionXYZ::GetZ ( ) {
    double _result = 0;
    HRESULT _hr = get_Z(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgDirectionXYZ::PutZ ( double pVal ) {
    HRESULT _hr = put_Z(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgDirectionXYZ::SetValues ( double X, double Y, double Z ) {
    HRESULT _hr = raw_SetValues(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgOrientation wrapper method implementations
//

IAgOrientationPtr _IAgOrientation::ConvertTo ( enum AgEOrientationType Type ) {
    struct IAgOrientation * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrientationPtr(_result, false);
}

enum AgEOrientationType _IAgOrientation::GetOrientationType ( ) {
    enum AgEOrientationType _result;
    HRESULT _hr = get_OrientationType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgOrientation::Assign ( struct IAgOrientation * pOrientation ) {
    HRESULT _hr = raw_Assign(pOrientation);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientation::AssignAzEl ( const _variant_t & Azimuth, const _variant_t & Elevation, enum AgEAzElAboutBoresight AboutBoresight ) {
    HRESULT _hr = raw_AssignAzEl(Azimuth, Elevation, AboutBoresight);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientation::AssignEulerAngles ( enum AgEEulerOrientationSequence Sequence, const _variant_t & A, const _variant_t & B, const _variant_t & C ) {
    HRESULT _hr = raw_AssignEulerAngles(Sequence, A, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientation::AssignQuaternion ( double QX, double QY, double QZ, double QS ) {
    HRESULT _hr = raw_AssignQuaternion(QX, QY, QZ, QS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientation::AssignYPRAngles ( enum AgEYPRAnglesSequence Sequence, const _variant_t & Yaw, const _variant_t & Pitch, const _variant_t & Roll ) {
    HRESULT _hr = raw_AssignYPRAngles(Sequence, Yaw, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientation::QueryAzEl ( VARIANT * Azimuth, VARIANT * Elevation, enum AgEAzElAboutBoresight * AboutBoresight ) {
    HRESULT _hr = raw_QueryAzEl(Azimuth, Elevation, AboutBoresight);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientation::QueryEulerAngles ( enum AgEEulerOrientationSequence Sequence, VARIANT * A, VARIANT * B, VARIANT * C ) {
    HRESULT _hr = raw_QueryEulerAngles(Sequence, A, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientation::QueryQuaternion ( double * QX, double * QY, double * QZ, double * QS ) {
    HRESULT _hr = raw_QueryQuaternion(QX, QY, QZ, QS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientation::QueryYPRAngles ( enum AgEYPRAnglesSequence Sequence, VARIANT * Yaw, VARIANT * Pitch, VARIANT * Roll ) {
    HRESULT _hr = raw_QueryYPRAngles(Sequence, Yaw, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgOrientation::QueryAzElArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryAzElArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgOrientation::QueryEulerAnglesArray ( enum AgEEulerOrientationSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryEulerAnglesArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgOrientation::QueryQuaternionArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryQuaternionArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgOrientation::QueryYPRAnglesArray ( enum AgEYPRAnglesSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryYPRAnglesArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgOrientationAzEl wrapper method implementations
//

_variant_t _IAgOrientationAzEl::GetAzimuth ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Azimuth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgOrientationAzEl::PutAzimuth ( const _variant_t & pVal ) {
    HRESULT _hr = put_Azimuth(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgOrientationAzEl::GetElevation ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Elevation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgOrientationAzEl::PutElevation ( const _variant_t & pVal ) {
    HRESULT _hr = put_Elevation(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgEAzElAboutBoresight _IAgOrientationAzEl::GetAboutBoresight ( ) {
    enum AgEAzElAboutBoresight _result;
    HRESULT _hr = get_AboutBoresight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrientationAzEl::PutAboutBoresight ( enum AgEAzElAboutBoresight pVal ) {
    HRESULT _hr = put_AboutBoresight(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgOrientationAzEl::SetValues ( const _variant_t & Azimuth, const _variant_t & Elevation, enum AgEAzElAboutBoresight AboutBoresight ) {
    HRESULT _hr = raw_SetValues(Azimuth, Elevation, AboutBoresight);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgOrientationPtr _IAgOrientationAzEl::ConvertTo ( enum AgEOrientationType Type ) {
    struct IAgOrientation * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrientationPtr(_result, false);
}

enum AgEOrientationType _IAgOrientationAzEl::GetOrientationType ( ) {
    enum AgEOrientationType _result;
    HRESULT _hr = get_OrientationType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgOrientationAzEl::Assign ( struct IAgOrientation * pOrientation ) {
    HRESULT _hr = raw_Assign(pOrientation);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationAzEl::AssignAzEl ( const _variant_t & Azimuth, const _variant_t & Elevation, enum AgEAzElAboutBoresight AboutBoresight ) {
    HRESULT _hr = raw_AssignAzEl(Azimuth, Elevation, AboutBoresight);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationAzEl::AssignEulerAngles ( enum AgEEulerOrientationSequence Sequence, const _variant_t & A, const _variant_t & B, const _variant_t & C ) {
    HRESULT _hr = raw_AssignEulerAngles(Sequence, A, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationAzEl::AssignQuaternion ( double QX, double QY, double QZ, double QS ) {
    HRESULT _hr = raw_AssignQuaternion(QX, QY, QZ, QS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationAzEl::AssignYPRAngles ( enum AgEYPRAnglesSequence Sequence, const _variant_t & Yaw, const _variant_t & Pitch, const _variant_t & Roll ) {
    HRESULT _hr = raw_AssignYPRAngles(Sequence, Yaw, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationAzEl::QueryAzEl ( VARIANT * Azimuth, VARIANT * Elevation, enum AgEAzElAboutBoresight * AboutBoresight ) {
    HRESULT _hr = raw_QueryAzEl(Azimuth, Elevation, AboutBoresight);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationAzEl::QueryEulerAngles ( enum AgEEulerOrientationSequence Sequence, VARIANT * A, VARIANT * B, VARIANT * C ) {
    HRESULT _hr = raw_QueryEulerAngles(Sequence, A, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationAzEl::QueryQuaternion ( double * QX, double * QY, double * QZ, double * QS ) {
    HRESULT _hr = raw_QueryQuaternion(QX, QY, QZ, QS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationAzEl::QueryYPRAngles ( enum AgEYPRAnglesSequence Sequence, VARIANT * Yaw, VARIANT * Pitch, VARIANT * Roll ) {
    HRESULT _hr = raw_QueryYPRAngles(Sequence, Yaw, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgOrientationAzEl::QueryAzElArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryAzElArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgOrientationAzEl::QueryEulerAnglesArray ( enum AgEEulerOrientationSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryEulerAnglesArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgOrientationAzEl::QueryQuaternionArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryQuaternionArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgOrientationAzEl::QueryYPRAnglesArray ( enum AgEYPRAnglesSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryYPRAnglesArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgOrientationAzEl wrapper method implementations
//

_variant_t IAgOrientationAzEl::GetAzimuth ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Azimuth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgOrientationAzEl::PutAzimuth ( const _variant_t & pVal ) {
    HRESULT _hr = put_Azimuth(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t IAgOrientationAzEl::GetElevation ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Elevation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgOrientationAzEl::PutElevation ( const _variant_t & pVal ) {
    HRESULT _hr = put_Elevation(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgEAzElAboutBoresight IAgOrientationAzEl::GetAboutBoresight ( ) {
    enum AgEAzElAboutBoresight _result;
    HRESULT _hr = get_AboutBoresight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrientationAzEl::PutAboutBoresight ( enum AgEAzElAboutBoresight pVal ) {
    HRESULT _hr = put_AboutBoresight(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgOrientationAzEl::SetValues ( const _variant_t & Azimuth, const _variant_t & Elevation, enum AgEAzElAboutBoresight AboutBoresight ) {
    HRESULT _hr = raw_SetValues(Azimuth, Elevation, AboutBoresight);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgOrientationEulerAngles wrapper method implementations
//

enum AgEEulerOrientationSequence _IAgOrientationEulerAngles::GetSequence ( ) {
    enum AgEEulerOrientationSequence _result;
    HRESULT _hr = get_Sequence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrientationEulerAngles::PutSequence ( enum AgEEulerOrientationSequence pVal ) {
    HRESULT _hr = put_Sequence(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgOrientationEulerAngles::GetA ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_A(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgOrientationEulerAngles::PutA ( const _variant_t & pVal ) {
    HRESULT _hr = put_A(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgOrientationEulerAngles::GetB ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_B(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgOrientationEulerAngles::PutB ( const _variant_t & pVal ) {
    HRESULT _hr = put_B(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgOrientationEulerAngles::GetC ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_C(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgOrientationEulerAngles::PutC ( const _variant_t & pVal ) {
    HRESULT _hr = put_C(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgOrientationEulerAngles::SetValues ( enum AgEEulerOrientationSequence Sequence, const _variant_t & A, const _variant_t & B, const _variant_t & C ) {
    HRESULT _hr = raw_SetValues(Sequence, A, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgOrientationPtr _IAgOrientationEulerAngles::ConvertTo ( enum AgEOrientationType Type ) {
    struct IAgOrientation * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrientationPtr(_result, false);
}

enum AgEOrientationType _IAgOrientationEulerAngles::GetOrientationType ( ) {
    enum AgEOrientationType _result;
    HRESULT _hr = get_OrientationType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgOrientationEulerAngles::Assign ( struct IAgOrientation * pOrientation ) {
    HRESULT _hr = raw_Assign(pOrientation);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationEulerAngles::AssignAzEl ( const _variant_t & Azimuth, const _variant_t & Elevation, enum AgEAzElAboutBoresight AboutBoresight ) {
    HRESULT _hr = raw_AssignAzEl(Azimuth, Elevation, AboutBoresight);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationEulerAngles::AssignEulerAngles ( enum AgEEulerOrientationSequence Sequence, const _variant_t & A, const _variant_t & B, const _variant_t & C ) {
    HRESULT _hr = raw_AssignEulerAngles(Sequence, A, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationEulerAngles::AssignQuaternion ( double QX, double QY, double QZ, double QS ) {
    HRESULT _hr = raw_AssignQuaternion(QX, QY, QZ, QS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationEulerAngles::AssignYPRAngles ( enum AgEYPRAnglesSequence Sequence, const _variant_t & Yaw, const _variant_t & Pitch, const _variant_t & Roll ) {
    HRESULT _hr = raw_AssignYPRAngles(Sequence, Yaw, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationEulerAngles::QueryAzEl ( VARIANT * Azimuth, VARIANT * Elevation, enum AgEAzElAboutBoresight * AboutBoresight ) {
    HRESULT _hr = raw_QueryAzEl(Azimuth, Elevation, AboutBoresight);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationEulerAngles::QueryEulerAngles ( enum AgEEulerOrientationSequence Sequence, VARIANT * A, VARIANT * B, VARIANT * C ) {
    HRESULT _hr = raw_QueryEulerAngles(Sequence, A, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationEulerAngles::QueryQuaternion ( double * QX, double * QY, double * QZ, double * QS ) {
    HRESULT _hr = raw_QueryQuaternion(QX, QY, QZ, QS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationEulerAngles::QueryYPRAngles ( enum AgEYPRAnglesSequence Sequence, VARIANT * Yaw, VARIANT * Pitch, VARIANT * Roll ) {
    HRESULT _hr = raw_QueryYPRAngles(Sequence, Yaw, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgOrientationEulerAngles::QueryAzElArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryAzElArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgOrientationEulerAngles::QueryEulerAnglesArray ( enum AgEEulerOrientationSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryEulerAnglesArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgOrientationEulerAngles::QueryQuaternionArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryQuaternionArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgOrientationEulerAngles::QueryYPRAnglesArray ( enum AgEYPRAnglesSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryYPRAnglesArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgOrientationEulerAngles wrapper method implementations
//

enum AgEEulerOrientationSequence IAgOrientationEulerAngles::GetSequence ( ) {
    enum AgEEulerOrientationSequence _result;
    HRESULT _hr = get_Sequence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrientationEulerAngles::PutSequence ( enum AgEEulerOrientationSequence pVal ) {
    HRESULT _hr = put_Sequence(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t IAgOrientationEulerAngles::GetA ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_A(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgOrientationEulerAngles::PutA ( const _variant_t & pVal ) {
    HRESULT _hr = put_A(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t IAgOrientationEulerAngles::GetB ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_B(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgOrientationEulerAngles::PutB ( const _variant_t & pVal ) {
    HRESULT _hr = put_B(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t IAgOrientationEulerAngles::GetC ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_C(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgOrientationEulerAngles::PutC ( const _variant_t & pVal ) {
    HRESULT _hr = put_C(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgOrientationEulerAngles::SetValues ( enum AgEEulerOrientationSequence Sequence, const _variant_t & A, const _variant_t & B, const _variant_t & C ) {
    HRESULT _hr = raw_SetValues(Sequence, A, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgOrientationQuaternion wrapper method implementations
//

double _IAgOrientationQuaternion::GetQX ( ) {
    double _result = 0;
    HRESULT _hr = get_QX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrientationQuaternion::PutQX ( double pVal ) {
    HRESULT _hr = put_QX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgOrientationQuaternion::GetQY ( ) {
    double _result = 0;
    HRESULT _hr = get_QY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrientationQuaternion::PutQY ( double pVal ) {
    HRESULT _hr = put_QY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgOrientationQuaternion::GetQZ ( ) {
    double _result = 0;
    HRESULT _hr = get_QZ(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrientationQuaternion::PutQZ ( double pVal ) {
    HRESULT _hr = put_QZ(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgOrientationQuaternion::GetQS ( ) {
    double _result = 0;
    HRESULT _hr = get_QS(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrientationQuaternion::PutQS ( double pVal ) {
    HRESULT _hr = put_QS(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgOrientationQuaternion::SetValues ( double QX, double QY, double QZ, double QS ) {
    HRESULT _hr = raw_SetValues(QX, QY, QZ, QS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgOrientationPtr _IAgOrientationQuaternion::ConvertTo ( enum AgEOrientationType Type ) {
    struct IAgOrientation * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrientationPtr(_result, false);
}

enum AgEOrientationType _IAgOrientationQuaternion::GetOrientationType ( ) {
    enum AgEOrientationType _result;
    HRESULT _hr = get_OrientationType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgOrientationQuaternion::Assign ( struct IAgOrientation * pOrientation ) {
    HRESULT _hr = raw_Assign(pOrientation);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationQuaternion::AssignAzEl ( const _variant_t & Azimuth, const _variant_t & Elevation, enum AgEAzElAboutBoresight AboutBoresight ) {
    HRESULT _hr = raw_AssignAzEl(Azimuth, Elevation, AboutBoresight);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationQuaternion::AssignEulerAngles ( enum AgEEulerOrientationSequence Sequence, const _variant_t & A, const _variant_t & B, const _variant_t & C ) {
    HRESULT _hr = raw_AssignEulerAngles(Sequence, A, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationQuaternion::AssignQuaternion ( double QX, double QY, double QZ, double QS ) {
    HRESULT _hr = raw_AssignQuaternion(QX, QY, QZ, QS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationQuaternion::AssignYPRAngles ( enum AgEYPRAnglesSequence Sequence, const _variant_t & Yaw, const _variant_t & Pitch, const _variant_t & Roll ) {
    HRESULT _hr = raw_AssignYPRAngles(Sequence, Yaw, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationQuaternion::QueryAzEl ( VARIANT * Azimuth, VARIANT * Elevation, enum AgEAzElAboutBoresight * AboutBoresight ) {
    HRESULT _hr = raw_QueryAzEl(Azimuth, Elevation, AboutBoresight);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationQuaternion::QueryEulerAngles ( enum AgEEulerOrientationSequence Sequence, VARIANT * A, VARIANT * B, VARIANT * C ) {
    HRESULT _hr = raw_QueryEulerAngles(Sequence, A, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationQuaternion::QueryQuaternion ( double * QX, double * QY, double * QZ, double * QS ) {
    HRESULT _hr = raw_QueryQuaternion(QX, QY, QZ, QS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationQuaternion::QueryYPRAngles ( enum AgEYPRAnglesSequence Sequence, VARIANT * Yaw, VARIANT * Pitch, VARIANT * Roll ) {
    HRESULT _hr = raw_QueryYPRAngles(Sequence, Yaw, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgOrientationQuaternion::QueryAzElArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryAzElArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgOrientationQuaternion::QueryEulerAnglesArray ( enum AgEEulerOrientationSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryEulerAnglesArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgOrientationQuaternion::QueryQuaternionArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryQuaternionArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgOrientationQuaternion::QueryYPRAnglesArray ( enum AgEYPRAnglesSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryYPRAnglesArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgOrientationQuaternion wrapper method implementations
//

double IAgOrientationQuaternion::GetQX ( ) {
    double _result = 0;
    HRESULT _hr = get_QX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrientationQuaternion::PutQX ( double pVal ) {
    HRESULT _hr = put_QX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgOrientationQuaternion::GetQY ( ) {
    double _result = 0;
    HRESULT _hr = get_QY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrientationQuaternion::PutQY ( double pVal ) {
    HRESULT _hr = put_QY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgOrientationQuaternion::GetQZ ( ) {
    double _result = 0;
    HRESULT _hr = get_QZ(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrientationQuaternion::PutQZ ( double pVal ) {
    HRESULT _hr = put_QZ(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgOrientationQuaternion::GetQS ( ) {
    double _result = 0;
    HRESULT _hr = get_QS(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrientationQuaternion::PutQS ( double pVal ) {
    HRESULT _hr = put_QS(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgOrientationQuaternion::SetValues ( double QX, double QY, double QZ, double QS ) {
    HRESULT _hr = raw_SetValues(QX, QY, QZ, QS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgOrientationYPRAngles wrapper method implementations
//

enum AgEYPRAnglesSequence _IAgOrientationYPRAngles::GetSequence ( ) {
    enum AgEYPRAnglesSequence _result;
    HRESULT _hr = get_Sequence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgOrientationYPRAngles::PutSequence ( enum AgEYPRAnglesSequence pVal ) {
    HRESULT _hr = put_Sequence(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgOrientationYPRAngles::GetYaw ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Yaw(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgOrientationYPRAngles::PutYaw ( const _variant_t & pVal ) {
    HRESULT _hr = put_Yaw(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgOrientationYPRAngles::GetPitch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Pitch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgOrientationYPRAngles::PutPitch ( const _variant_t & pVal ) {
    HRESULT _hr = put_Pitch(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgOrientationYPRAngles::GetRoll ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Roll(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgOrientationYPRAngles::PutRoll ( const _variant_t & pVal ) {
    HRESULT _hr = put_Roll(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgOrientationYPRAngles::SetValues ( enum AgEYPRAnglesSequence Sequence, const _variant_t & Yaw, const _variant_t & Pitch, const _variant_t & Roll ) {
    HRESULT _hr = raw_SetValues(Sequence, Yaw, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgOrientationPtr _IAgOrientationYPRAngles::ConvertTo ( enum AgEOrientationType Type ) {
    struct IAgOrientation * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrientationPtr(_result, false);
}

enum AgEOrientationType _IAgOrientationYPRAngles::GetOrientationType ( ) {
    enum AgEOrientationType _result;
    HRESULT _hr = get_OrientationType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgOrientationYPRAngles::Assign ( struct IAgOrientation * pOrientation ) {
    HRESULT _hr = raw_Assign(pOrientation);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationYPRAngles::AssignAzEl ( const _variant_t & Azimuth, const _variant_t & Elevation, enum AgEAzElAboutBoresight AboutBoresight ) {
    HRESULT _hr = raw_AssignAzEl(Azimuth, Elevation, AboutBoresight);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationYPRAngles::AssignEulerAngles ( enum AgEEulerOrientationSequence Sequence, const _variant_t & A, const _variant_t & B, const _variant_t & C ) {
    HRESULT _hr = raw_AssignEulerAngles(Sequence, A, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationYPRAngles::AssignQuaternion ( double QX, double QY, double QZ, double QS ) {
    HRESULT _hr = raw_AssignQuaternion(QX, QY, QZ, QS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationYPRAngles::AssignYPRAngles ( enum AgEYPRAnglesSequence Sequence, const _variant_t & Yaw, const _variant_t & Pitch, const _variant_t & Roll ) {
    HRESULT _hr = raw_AssignYPRAngles(Sequence, Yaw, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationYPRAngles::QueryAzEl ( VARIANT * Azimuth, VARIANT * Elevation, enum AgEAzElAboutBoresight * AboutBoresight ) {
    HRESULT _hr = raw_QueryAzEl(Azimuth, Elevation, AboutBoresight);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationYPRAngles::QueryEulerAngles ( enum AgEEulerOrientationSequence Sequence, VARIANT * A, VARIANT * B, VARIANT * C ) {
    HRESULT _hr = raw_QueryEulerAngles(Sequence, A, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationYPRAngles::QueryQuaternion ( double * QX, double * QY, double * QZ, double * QS ) {
    HRESULT _hr = raw_QueryQuaternion(QX, QY, QZ, QS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgOrientationYPRAngles::QueryYPRAngles ( enum AgEYPRAnglesSequence Sequence, VARIANT * Yaw, VARIANT * Pitch, VARIANT * Roll ) {
    HRESULT _hr = raw_QueryYPRAngles(Sequence, Yaw, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgOrientationYPRAngles::QueryAzElArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryAzElArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgOrientationYPRAngles::QueryEulerAnglesArray ( enum AgEEulerOrientationSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryEulerAnglesArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgOrientationYPRAngles::QueryQuaternionArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryQuaternionArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgOrientationYPRAngles::QueryYPRAnglesArray ( enum AgEYPRAnglesSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryYPRAnglesArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgOrientationYPRAngles wrapper method implementations
//

enum AgEYPRAnglesSequence IAgOrientationYPRAngles::GetSequence ( ) {
    enum AgEYPRAnglesSequence _result;
    HRESULT _hr = get_Sequence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgOrientationYPRAngles::PutSequence ( enum AgEYPRAnglesSequence pVal ) {
    HRESULT _hr = put_Sequence(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t IAgOrientationYPRAngles::GetYaw ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Yaw(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgOrientationYPRAngles::PutYaw ( const _variant_t & pVal ) {
    HRESULT _hr = put_Yaw(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t IAgOrientationYPRAngles::GetPitch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Pitch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgOrientationYPRAngles::PutPitch ( const _variant_t & pVal ) {
    HRESULT _hr = put_Pitch(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t IAgOrientationYPRAngles::GetRoll ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Roll(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgOrientationYPRAngles::PutRoll ( const _variant_t & pVal ) {
    HRESULT _hr = put_Roll(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgOrientationYPRAngles::SetValues ( enum AgEYPRAnglesSequence Sequence, const _variant_t & Yaw, const _variant_t & Pitch, const _variant_t & Roll ) {
    HRESULT _hr = raw_SetValues(Sequence, Yaw, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IAgDoublesCollection wrapper method implementations
//

double IAgDoublesCollection::GetItem ( long Index ) {
    double _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IAgDoublesCollection::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IUnknownPtr IAgDoublesCollection::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

HRESULT IAgDoublesCollection::Add ( double Value ) {
    HRESULT _hr = raw_Add(Value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgDoublesCollection::RemoveAt ( long Index ) {
    HRESULT _hr = raw_RemoveAt(Index);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgDoublesCollection::RemoveAll ( ) {
    HRESULT _hr = raw_RemoveAll();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * IAgDoublesCollection::ToArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_ToArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IAgDoublesCollection::SetAt ( long Index, double Value ) {
    HRESULT _hr = raw_SetAt(Index, Value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCartesian3Vector wrapper method implementations
//

double _IAgCartesian3Vector::GetX ( ) {
    double _result = 0;
    HRESULT _hr = get_X(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCartesian3Vector::PutX ( double pRetVal ) {
    HRESULT _hr = put_X(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCartesian3Vector::GetY ( ) {
    double _result = 0;
    HRESULT _hr = get_Y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCartesian3Vector::PutY ( double pRetVal ) {
    HRESULT _hr = put_Y(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCartesian3Vector::GetZ ( ) {
    double _result = 0;
    HRESULT _hr = get_Z(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCartesian3Vector::PutZ ( double pRetVal ) {
    HRESULT _hr = put_Z(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgCartesian3Vector::Get ( double * X, double * Y, double * Z ) {
    HRESULT _hr = raw_Get(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCartesian3Vector::Set ( double X, double Y, double Z ) {
    HRESULT _hr = raw_Set(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgCartesian3Vector::ToArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_ToArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCartesian2Vector wrapper method implementations
//

double _IAgCartesian2Vector::GetX ( ) {
    double _result = 0;
    HRESULT _hr = get_X(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCartesian2Vector::PutX ( double pRetVal ) {
    HRESULT _hr = put_X(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCartesian2Vector::GetY ( ) {
    double _result = 0;
    HRESULT _hr = get_Y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCartesian2Vector::PutY ( double pRetVal ) {
    HRESULT _hr = put_Y(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgCartesian2Vector::Get ( double * X, double * Y ) {
    HRESULT _hr = raw_Get(X, Y);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCartesian2Vector::Set ( double X, double Y ) {
    HRESULT _hr = raw_Set(X, Y);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgCartesian2Vector::ToArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_ToArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCartesian2Vector wrapper method implementations
//

double IAgCartesian2Vector::GetX ( ) {
    double _result = 0;
    HRESULT _hr = get_X(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCartesian2Vector::PutX ( double pRetVal ) {
    HRESULT _hr = put_X(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCartesian2Vector::GetY ( ) {
    double _result = 0;
    HRESULT _hr = get_Y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCartesian2Vector::PutY ( double pRetVal ) {
    HRESULT _hr = put_Y(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgCartesian2Vector::Get ( double * X, double * Y ) {
    HRESULT _hr = raw_Get(X, Y);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgCartesian2Vector::Set ( double X, double Y ) {
    HRESULT _hr = raw_Set(X, Y);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * IAgCartesian2Vector::ToArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_ToArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgPropertyInfo wrapper method implementations
//

_bstr_t IAgPropertyInfo::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

enum AgEPropertyInfoValueType IAgPropertyInfo::GetPropertyType ( ) {
    enum AgEPropertyInfoValueType _result;
    HRESULT _hr = get_PropertyType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_variant_t IAgPropertyInfo::GetValue ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_GetValue(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

HRESULT IAgPropertyInfo::SetValue ( const _variant_t & PropertyInfo ) {
    HRESULT _hr = raw_SetValue(PropertyInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL IAgPropertyInfo::GetHasMin ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_HasMin(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IAgPropertyInfo::GetHasMax ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_HasMax(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_variant_t IAgPropertyInfo::GetMin ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Min(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

_variant_t IAgPropertyInfo::GetMax ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Max(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface _IAgPropertyInfo wrapper method implementations
//

_bstr_t _IAgPropertyInfo::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

enum AgEPropertyInfoValueType _IAgPropertyInfo::GetPropertyType ( ) {
    enum AgEPropertyInfoValueType _result;
    HRESULT _hr = get_PropertyType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_variant_t _IAgPropertyInfo::GetValue ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_GetValue(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

HRESULT _IAgPropertyInfo::SetValue ( const _variant_t & PropertyInfo ) {
    HRESULT _hr = raw_SetValue(PropertyInfo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL _IAgPropertyInfo::GetHasMin ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_HasMin(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgPropertyInfo::GetHasMax ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_HasMax(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_variant_t _IAgPropertyInfo::GetMin ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Min(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

_variant_t _IAgPropertyInfo::GetMax ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Max(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface IAgPropertyInfoCollection wrapper method implementations
//

IAgPropertyInfoPtr IAgPropertyInfoCollection::GetItem ( const _variant_t & IndexOrName ) {
    struct IAgPropertyInfo * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgPropertyInfoPtr(_result, false);
}

IUnknownPtr IAgPropertyInfoCollection::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

long IAgPropertyInfoCollection::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgRuntimeTypeInfo wrapper method implementations
//

IAgPropertyInfoCollectionPtr _IAgRuntimeTypeInfo::GetProperties ( ) {
    struct IAgPropertyInfoCollection * _result = 0;
    HRESULT _hr = get_Properties(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgPropertyInfoCollectionPtr(_result, false);
}

VARIANT_BOOL _IAgRuntimeTypeInfo::GetIsCollection ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsCollection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long _IAgRuntimeTypeInfo::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgPropertyInfoPtr _IAgRuntimeTypeInfo::GetItem ( long Index ) {
    struct IAgPropertyInfo * _result = 0;
    HRESULT _hr = raw_GetItem(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgPropertyInfoPtr(_result, false);
}

//
// interface IAgRuntimeTypeInfo wrapper method implementations
//

IAgPropertyInfoCollectionPtr IAgRuntimeTypeInfo::GetProperties ( ) {
    struct IAgPropertyInfoCollection * _result = 0;
    HRESULT _hr = get_Properties(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgPropertyInfoCollectionPtr(_result, false);
}

VARIANT_BOOL IAgRuntimeTypeInfo::GetIsCollection ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsCollection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IAgRuntimeTypeInfo::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgPropertyInfoPtr IAgRuntimeTypeInfo::GetItem ( long Index ) {
    struct IAgPropertyInfo * _result = 0;
    HRESULT _hr = raw_GetItem(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgPropertyInfoPtr(_result, false);
}

//
// interface _IAgCROrientationAzEl wrapper method implementations
//

_variant_t _IAgCROrientationAzEl::GetAzimuth ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Azimuth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgCROrientationAzEl::PutAzimuth ( const _variant_t & pVal ) {
    HRESULT _hr = put_Azimuth(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgCROrientationAzEl::GetElevation ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Elevation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgCROrientationAzEl::PutElevation ( const _variant_t & pVal ) {
    HRESULT _hr = put_Elevation(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgEAzElAboutBoresight _IAgCROrientationAzEl::GetAboutBoresight ( ) {
    enum AgEAzElAboutBoresight _result;
    HRESULT _hr = get_AboutBoresight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCROrientationAzEl::PutAboutBoresight ( enum AgEAzElAboutBoresight pVal ) {
    HRESULT _hr = put_AboutBoresight(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgCROrientationAzEl::SetValues ( const _variant_t & Azimuth, const _variant_t & Elevation, enum AgEAzElAboutBoresight AboutBoresight ) {
    HRESULT _hr = raw_SetValues(Azimuth, Elevation, AboutBoresight);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgOrientationPtr _IAgCROrientationAzEl::ConvertTo ( enum AgEOrientationType Type ) {
    struct IAgOrientation * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrientationPtr(_result, false);
}

enum AgEOrientationType _IAgCROrientationAzEl::GetOrientationType ( ) {
    enum AgEOrientationType _result;
    HRESULT _hr = get_OrientationType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgCROrientationAzEl::Assign ( struct IAgOrientation * pOrientation ) {
    HRESULT _hr = raw_Assign(pOrientation);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCROrientationAzEl::AssignAzEl ( const _variant_t & Azimuth, const _variant_t & Elevation, enum AgEAzElAboutBoresight AboutBoresight ) {
    HRESULT _hr = raw_AssignAzEl(Azimuth, Elevation, AboutBoresight);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCROrientationAzEl::AssignEulerAngles ( enum AgEEulerOrientationSequence Sequence, const _variant_t & A, const _variant_t & B, const _variant_t & C ) {
    HRESULT _hr = raw_AssignEulerAngles(Sequence, A, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCROrientationAzEl::AssignQuaternion ( double QX, double QY, double QZ, double QS ) {
    HRESULT _hr = raw_AssignQuaternion(QX, QY, QZ, QS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCROrientationAzEl::AssignYPRAngles ( enum AgEYPRAnglesSequence Sequence, const _variant_t & Yaw, const _variant_t & Pitch, const _variant_t & Roll ) {
    HRESULT _hr = raw_AssignYPRAngles(Sequence, Yaw, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCROrientationAzEl::QueryAzEl ( VARIANT * Azimuth, VARIANT * Elevation, enum AgEAzElAboutBoresight * AboutBoresight ) {
    HRESULT _hr = raw_QueryAzEl(Azimuth, Elevation, AboutBoresight);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCROrientationAzEl::QueryEulerAngles ( enum AgEEulerOrientationSequence Sequence, VARIANT * A, VARIANT * B, VARIANT * C ) {
    HRESULT _hr = raw_QueryEulerAngles(Sequence, A, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCROrientationAzEl::QueryQuaternion ( double * QX, double * QY, double * QZ, double * QS ) {
    HRESULT _hr = raw_QueryQuaternion(QX, QY, QZ, QS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCROrientationAzEl::QueryYPRAngles ( enum AgEYPRAnglesSequence Sequence, VARIANT * Yaw, VARIANT * Pitch, VARIANT * Roll ) {
    HRESULT _hr = raw_QueryYPRAngles(Sequence, Yaw, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgCROrientationAzEl::QueryAzElArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryAzElArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCROrientationAzEl::QueryEulerAnglesArray ( enum AgEEulerOrientationSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryEulerAnglesArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCROrientationAzEl::QueryQuaternionArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryQuaternionArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCROrientationAzEl::QueryYPRAnglesArray ( enum AgEYPRAnglesSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryYPRAnglesArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCartesian3VectorPtr _IAgCROrientationAzEl::GetPositionOffset ( ) {
    struct IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_PositionOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCartesian3VectorPtr(_result, false);
}

//
// interface IAgOrientationPositionOffset wrapper method implementations
//

IAgCartesian3VectorPtr IAgOrientationPositionOffset::GetPositionOffset ( ) {
    struct IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_PositionOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCartesian3VectorPtr(_result, false);
}

//
// interface _IAgCROrientationEulerAngles wrapper method implementations
//

enum AgEEulerOrientationSequence _IAgCROrientationEulerAngles::GetSequence ( ) {
    enum AgEEulerOrientationSequence _result;
    HRESULT _hr = get_Sequence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCROrientationEulerAngles::PutSequence ( enum AgEEulerOrientationSequence pVal ) {
    HRESULT _hr = put_Sequence(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgCROrientationEulerAngles::GetA ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_A(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgCROrientationEulerAngles::PutA ( const _variant_t & pVal ) {
    HRESULT _hr = put_A(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgCROrientationEulerAngles::GetB ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_B(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgCROrientationEulerAngles::PutB ( const _variant_t & pVal ) {
    HRESULT _hr = put_B(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgCROrientationEulerAngles::GetC ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_C(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgCROrientationEulerAngles::PutC ( const _variant_t & pVal ) {
    HRESULT _hr = put_C(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgCROrientationEulerAngles::SetValues ( enum AgEEulerOrientationSequence Sequence, const _variant_t & A, const _variant_t & B, const _variant_t & C ) {
    HRESULT _hr = raw_SetValues(Sequence, A, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgOrientationPtr _IAgCROrientationEulerAngles::ConvertTo ( enum AgEOrientationType Type ) {
    struct IAgOrientation * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrientationPtr(_result, false);
}

enum AgEOrientationType _IAgCROrientationEulerAngles::GetOrientationType ( ) {
    enum AgEOrientationType _result;
    HRESULT _hr = get_OrientationType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgCROrientationEulerAngles::Assign ( struct IAgOrientation * pOrientation ) {
    HRESULT _hr = raw_Assign(pOrientation);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCROrientationEulerAngles::AssignAzEl ( const _variant_t & Azimuth, const _variant_t & Elevation, enum AgEAzElAboutBoresight AboutBoresight ) {
    HRESULT _hr = raw_AssignAzEl(Azimuth, Elevation, AboutBoresight);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCROrientationEulerAngles::AssignEulerAngles ( enum AgEEulerOrientationSequence Sequence, const _variant_t & A, const _variant_t & B, const _variant_t & C ) {
    HRESULT _hr = raw_AssignEulerAngles(Sequence, A, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCROrientationEulerAngles::AssignQuaternion ( double QX, double QY, double QZ, double QS ) {
    HRESULT _hr = raw_AssignQuaternion(QX, QY, QZ, QS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCROrientationEulerAngles::AssignYPRAngles ( enum AgEYPRAnglesSequence Sequence, const _variant_t & Yaw, const _variant_t & Pitch, const _variant_t & Roll ) {
    HRESULT _hr = raw_AssignYPRAngles(Sequence, Yaw, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCROrientationEulerAngles::QueryAzEl ( VARIANT * Azimuth, VARIANT * Elevation, enum AgEAzElAboutBoresight * AboutBoresight ) {
    HRESULT _hr = raw_QueryAzEl(Azimuth, Elevation, AboutBoresight);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCROrientationEulerAngles::QueryEulerAngles ( enum AgEEulerOrientationSequence Sequence, VARIANT * A, VARIANT * B, VARIANT * C ) {
    HRESULT _hr = raw_QueryEulerAngles(Sequence, A, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCROrientationEulerAngles::QueryQuaternion ( double * QX, double * QY, double * QZ, double * QS ) {
    HRESULT _hr = raw_QueryQuaternion(QX, QY, QZ, QS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCROrientationEulerAngles::QueryYPRAngles ( enum AgEYPRAnglesSequence Sequence, VARIANT * Yaw, VARIANT * Pitch, VARIANT * Roll ) {
    HRESULT _hr = raw_QueryYPRAngles(Sequence, Yaw, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgCROrientationEulerAngles::QueryAzElArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryAzElArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCROrientationEulerAngles::QueryEulerAnglesArray ( enum AgEEulerOrientationSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryEulerAnglesArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCROrientationEulerAngles::QueryQuaternionArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryQuaternionArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCROrientationEulerAngles::QueryYPRAnglesArray ( enum AgEYPRAnglesSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryYPRAnglesArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCartesian3VectorPtr _IAgCROrientationEulerAngles::GetPositionOffset ( ) {
    struct IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_PositionOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCartesian3VectorPtr(_result, false);
}

//
// interface _IAgCROrientationQuaternion wrapper method implementations
//

double _IAgCROrientationQuaternion::GetQX ( ) {
    double _result = 0;
    HRESULT _hr = get_QX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCROrientationQuaternion::PutQX ( double pVal ) {
    HRESULT _hr = put_QX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCROrientationQuaternion::GetQY ( ) {
    double _result = 0;
    HRESULT _hr = get_QY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCROrientationQuaternion::PutQY ( double pVal ) {
    HRESULT _hr = put_QY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCROrientationQuaternion::GetQZ ( ) {
    double _result = 0;
    HRESULT _hr = get_QZ(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCROrientationQuaternion::PutQZ ( double pVal ) {
    HRESULT _hr = put_QZ(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCROrientationQuaternion::GetQS ( ) {
    double _result = 0;
    HRESULT _hr = get_QS(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCROrientationQuaternion::PutQS ( double pVal ) {
    HRESULT _hr = put_QS(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgCROrientationQuaternion::SetValues ( double QX, double QY, double QZ, double QS ) {
    HRESULT _hr = raw_SetValues(QX, QY, QZ, QS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgOrientationPtr _IAgCROrientationQuaternion::ConvertTo ( enum AgEOrientationType Type ) {
    struct IAgOrientation * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrientationPtr(_result, false);
}

enum AgEOrientationType _IAgCROrientationQuaternion::GetOrientationType ( ) {
    enum AgEOrientationType _result;
    HRESULT _hr = get_OrientationType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgCROrientationQuaternion::Assign ( struct IAgOrientation * pOrientation ) {
    HRESULT _hr = raw_Assign(pOrientation);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCROrientationQuaternion::AssignAzEl ( const _variant_t & Azimuth, const _variant_t & Elevation, enum AgEAzElAboutBoresight AboutBoresight ) {
    HRESULT _hr = raw_AssignAzEl(Azimuth, Elevation, AboutBoresight);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCROrientationQuaternion::AssignEulerAngles ( enum AgEEulerOrientationSequence Sequence, const _variant_t & A, const _variant_t & B, const _variant_t & C ) {
    HRESULT _hr = raw_AssignEulerAngles(Sequence, A, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCROrientationQuaternion::AssignQuaternion ( double QX, double QY, double QZ, double QS ) {
    HRESULT _hr = raw_AssignQuaternion(QX, QY, QZ, QS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCROrientationQuaternion::AssignYPRAngles ( enum AgEYPRAnglesSequence Sequence, const _variant_t & Yaw, const _variant_t & Pitch, const _variant_t & Roll ) {
    HRESULT _hr = raw_AssignYPRAngles(Sequence, Yaw, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCROrientationQuaternion::QueryAzEl ( VARIANT * Azimuth, VARIANT * Elevation, enum AgEAzElAboutBoresight * AboutBoresight ) {
    HRESULT _hr = raw_QueryAzEl(Azimuth, Elevation, AboutBoresight);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCROrientationQuaternion::QueryEulerAngles ( enum AgEEulerOrientationSequence Sequence, VARIANT * A, VARIANT * B, VARIANT * C ) {
    HRESULT _hr = raw_QueryEulerAngles(Sequence, A, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCROrientationQuaternion::QueryQuaternion ( double * QX, double * QY, double * QZ, double * QS ) {
    HRESULT _hr = raw_QueryQuaternion(QX, QY, QZ, QS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCROrientationQuaternion::QueryYPRAngles ( enum AgEYPRAnglesSequence Sequence, VARIANT * Yaw, VARIANT * Pitch, VARIANT * Roll ) {
    HRESULT _hr = raw_QueryYPRAngles(Sequence, Yaw, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgCROrientationQuaternion::QueryAzElArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryAzElArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCROrientationQuaternion::QueryEulerAnglesArray ( enum AgEEulerOrientationSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryEulerAnglesArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCROrientationQuaternion::QueryQuaternionArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryQuaternionArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCROrientationQuaternion::QueryYPRAnglesArray ( enum AgEYPRAnglesSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryYPRAnglesArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCartesian3VectorPtr _IAgCROrientationQuaternion::GetPositionOffset ( ) {
    struct IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_PositionOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCartesian3VectorPtr(_result, false);
}

//
// interface _IAgCROrientationYPRAngles wrapper method implementations
//

enum AgEYPRAnglesSequence _IAgCROrientationYPRAngles::GetSequence ( ) {
    enum AgEYPRAnglesSequence _result;
    HRESULT _hr = get_Sequence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCROrientationYPRAngles::PutSequence ( enum AgEYPRAnglesSequence pVal ) {
    HRESULT _hr = put_Sequence(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgCROrientationYPRAngles::GetYaw ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Yaw(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgCROrientationYPRAngles::PutYaw ( const _variant_t & pVal ) {
    HRESULT _hr = put_Yaw(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgCROrientationYPRAngles::GetPitch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Pitch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgCROrientationYPRAngles::PutPitch ( const _variant_t & pVal ) {
    HRESULT _hr = put_Pitch(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgCROrientationYPRAngles::GetRoll ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Roll(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgCROrientationYPRAngles::PutRoll ( const _variant_t & pVal ) {
    HRESULT _hr = put_Roll(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgCROrientationYPRAngles::SetValues ( enum AgEYPRAnglesSequence Sequence, const _variant_t & Yaw, const _variant_t & Pitch, const _variant_t & Roll ) {
    HRESULT _hr = raw_SetValues(Sequence, Yaw, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgOrientationPtr _IAgCROrientationYPRAngles::ConvertTo ( enum AgEOrientationType Type ) {
    struct IAgOrientation * _result = 0;
    HRESULT _hr = raw_ConvertTo(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgOrientationPtr(_result, false);
}

enum AgEOrientationType _IAgCROrientationYPRAngles::GetOrientationType ( ) {
    enum AgEOrientationType _result;
    HRESULT _hr = get_OrientationType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgCROrientationYPRAngles::Assign ( struct IAgOrientation * pOrientation ) {
    HRESULT _hr = raw_Assign(pOrientation);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCROrientationYPRAngles::AssignAzEl ( const _variant_t & Azimuth, const _variant_t & Elevation, enum AgEAzElAboutBoresight AboutBoresight ) {
    HRESULT _hr = raw_AssignAzEl(Azimuth, Elevation, AboutBoresight);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCROrientationYPRAngles::AssignEulerAngles ( enum AgEEulerOrientationSequence Sequence, const _variant_t & A, const _variant_t & B, const _variant_t & C ) {
    HRESULT _hr = raw_AssignEulerAngles(Sequence, A, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCROrientationYPRAngles::AssignQuaternion ( double QX, double QY, double QZ, double QS ) {
    HRESULT _hr = raw_AssignQuaternion(QX, QY, QZ, QS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCROrientationYPRAngles::AssignYPRAngles ( enum AgEYPRAnglesSequence Sequence, const _variant_t & Yaw, const _variant_t & Pitch, const _variant_t & Roll ) {
    HRESULT _hr = raw_AssignYPRAngles(Sequence, Yaw, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCROrientationYPRAngles::QueryAzEl ( VARIANT * Azimuth, VARIANT * Elevation, enum AgEAzElAboutBoresight * AboutBoresight ) {
    HRESULT _hr = raw_QueryAzEl(Azimuth, Elevation, AboutBoresight);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCROrientationYPRAngles::QueryEulerAngles ( enum AgEEulerOrientationSequence Sequence, VARIANT * A, VARIANT * B, VARIANT * C ) {
    HRESULT _hr = raw_QueryEulerAngles(Sequence, A, B, C);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCROrientationYPRAngles::QueryQuaternion ( double * QX, double * QY, double * QZ, double * QS ) {
    HRESULT _hr = raw_QueryQuaternion(QX, QY, QZ, QS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCROrientationYPRAngles::QueryYPRAngles ( enum AgEYPRAnglesSequence Sequence, VARIANT * Yaw, VARIANT * Pitch, VARIANT * Roll ) {
    HRESULT _hr = raw_QueryYPRAngles(Sequence, Yaw, Pitch, Roll);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgCROrientationYPRAngles::QueryAzElArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryAzElArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCROrientationYPRAngles::QueryEulerAnglesArray ( enum AgEEulerOrientationSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryEulerAnglesArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCROrientationYPRAngles::QueryQuaternionArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryQuaternionArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCROrientationYPRAngles::QueryYPRAnglesArray ( enum AgEYPRAnglesSequence Sequence ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QueryYPRAnglesArray(Sequence, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCartesian3VectorPtr _IAgCROrientationYPRAngles::GetPositionOffset ( ) {
    struct IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_PositionOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCartesian3VectorPtr(_result, false);
}

//
// interface _IAgCROrientationOffsetCart wrapper method implementations
//

double _IAgCROrientationOffsetCart::GetX ( ) {
    double _result = 0;
    HRESULT _hr = get_X(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCROrientationOffsetCart::PutX ( double pRetVal ) {
    HRESULT _hr = put_X(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCROrientationOffsetCart::GetY ( ) {
    double _result = 0;
    HRESULT _hr = get_Y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCROrientationOffsetCart::PutY ( double pRetVal ) {
    HRESULT _hr = put_Y(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCROrientationOffsetCart::GetZ ( ) {
    double _result = 0;
    HRESULT _hr = get_Z(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCROrientationOffsetCart::PutZ ( double pRetVal ) {
    HRESULT _hr = put_Z(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgCROrientationOffsetCart::Set ( double X, double Y, double Z ) {
    HRESULT _hr = raw_Set(X, Y, Z);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgCROrientationOffsetCart::ToArray ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_ToArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgUnitPrefsUnit wrapper method implementations
//

_bstr_t _IAgUnitPrefsUnit::GetFullName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FullName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgUnitPrefsUnit::GetAbbrv ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Abbrv(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

long _IAgUnitPrefsUnit::GetId ( ) {
    long _result = 0;
    HRESULT _hr = get_Id(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgUnitPrefsDimPtr _IAgUnitPrefsUnit::GetDimension ( ) {
    struct IAgUnitPrefsDim * _result = 0;
    HRESULT _hr = get_Dimension(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgUnitPrefsDimPtr(_result, false);
}

//
// interface IAgUnitPrefsDim wrapper method implementations
//

long IAgUnitPrefsDim::GetId ( ) {
    long _result = 0;
    HRESULT _hr = get_Id(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t IAgUnitPrefsDim::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

IAgUnitPrefsUnitCollectionPtr IAgUnitPrefsDim::GetAvailableUnits ( ) {
    struct IAgUnitPrefsUnitCollection * _result = 0;
    HRESULT _hr = get_AvailableUnits(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgUnitPrefsUnitCollectionPtr(_result, false);
}

IAgUnitPrefsUnitPtr IAgUnitPrefsDim::GetCurrentUnit ( ) {
    struct IAgUnitPrefsUnit * _result = 0;
    HRESULT _hr = get_CurrentUnit(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgUnitPrefsUnitPtr(_result, false);
}

HRESULT IAgUnitPrefsDim::SetCurrentUnit ( _bstr_t UnitAbbrv ) {
    HRESULT _hr = raw_SetCurrentUnit(UnitAbbrv);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IAgUnitPrefsUnit wrapper method implementations
//

_bstr_t IAgUnitPrefsUnit::GetFullName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FullName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t IAgUnitPrefsUnit::GetAbbrv ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Abbrv(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

long IAgUnitPrefsUnit::GetId ( ) {
    long _result = 0;
    HRESULT _hr = get_Id(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgUnitPrefsDimPtr IAgUnitPrefsUnit::GetDimension ( ) {
    struct IAgUnitPrefsDim * _result = 0;
    HRESULT _hr = get_Dimension(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgUnitPrefsDimPtr(_result, false);
}

//
// interface IAgUnitPrefsUnitCollection wrapper method implementations
//

IAgUnitPrefsUnitPtr IAgUnitPrefsUnitCollection::GetItem ( const _variant_t & IndexOrName ) {
    struct IAgUnitPrefsUnit * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgUnitPrefsUnitPtr(_result, false);
}

long IAgUnitPrefsUnitCollection::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IUnknownPtr IAgUnitPrefsUnitCollection::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface _IAgUnitPrefsDim wrapper method implementations
//

long _IAgUnitPrefsDim::GetId ( ) {
    long _result = 0;
    HRESULT _hr = get_Id(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgUnitPrefsDim::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

IAgUnitPrefsUnitCollectionPtr _IAgUnitPrefsDim::GetAvailableUnits ( ) {
    struct IAgUnitPrefsUnitCollection * _result = 0;
    HRESULT _hr = get_AvailableUnits(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgUnitPrefsUnitCollectionPtr(_result, false);
}

IAgUnitPrefsUnitPtr _IAgUnitPrefsDim::GetCurrentUnit ( ) {
    struct IAgUnitPrefsUnit * _result = 0;
    HRESULT _hr = get_CurrentUnit(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgUnitPrefsUnitPtr(_result, false);
}

HRESULT _IAgUnitPrefsDim::SetCurrentUnit ( _bstr_t UnitAbbrv ) {
    HRESULT _hr = raw_SetCurrentUnit(UnitAbbrv);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IAgUnitPrefsDimCollection wrapper method implementations
//

IAgUnitPrefsDimPtr IAgUnitPrefsDimCollection::GetItem ( const _variant_t & IndexOrName ) {
    struct IAgUnitPrefsDim * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgUnitPrefsDimPtr(_result, false);
}

long IAgUnitPrefsDimCollection::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IAgUnitPrefsDimCollection::SetCurrentUnit ( _bstr_t Dimension, _bstr_t UnitAbbrv ) {
    HRESULT _hr = raw_SetCurrentUnit(Dimension, UnitAbbrv);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t IAgUnitPrefsDimCollection::GetCurrentUnitAbbrv ( const _variant_t & IndexOrDimName ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetCurrentUnitAbbrv(IndexOrDimName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_variant_t IAgUnitPrefsDimCollection::GetMissionElapsedTime ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_MissionElapsedTime(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgUnitPrefsDimCollection::PutMissionElapsedTime ( const _variant_t & pMisElapTime ) {
    HRESULT _hr = put_MissionElapsedTime(pMisElapTime);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgUnitPrefsDimCollection::GetJulianDateOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_JulianDateOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgUnitPrefsDimCollection::PutJulianDateOffset ( double pJDateOffset ) {
    HRESULT _hr = put_JulianDateOffset(pJDateOffset);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IUnknownPtr IAgUnitPrefsDimCollection::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

HRESULT IAgUnitPrefsDimCollection::ResetUnits ( ) {
    HRESULT _hr = raw_ResetUnits();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

} // namespace STKUtil
