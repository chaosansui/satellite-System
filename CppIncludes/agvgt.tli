// Created by Microsoft (R) C/C++ Compiler Version 14.16.27026.1 (fca164ec).
//
// d:\dev\r_stk_prod_x64\source\lib\release.x64\tlhbuilder\agvgt.tli
//
// Wrapper implementations for type library AgVGT.tlb
// compiler-generated file created 03/29/19 at 20:37:36 - DO NOT EDIT!

#pragma once

namespace AgSTKVgtLib {

//
// interface IAgCrdnInterval wrapper method implementations
//

_variant_t IAgCrdnInterval::GetStart ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Start(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

_variant_t IAgCrdnInterval::GetStop ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Stop(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface IAgCrdnIntervalCollection wrapper method implementations
//

long IAgCrdnIntervalCollection::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalPtr IAgCrdnIntervalCollection::GetItem ( long Index ) {
    struct IAgCrdnInterval * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalPtr(_result, false);
}

IUnknownPtr IAgCrdnIntervalCollection::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface IAgCrdnSystemFindInSystemResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnSystemFindInSystemResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnSystemFindInSystemResult::GetPosition ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnSystemFindInSystemResult::GetVelocity ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_Velocity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnSystemFindInSystemResult::GetRate ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_Rate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgOrientationPtr IAgCrdnSystemFindInSystemResult::GetOrientation ( ) {
    struct STKUtil::IAgOrientation * _result = 0;
    HRESULT _hr = get_Orientation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgOrientationPtr(_result, false);
}

//
// interface IAgCrdnSystemTransformResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnSystemTransformResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnSystemTransformResult::GetVector ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_Vector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

//
// interface IAgCrdnSystemTransformWithRateResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnSystemTransformWithRateResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnSystemTransformWithRateResult::GetVector ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_Vector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnSystemTransformWithRateResult::GetVelocity ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_Velocity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

//
// interface IAgCrdnSystem wrapper method implementations
//

enum AgECrdnSystemType IAgCrdnSystem::GetType ( ) {
    enum AgECrdnSystemType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnSystemFindInSystemResultPtr IAgCrdnSystem::FindInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnSystemFindInSystemResult * _result = 0;
    HRESULT _hr = raw_FindInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemFindInSystemResultPtr(_result, false);
}

IAgCrdnSystemTransformResultPtr IAgCrdnSystem::Transform ( const _variant_t & Epoch, struct IAgCrdnSystem * OutputSystem, struct STKUtil::IAgCartesian3Vector * PositionInMySystem ) {
    struct IAgCrdnSystemTransformResult * _result = 0;
    HRESULT _hr = raw_Transform(Epoch, OutputSystem, PositionInMySystem, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemTransformResultPtr(_result, false);
}

IAgCrdnSystemTransformWithRateResultPtr IAgCrdnSystem::TransformWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * OutputSystem, struct STKUtil::IAgCartesian3Vector * PositionInMySystem, struct STKUtil::IAgCartesian3Vector * VelocityInMySystem ) {
    struct IAgCrdnSystemTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformWithRate(Epoch, OutputSystem, PositionInMySystem, VelocityInMySystem, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemTransformWithRateResultPtr(_result, false);
}

//
// interface IAgCrdnPointLocateInSystemWithRateResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnPointLocateInSystemWithRateResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnPointLocateInSystemWithRateResult::GetPosition ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnPointLocateInSystemWithRateResult::GetVelocity ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_Velocity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

//
// interface IAgCrdnPointLocateInSystemResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnPointLocateInSystemResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnPointLocateInSystemResult::GetPosition ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

//
// interface IAgCrdnPoint wrapper method implementations
//

enum AgECrdnPointType IAgCrdnPoint::GetType ( ) {
    enum AgECrdnPointType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointLocateInSystemWithRateResultPtr IAgCrdnPoint::LocateInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_LocateInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPointLocateInSystemResultPtr IAgCrdnPoint::LocateInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemResult * _result = 0;
    HRESULT _hr = raw_LocateInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemResultPtr(_result, false);
}

//
// interface IAgCrdnAxesFindInAxesWithRateResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnAxesFindInAxesWithRateResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnAxesFindInAxesWithRateResult::GetAngularVelocity ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_AngularVelocity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgOrientationPtr IAgCrdnAxesFindInAxesWithRateResult::GetOrientation ( ) {
    struct STKUtil::IAgOrientation * _result = 0;
    HRESULT _hr = get_Orientation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgOrientationPtr(_result, false);
}

//
// interface IAgCrdnAxesFindInAxesResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnAxesFindInAxesResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

STKUtil::IAgOrientationPtr IAgCrdnAxesFindInAxesResult::GetOrientation ( ) {
    struct STKUtil::IAgOrientation * _result = 0;
    HRESULT _hr = get_Orientation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgOrientationPtr(_result, false);
}

//
// interface IAgCrdnAxesLabels wrapper method implementations
//

_bstr_t IAgCrdnAxesLabels::GetLabelX ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnAxesLabels::PutLabelX ( _bstr_t pRetVal ) {
    HRESULT _hr = put_LabelX(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IAgCrdnAxesLabels::GetLabelY ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnAxesLabels::PutLabelY ( _bstr_t pRetVal ) {
    HRESULT _hr = put_LabelY(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IAgCrdnAxesLabels::GetLabelZ ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelZ(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnAxesLabels::PutLabelZ ( _bstr_t pRetVal ) {
    HRESULT _hr = put_LabelZ(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnAxesTransformResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnAxesTransformResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnAxesTransformResult::GetVector ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_Vector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

//
// interface IAgCrdnAxesTransformWithRateResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnAxesTransformWithRateResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnAxesTransformWithRateResult::GetVector ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_Vector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnAxesTransformWithRateResult::GetVelocity ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_Velocity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

//
// interface IAgCrdnVectorFindInAxesResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnVectorFindInAxesResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnVectorFindInAxesResult::GetVector ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_Vector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

//
// interface IAgCrdnVectorFindInAxesWithRateResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnVectorFindInAxesWithRateResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnVectorFindInAxesWithRateResult::GetVector ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_Vector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnVectorFindInAxesWithRateResult::GetRate ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_Rate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

//
// interface IAgCrdnAngleFindAngleResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnAngleFindAngleResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_variant_t IAgCrdnAngleFindAngleResult::GetAngle ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Angle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface IAgCrdnAngleFindAngleWithRateResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnAngleFindAngleWithRateResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_variant_t IAgCrdnAngleFindAngleWithRateResult::GetAngle ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Angle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

_variant_t IAgCrdnAngleFindAngleWithRateResult::GetAngleRate ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_AngleRate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface IAgCrdnAngleFindResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnAngleFindResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_variant_t IAgCrdnAngleFindResult::GetAngle ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Angle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnAngleFindResult::GetVectorFrom ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_VectorFrom(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnAngleFindResult::GetVectorTo ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_VectorTo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnAngleFindResult::GetVectorAbout ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_VectorAbout(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

//
// interface IAgCrdnAngleFindWithRateResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnAngleFindWithRateResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_variant_t IAgCrdnAngleFindWithRateResult::GetAngle ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Angle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

_variant_t IAgCrdnAngleFindWithRateResult::GetAngleRate ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_AngleRate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnAngleFindWithRateResult::GetVectorFrom ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_VectorFrom(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnAngleFindWithRateResult::GetVectorTo ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_VectorTo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnAngleFindWithRateResult::GetVectorAbout ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_VectorAbout(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

//
// interface IAgCrdnPlaneFindInAxesResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnPlaneFindInAxesResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnPlaneFindInAxesResult::GetXAxis ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_XAxis(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnPlaneFindInAxesResult::GetYAxis ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_YAxis(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

//
// interface IAgCrdnPlaneFindInAxesWithRateResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnPlaneFindInAxesWithRateResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnPlaneFindInAxesWithRateResult::GetXAxis ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_XAxis(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnPlaneFindInAxesWithRateResult::GetXAxisRate ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_XAxisRate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnPlaneFindInAxesWithRateResult::GetYAxis ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_YAxis(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnPlaneFindInAxesWithRateResult::GetYAxisRate ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_YAxisRate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

//
// interface IAgCrdnPlaneFindInSystemResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnPlaneFindInSystemResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnPlaneFindInSystemResult::GetOriginPosition ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_OriginPosition(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnPlaneFindInSystemResult::GetXAxis ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_XAxis(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnPlaneFindInSystemResult::GetYAxis ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_YAxis(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

//
// interface IAgCrdnPlaneFindInSystemWithRateResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnPlaneFindInSystemWithRateResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnPlaneFindInSystemWithRateResult::GetOriginPosition ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_OriginPosition(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnPlaneFindInSystemWithRateResult::GetOriginVelocity ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_OriginVelocity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnPlaneFindInSystemWithRateResult::GetXAxis ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_XAxis(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnPlaneFindInSystemWithRateResult::GetXAxisRate ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_XAxisRate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnPlaneFindInSystemWithRateResult::GetYAxis ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_YAxis(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr IAgCrdnPlaneFindInSystemWithRateResult::GetYAxisRate ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_YAxisRate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

//
// interface IAgCrdnPlaneLabels wrapper method implementations
//

_bstr_t IAgCrdnPlaneLabels::GetXAxisLabel ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_XAxisLabel(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnPlaneLabels::PutXAxisLabel ( _bstr_t pRetVal ) {
    HRESULT _hr = put_XAxisLabel(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IAgCrdnPlaneLabels::GetYAxisLabel ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_YAxisLabel(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnPlaneLabels::PutYAxisLabel ( _bstr_t pRetVal ) {
    HRESULT _hr = put_YAxisLabel(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnContext wrapper method implementations
//

VARIANT_BOOL IAgCrdnContext::GetIsTemplate ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsTemplate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnEvaluateResult wrapper method implementations
//

VARIANT_BOOL _IAgCrdnEvaluateResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

double _IAgCrdnEvaluateResult::GetValue ( ) {
    double _result = 0;
    HRESULT _hr = get_Value(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnEvaluateWithRateResult wrapper method implementations
//

VARIANT_BOOL _IAgCrdnEvaluateWithRateResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

double _IAgCrdnEvaluateWithRateResult::GetValue ( ) {
    double _result = 0;
    HRESULT _hr = get_Value(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

double _IAgCrdnEvaluateWithRateResult::GetRate ( ) {
    double _result = 0;
    HRESULT _hr = get_Rate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnEventIntervalResult wrapper method implementations
//

VARIANT_BOOL _IAgCrdnEventIntervalResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalPtr _IAgCrdnEventIntervalResult::GetInterval ( ) {
    struct IAgCrdnInterval * _result = 0;
    HRESULT _hr = get_Interval(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalPtr(_result, false);
}

//
// interface _IAgCrdnEventFindOccurrenceResult wrapper method implementations
//

VARIANT_BOOL _IAgCrdnEventFindOccurrenceResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_variant_t _IAgCrdnEventFindOccurrenceResult::GetEpoch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Epoch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface _IAgCrdnFindTimesResult wrapper method implementations
//

VARIANT_BOOL _IAgCrdnFindTimesResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnFindTimesResult::GetIntervals ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = get_Intervals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

_variant_t _IAgCrdnFindTimesResult::GetStart ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Start(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

_variant_t _IAgCrdnFindTimesResult::GetStop ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Stop(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

SAFEARRAY * _IAgCrdnFindTimesResult::GetTimes ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Times(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCrdnIntervalVectorCollection wrapper method implementations
//

long IAgCrdnIntervalVectorCollection::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr IAgCrdnIntervalVectorCollection::GetItem ( long Index ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

IUnknownPtr IAgCrdnIntervalVectorCollection::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface _IAgCrdnIntervalsVectorResult wrapper method implementations
//

VARIANT_BOOL _IAgCrdnIntervalsVectorResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalVectorCollectionPtr _IAgCrdnIntervalsVectorResult::GetIntervalCollections ( ) {
    struct IAgCrdnIntervalVectorCollection * _result = 0;
    HRESULT _hr = get_IntervalCollections(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalVectorCollectionPtr(_result, false);
}

//
// interface _IAgCrdnEventIntervalCollectionOccurredResult wrapper method implementations
//

VARIANT_BOOL _IAgCrdnEventIntervalCollectionOccurredResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long _IAgCrdnEventIntervalCollectionOccurredResult::GetIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_Index(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnIntervalListResult wrapper method implementations
//

VARIANT_BOOL _IAgCrdnIntervalListResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnIntervalListResult::GetIntervals ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = get_Intervals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

//
// interface _IAgCrdnIntervalVectorCollection wrapper method implementations
//

long _IAgCrdnIntervalVectorCollection::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnIntervalVectorCollection::GetItem ( long Index ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

IUnknownPtr _IAgCrdnIntervalVectorCollection::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface _IAgCrdnConditionSetEvaluateResult wrapper method implementations
//

VARIANT_BOOL _IAgCrdnConditionSetEvaluateResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnConditionSetEvaluateResult::GetValues ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Values(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnConditionSetEvaluateWithRateResult wrapper method implementations
//

VARIANT_BOOL _IAgCrdnConditionSetEvaluateWithRateResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnConditionSetEvaluateWithRateResult::GetValues ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Values(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnConditionSetEvaluateWithRateResult::GetRates ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Rates(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCrdnEvaluateResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnEvaluateResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

double IAgCrdnEvaluateResult::GetValue ( ) {
    double _result = 0;
    HRESULT _hr = get_Value(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCrdnEvaluateWithRateResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnEvaluateWithRateResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

double IAgCrdnEvaluateWithRateResult::GetValue ( ) {
    double _result = 0;
    HRESULT _hr = get_Value(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

double IAgCrdnEvaluateWithRateResult::GetRate ( ) {
    double _result = 0;
    HRESULT _hr = get_Rate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCrdnTypeInfo wrapper method implementations
//

_bstr_t IAgCrdnTypeInfo::GetTypeDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_TypeDescription(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t IAgCrdnTypeInfo::GetTypeName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_TypeName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t IAgCrdnTypeInfo::GetShortTypeDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ShortTypeDescription(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface IAgCrdnFindTimesResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnFindTimesResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr IAgCrdnFindTimesResult::GetIntervals ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = get_Intervals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

_variant_t IAgCrdnFindTimesResult::GetStart ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Start(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

_variant_t IAgCrdnFindTimesResult::GetStop ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Stop(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

SAFEARRAY * IAgCrdnFindTimesResult::GetTimes ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Times(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCrdnEventArray wrapper method implementations
//

enum AgECrdnEventArrayType IAgCrdnEventArray::GetType ( ) {
    enum AgECrdnEventArrayType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnFindTimesResultPtr IAgCrdnEventArray::FindTimes ( ) {
    struct IAgCrdnFindTimesResult * _result = 0;
    HRESULT _hr = raw_FindTimes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnFindTimesResultPtr(_result, false);
}

//
// interface IAgCrdnCalcScalar wrapper method implementations
//

enum AgECrdnCalcScalarType IAgCrdnCalcScalar::GetType ( ) {
    enum AgECrdnCalcScalarType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEvaluateResultPtr IAgCrdnCalcScalar::Evaluate ( const _variant_t & Epoch ) {
    struct IAgCrdnEvaluateResult * _result = 0;
    HRESULT _hr = raw_Evaluate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEvaluateResultPtr(_result, false);
}

SAFEARRAY * IAgCrdnCalcScalar::QuickEvaluate ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEvaluateWithRateResultPtr IAgCrdnCalcScalar::EvaluateWithRate ( const _variant_t & Epoch ) {
    struct IAgCrdnEvaluateWithRateResult * _result = 0;
    HRESULT _hr = raw_EvaluateWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEvaluateWithRateResultPtr(_result, false);
}

SAFEARRAY * IAgCrdnCalcScalar::QuickEvaluateWithRate ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr IAgCrdnCalcScalar::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

_bstr_t IAgCrdnCalcScalar::GetUnitOfMeasure ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_UnitOfMeasure(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

SAFEARRAY * IAgCrdnCalcScalar::QuickEvaluateArray ( SAFEARRAY * * Times ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateArray(Times, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgCrdnCalcScalar::QuickEvaluateWithRateArray ( SAFEARRAY * * Times ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRateArray(Times, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgCrdnCalcScalar::QuickEvaluateEventArray ( struct IAgCrdnEventArray * RefArray ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateEventArray(RefArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgCrdnCalcScalar::QuickEvaluateWithRateEventArray ( struct IAgCrdnEventArray * RefArray ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRateEventArray(RefArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCrdnEventFindOccurrenceResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnEventFindOccurrenceResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_variant_t IAgCrdnEventFindOccurrenceResult::GetEpoch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Epoch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface IAgCrdnEvent wrapper method implementations
//

enum AgECrdnEventType IAgCrdnEvent::GetType ( ) {
    enum AgECrdnEventType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEventPtr IAgCrdnEvent::GetToday ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_Today(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventPtr IAgCrdnEvent::GetTomorrow ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_Tomorrow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventPtr IAgCrdnEvent::GetNoonToday ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_NoonToday(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventPtr IAgCrdnEvent::GetNoonTomorrow ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_NoonTomorrow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventFindOccurrenceResultPtr IAgCrdnEvent::FindOccurrence ( ) {
    struct IAgCrdnEventFindOccurrenceResult * _result = 0;
    HRESULT _hr = raw_FindOccurrence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventFindOccurrenceResultPtr(_result, false);
}

VARIANT_BOOL IAgCrdnEvent::OccursBefore ( const _variant_t & Epoch ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_OccursBefore(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnCalcScalarFactory wrapper method implementations
//

SAFEARRAY * _IAgCrdnCalcScalarFactory::GetAvailableCalcScalarPluginDisplayNames ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_AvailableCalcScalarPluginDisplayNames(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCalcScalarPtr _IAgCrdnCalcScalarFactory::Create ( _bstr_t Name, _bstr_t Description, enum AgECrdnCalcScalarType Type ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = raw_Create(Name, Description, Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

IAgCrdnCalcScalarPtr _IAgCrdnCalcScalarFactory::CreateCalcScalarAngle ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = raw_CreateCalcScalarAngle(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

IAgCrdnCalcScalarPtr _IAgCrdnCalcScalarFactory::CreateCalcScalarFixedAtTimeInstant ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = raw_CreateCalcScalarFixedAtTimeInstant(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

IAgCrdnCalcScalarPtr _IAgCrdnCalcScalarFactory::CreateCalcScalarConstant ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = raw_CreateCalcScalarConstant(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

IAgCrdnCalcScalarPtr _IAgCrdnCalcScalarFactory::CreateCalcScalarDataElement ( _bstr_t Name, _bstr_t Description, _bstr_t DataProvider, _bstr_t ElementName ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = raw_CreateCalcScalarDataElement(Name, Description, DataProvider, ElementName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

IAgCrdnCalcScalarPtr _IAgCrdnCalcScalarFactory::CreateCalcScalarDataElementWithGroup ( _bstr_t Name, _bstr_t Description, _bstr_t DataProvider, _bstr_t GroupName, _bstr_t ElementName ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = raw_CreateCalcScalarDataElementWithGroup(Name, Description, DataProvider, GroupName, ElementName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

IAgCrdnCalcScalarPtr _IAgCrdnCalcScalarFactory::CreateCalcScalarDerivative ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = raw_CreateCalcScalarDerivative(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

IAgCrdnCalcScalarPtr _IAgCrdnCalcScalarFactory::CreateCalcScalarElapsedTime ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = raw_CreateCalcScalarElapsedTime(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

IAgCrdnCalcScalarPtr _IAgCrdnCalcScalarFactory::CreateCalcScalarFile ( _bstr_t Name, _bstr_t Description, _bstr_t Filepath ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = raw_CreateCalcScalarFile(Name, Description, Filepath, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

IAgCrdnCalcScalarPtr _IAgCrdnCalcScalarFactory::CreateCalcScalarFunction ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = raw_CreateCalcScalarFunction(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

IAgCrdnCalcScalarPtr _IAgCrdnCalcScalarFactory::CreateCalcScalarIntegral ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = raw_CreateCalcScalarIntegral(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

IAgCrdnCalcScalarPtr _IAgCrdnCalcScalarFactory::CreateCalcScalarFunction2Var ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = raw_CreateCalcScalarFunction2Var(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

IAgCrdnCalcScalarPtr _IAgCrdnCalcScalarFactory::CreateCalcScalarVectorMagnitude ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = raw_CreateCalcScalarVectorMagnitude(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

IAgCrdnCalcScalarPtr _IAgCrdnCalcScalarFactory::CreateCalcScalarPluginFromDisplayName ( _bstr_t Name, _bstr_t Description, _bstr_t DisplayName ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = raw_CreateCalcScalarPluginFromDisplayName(Name, Description, DisplayName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarFactory::IsTypeSupported ( enum AgECrdnCalcScalarType EType ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(EType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCalcScalarPtr _IAgCrdnCalcScalarFactory::CreateCalcScalarFromCustomScript ( _bstr_t Name, _bstr_t Description, _bstr_t Filepath ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = raw_CreateCalcScalarFromCustomScript(Name, Description, Filepath, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

IAgCrdnCalcScalarPtr _IAgCrdnCalcScalarFactory::CreateCalcScalarSurfaceDistanceBetweenPoints ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = raw_CreateCalcScalarSurfaceDistanceBetweenPoints(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

//
// interface IAgCrdnEventIntervalResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnEventIntervalResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalPtr IAgCrdnEventIntervalResult::GetInterval ( ) {
    struct IAgCrdnInterval * _result = 0;
    HRESULT _hr = get_Interval(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalPtr(_result, false);
}

//
// interface IAgCrdnIntervalListResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnIntervalListResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr IAgCrdnIntervalListResult::GetIntervals ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = get_Intervals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

//
// interface IAgCrdnEventIntervalList wrapper method implementations
//

enum AgECrdnEventIntervalListType IAgCrdnEventIntervalList::GetType ( ) {
    enum AgECrdnEventIntervalListType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgCrdnEventIntervalList::GetLabels ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgCrdnEventIntervalList::GetDescriptions ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Descriptions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalListResultPtr IAgCrdnEventIntervalList::FindIntervals ( ) {
    struct IAgCrdnIntervalListResult * _result = 0;
    HRESULT _hr = raw_FindIntervals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalListResultPtr(_result, false);
}

VARIANT_BOOL IAgCrdnEventIntervalList::Occurred ( const _variant_t & Epoch ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Occurred(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCrdnCondition wrapper method implementations
//

enum AgECrdnConditionType IAgCrdnCondition::GetType ( ) {
    enum AgECrdnConditionType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEvaluateResultPtr IAgCrdnCondition::Evaluate ( const _variant_t & Epoch ) {
    struct IAgCrdnEvaluateResult * _result = 0;
    HRESULT _hr = raw_Evaluate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEvaluateResultPtr(_result, false);
}

IAgCrdnEvaluateWithRateResultPtr IAgCrdnCondition::EvaluateWithRate ( const _variant_t & Epoch ) {
    struct IAgCrdnEvaluateWithRateResult * _result = 0;
    HRESULT _hr = raw_EvaluateWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEvaluateWithRateResultPtr(_result, false);
}

//
// interface _IAgCrdnConditionFactory wrapper method implementations
//

IAgCrdnConditionPtr _IAgCrdnConditionFactory::Create ( _bstr_t Name, _bstr_t Description, enum AgECrdnConditionType Type ) {
    struct IAgCrdnCondition * _result = 0;
    HRESULT _hr = raw_Create(Name, Description, Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConditionPtr(_result, false);
}

IAgCrdnConditionPtr _IAgCrdnConditionFactory::CreateConditionScalarBounds ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnCondition * _result = 0;
    HRESULT _hr = raw_CreateConditionScalarBounds(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConditionPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnConditionFactory::IsTypeSupported ( enum AgECrdnConditionType EType ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(EType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnConditionPtr _IAgCrdnConditionFactory::CreateConditionCombined ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnCondition * _result = 0;
    HRESULT _hr = raw_CreateConditionCombined(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConditionPtr(_result, false);
}

//
// interface IAgCrdnConditionSetEvaluateResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnConditionSetEvaluateResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgCrdnConditionSetEvaluateResult::GetValues ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Values(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCrdnConditionSetEvaluateWithRateResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnConditionSetEvaluateWithRateResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgCrdnConditionSetEvaluateWithRateResult::GetValues ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Values(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgCrdnConditionSetEvaluateWithRateResult::GetRates ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Rates(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCrdnConditionSet wrapper method implementations
//

enum AgECrdnConditionSetType IAgCrdnConditionSet::GetType ( ) {
    enum AgECrdnConditionSetType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnConditionSetEvaluateResultPtr IAgCrdnConditionSet::Evaluate ( const _variant_t & Epoch ) {
    struct IAgCrdnConditionSetEvaluateResult * _result = 0;
    HRESULT _hr = raw_Evaluate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConditionSetEvaluateResultPtr(_result, false);
}

IAgCrdnConditionSetEvaluateWithRateResultPtr IAgCrdnConditionSet::EvaluateWithRate ( const _variant_t & Epoch ) {
    struct IAgCrdnConditionSetEvaluateWithRateResult * _result = 0;
    HRESULT _hr = raw_EvaluateWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConditionSetEvaluateWithRateResultPtr(_result, false);
}

//
// interface _IAgCrdnConditionSetFactory wrapper method implementations
//

IAgCrdnConditionSetPtr _IAgCrdnConditionSetFactory::Create ( _bstr_t Name, _bstr_t Description, enum AgECrdnConditionSetType Type ) {
    struct IAgCrdnConditionSet * _result = 0;
    HRESULT _hr = raw_Create(Name, Description, Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConditionSetPtr(_result, false);
}

IAgCrdnConditionSetPtr _IAgCrdnConditionSetFactory::CreateScalarThresholds ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnConditionSet * _result = 0;
    HRESULT _hr = raw_CreateScalarThresholds(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConditionSetPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnConditionSetFactory::IsTypeSupported ( enum AgECrdnConditionSetType EType ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(EType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnEventArrayFactory wrapper method implementations
//

IAgCrdnEventArrayPtr _IAgCrdnEventArrayFactory::Create ( _bstr_t Name, _bstr_t Description, enum AgECrdnEventArrayType Type ) {
    struct IAgCrdnEventArray * _result = 0;
    HRESULT _hr = raw_Create(Name, Description, Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventArrayPtr(_result, false);
}

IAgCrdnEventArrayPtr _IAgCrdnEventArrayFactory::CreateEventArrayExtrema ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventArray * _result = 0;
    HRESULT _hr = raw_CreateEventArrayExtrema(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventArrayPtr(_result, false);
}

IAgCrdnEventArrayPtr _IAgCrdnEventArrayFactory::CreateEventArrayStartStopTimes ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventArray * _result = 0;
    HRESULT _hr = raw_CreateEventArrayStartStopTimes(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventArrayPtr(_result, false);
}

IAgCrdnEventArrayPtr _IAgCrdnEventArrayFactory::CreateEventArrayMerged ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventArray * _result = 0;
    HRESULT _hr = raw_CreateEventArrayMerged(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventArrayPtr(_result, false);
}

IAgCrdnEventArrayPtr _IAgCrdnEventArrayFactory::CreateEventArrayFiltered ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventArray * _result = 0;
    HRESULT _hr = raw_CreateEventArrayFiltered(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventArrayPtr(_result, false);
}

IAgCrdnEventArrayPtr _IAgCrdnEventArrayFactory::CreateEventArrayFixedStep ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventArray * _result = 0;
    HRESULT _hr = raw_CreateEventArrayFixedStep(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventArrayPtr(_result, false);
}

IAgCrdnEventArrayPtr _IAgCrdnEventArrayFactory::CreateEventArrayConditionCrossings ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventArray * _result = 0;
    HRESULT _hr = raw_CreateEventArrayConditionCrossings(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventArrayPtr(_result, false);
}

IAgCrdnEventArrayPtr _IAgCrdnEventArrayFactory::CreateEventArraySignaled ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventArray * _result = 0;
    HRESULT _hr = raw_CreateEventArraySignaled(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventArrayPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventArrayFactory::IsTypeSupported ( enum AgECrdnEventArrayType EType ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(EType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEventArrayPtr _IAgCrdnEventArrayFactory::CreateEventArrayFixedTimes ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventArray * _result = 0;
    HRESULT _hr = raw_CreateEventArrayFixedTimes(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventArrayPtr(_result, false);
}

//
// interface IAgCrdnEventSmartEpoch wrapper method implementations
//

_variant_t IAgCrdnEventSmartEpoch::GetTimeInstant ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_TimeInstant(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

IAgCrdnEventPtr IAgCrdnEventSmartEpoch::GetReferenceEvent ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_ReferenceEvent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

enum AgECrdnSmartEpochState IAgCrdnEventSmartEpoch::GetState ( ) {
    enum AgECrdnSmartEpochState _result;
    HRESULT _hr = get_State(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventSmartEpoch::PutState ( enum AgECrdnSmartEpochState pRetVal ) {
    HRESULT _hr = put_State(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgCrdnEventSmartEpoch::SetExplicitTime ( const _variant_t & Epoch ) {
    HRESULT _hr = raw_SetExplicitTime(Epoch);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgCrdnEventSmartEpoch::SetImplicitTime ( struct IAgCrdnEvent * EventEpoch ) {
    HRESULT _hr = raw_SetImplicitTime(EventEpoch);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnEventFactory wrapper method implementations
//

IAgCrdnEventPtr _IAgCrdnEventFactory::GetToday ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_Today(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventPtr _IAgCrdnEventFactory::GetTomorrow ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_Tomorrow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventPtr _IAgCrdnEventFactory::Create ( _bstr_t Name, _bstr_t Description, enum AgECrdnEventType Type ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = raw_Create(Name, Description, Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventPtr _IAgCrdnEventFactory::CreateEventEpoch ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = raw_CreateEventEpoch(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventPtr _IAgCrdnEventFactory::CreateEventExtremum ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = raw_CreateEventExtremum(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventPtr _IAgCrdnEventFactory::CreateEventStartStopTime ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = raw_CreateEventStartStopTime(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventPtr _IAgCrdnEventFactory::CreateEventSignaled ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = raw_CreateEventSignaled(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventPtr _IAgCrdnEventFactory::CreateEventTimeOffset ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = raw_CreateEventTimeOffset(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventSmartEpochPtr _IAgCrdnEventFactory::CreateSmartEpochFromTime ( const _variant_t & Epoch ) {
    struct IAgCrdnEventSmartEpoch * _result = 0;
    HRESULT _hr = raw_CreateSmartEpochFromTime(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventSmartEpochPtr(_result, false);
}

IAgCrdnEventSmartEpochPtr _IAgCrdnEventFactory::CreateSmartEpochFromEvent ( struct IAgCrdnEvent * RefEvent ) {
    struct IAgCrdnEventSmartEpoch * _result = 0;
    HRESULT _hr = raw_CreateSmartEpochFromEvent(RefEvent, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventSmartEpochPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventFactory::IsTypeSupported ( enum AgECrdnEventType EType ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(EType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCrdnIntervalsVectorResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnIntervalsVectorResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalVectorCollectionPtr IAgCrdnIntervalsVectorResult::GetIntervalCollections ( ) {
    struct IAgCrdnIntervalVectorCollection * _result = 0;
    HRESULT _hr = get_IntervalCollections(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalVectorCollectionPtr(_result, false);
}

//
// interface IAgCrdnEventIntervalCollectionOccurredResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnEventIntervalCollectionOccurredResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IAgCrdnEventIntervalCollectionOccurredResult::GetIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_Index(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCrdnEventIntervalCollection wrapper method implementations
//

enum AgECrdnEventIntervalCollectionType IAgCrdnEventIntervalCollection::GetType ( ) {
    enum AgECrdnEventIntervalCollectionType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgCrdnEventIntervalCollection::GetLabels ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalsVectorResultPtr IAgCrdnEventIntervalCollection::FindIntervalCollection ( ) {
    struct IAgCrdnIntervalsVectorResult * _result = 0;
    HRESULT _hr = raw_FindIntervalCollection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalsVectorResultPtr(_result, false);
}

IAgCrdnEventIntervalCollectionOccurredResultPtr IAgCrdnEventIntervalCollection::Occurred ( const _variant_t & Epoch ) {
    struct IAgCrdnEventIntervalCollectionOccurredResult * _result = 0;
    HRESULT _hr = raw_Occurred(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalCollectionOccurredResultPtr(_result, false);
}

//
// interface _IAgCrdnEventIntervalCollectionFactory wrapper method implementations
//

IAgCrdnEventIntervalCollectionPtr _IAgCrdnEventIntervalCollectionFactory::Create ( _bstr_t Name, _bstr_t Description, enum AgECrdnEventIntervalCollectionType Type ) {
    struct IAgCrdnEventIntervalCollection * _result = 0;
    HRESULT _hr = raw_Create(Name, Description, Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalCollectionPtr(_result, false);
}

IAgCrdnEventIntervalCollectionPtr _IAgCrdnEventIntervalCollectionFactory::CreateEventIntervalCollectionLighting ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventIntervalCollection * _result = 0;
    HRESULT _hr = raw_CreateEventIntervalCollectionLighting(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalCollectionPtr(_result, false);
}

IAgCrdnEventIntervalCollectionPtr _IAgCrdnEventIntervalCollectionFactory::CreateEventIntervalCollectionSignaled ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventIntervalCollection * _result = 0;
    HRESULT _hr = raw_CreateEventIntervalCollectionSignaled(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalCollectionPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalCollectionFactory::IsTypeSupported ( enum AgECrdnEventIntervalCollectionType EType ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(EType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEventIntervalCollectionPtr _IAgCrdnEventIntervalCollectionFactory::CreateEventIntervalCollectionSatisfaction ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventIntervalCollection * _result = 0;
    HRESULT _hr = raw_CreateEventIntervalCollectionSatisfaction(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalCollectionPtr(_result, false);
}

//
// interface IAgCrdnEventInterval wrapper method implementations
//

enum AgECrdnEventIntervalType IAgCrdnEventInterval::GetType ( ) {
    enum AgECrdnEventIntervalType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t IAgCrdnEventInterval::GetLabelStartDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelStartDescription(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t IAgCrdnEventInterval::GetLabelStopDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelStopDescription(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t IAgCrdnEventInterval::GetLabelStart ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelStart(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t IAgCrdnEventInterval::GetLabelStop ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelStop(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

IAgCrdnEventIntervalResultPtr IAgCrdnEventInterval::FindInterval ( ) {
    struct IAgCrdnEventIntervalResult * _result = 0;
    HRESULT _hr = raw_FindInterval(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalResultPtr(_result, false);
}

VARIANT_BOOL IAgCrdnEventInterval::Occurred ( const _variant_t & Epoch ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Occurred(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnEventIntervalFactory wrapper method implementations
//

IAgCrdnEventIntervalPtr _IAgCrdnEventIntervalFactory::Create ( _bstr_t Name, _bstr_t Description, enum AgECrdnEventIntervalType Type ) {
    struct IAgCrdnEventInterval * _result = 0;
    HRESULT _hr = raw_Create(Name, Description, Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalPtr(_result, false);
}

IAgCrdnEventIntervalPtr _IAgCrdnEventIntervalFactory::CreateEventIntervalFixed ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventInterval * _result = 0;
    HRESULT _hr = raw_CreateEventIntervalFixed(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalPtr(_result, false);
}

IAgCrdnEventIntervalPtr _IAgCrdnEventIntervalFactory::CreateEventIntervalFixedDuration ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventInterval * _result = 0;
    HRESULT _hr = raw_CreateEventIntervalFixedDuration(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalPtr(_result, false);
}

IAgCrdnEventIntervalPtr _IAgCrdnEventIntervalFactory::CreateEventIntervalBetweenTimeInstants ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventInterval * _result = 0;
    HRESULT _hr = raw_CreateEventIntervalBetweenTimeInstants(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalPtr(_result, false);
}

IAgCrdnEventIntervalPtr _IAgCrdnEventIntervalFactory::CreateEventIntervalFromIntervalList ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventInterval * _result = 0;
    HRESULT _hr = raw_CreateEventIntervalFromIntervalList(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalPtr(_result, false);
}

IAgCrdnEventIntervalPtr _IAgCrdnEventIntervalFactory::CreateEventIntervalScaled ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventInterval * _result = 0;
    HRESULT _hr = raw_CreateEventIntervalScaled(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalPtr(_result, false);
}

IAgCrdnEventIntervalPtr _IAgCrdnEventIntervalFactory::CreateEventIntervalSignaled ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventInterval * _result = 0;
    HRESULT _hr = raw_CreateEventIntervalSignaled(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalPtr(_result, false);
}

IAgCrdnEventIntervalPtr _IAgCrdnEventIntervalFactory::CreateEventIntervalTimeOffset ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventInterval * _result = 0;
    HRESULT _hr = raw_CreateEventIntervalTimeOffset(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalFactory::IsTypeSupported ( enum AgECrdnEventIntervalType EType ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(EType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnEventIntervalListFactory wrapper method implementations
//

IAgCrdnEventIntervalListPtr _IAgCrdnEventIntervalListFactory::Create ( _bstr_t Name, _bstr_t Description, enum AgECrdnEventIntervalListType Type ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = raw_Create(Name, Description, Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

IAgCrdnEventIntervalListPtr _IAgCrdnEventIntervalListFactory::CreateEventIntervalListFromFile ( _bstr_t Name, _bstr_t Description, _bstr_t Filepath ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = raw_CreateEventIntervalListFromFile(Name, Description, Filepath, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

IAgCrdnEventIntervalListPtr _IAgCrdnEventIntervalListFactory::CreateEventIntervalListMerged ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = raw_CreateEventIntervalListMerged(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

IAgCrdnEventIntervalListPtr _IAgCrdnEventIntervalListFactory::CreateEventIntervalListFiltered ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = raw_CreateEventIntervalListFiltered(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

IAgCrdnEventIntervalListPtr _IAgCrdnEventIntervalListFactory::CreateEventIntervalListCondition ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = raw_CreateEventIntervalListCondition(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

IAgCrdnEventIntervalListPtr _IAgCrdnEventIntervalListFactory::CreateEventIntervalListScaled ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = raw_CreateEventIntervalListScaled(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

IAgCrdnEventIntervalListPtr _IAgCrdnEventIntervalListFactory::CreateEventIntervalListSignaled ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = raw_CreateEventIntervalListSignaled(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

IAgCrdnEventIntervalListPtr _IAgCrdnEventIntervalListFactory::CreateEventIntervalListTimeOffset ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = raw_CreateEventIntervalListTimeOffset(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalListFactory::IsTypeSupported ( enum AgECrdnEventIntervalListType EType ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(EType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEventIntervalListPtr _IAgCrdnEventIntervalListFactory::CreateEventIntervalListFile ( _bstr_t Name, _bstr_t Description, _bstr_t Filepath ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = raw_CreateEventIntervalListFile(Name, Description, Filepath, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

IAgCrdnEventIntervalListPtr _IAgCrdnEventIntervalListFactory::CreateEventIntervalListFixed ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = raw_CreateEventIntervalListFixed(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

//
// interface IAgCrdnPruneFilter wrapper method implementations
//

enum AgECrdnPruneFilter IAgCrdnPruneFilter::GetFilterType ( ) {
    enum AgECrdnPruneFilter _result;
    HRESULT _hr = get_FilterType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCrdnPruneFilterFactory wrapper method implementations
//

IAgCrdnPruneFilterPtr IAgCrdnPruneFilterFactory::Create ( enum AgECrdnPruneFilter EFilter ) {
    struct IAgCrdnPruneFilter * _result = 0;
    HRESULT _hr = raw_Create(EFilter, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPruneFilterPtr(_result, false);
}

//
// interface _IAgCrdnFirstIntervalsFilter wrapper method implementations
//

enum AgECrdnPruneFilter _IAgCrdnFirstIntervalsFilter::GetFilterType ( ) {
    enum AgECrdnPruneFilter _result;
    HRESULT _hr = get_FilterType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

int _IAgCrdnFirstIntervalsFilter::GetMaximumNumberOfIntervals ( ) {
    int _result = 0;
    HRESULT _hr = get_MaximumNumberOfIntervals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnFirstIntervalsFilter::PutMaximumNumberOfIntervals ( int pRetVal ) {
    HRESULT _hr = put_MaximumNumberOfIntervals(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnGapsFilter wrapper method implementations
//

enum AgECrdnPruneFilter _IAgCrdnGapsFilter::GetFilterType ( ) {
    enum AgECrdnPruneFilter _result;
    HRESULT _hr = get_FilterType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

enum AgECrdnIntervalDurationKind _IAgCrdnGapsFilter::GetDurationKind ( ) {
    enum AgECrdnIntervalDurationKind _result;
    HRESULT _hr = get_DurationKind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnGapsFilter::PutDurationKind ( enum AgECrdnIntervalDurationKind pRetVal ) {
    HRESULT _hr = put_DurationKind(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnGapsFilter::GetGapDuration ( ) {
    double _result = 0;
    HRESULT _hr = get_GapDuration(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnGapsFilter::PutGapDuration ( double pRetVal ) {
    HRESULT _hr = put_GapDuration(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnIntervalsFilter wrapper method implementations
//

enum AgECrdnPruneFilter _IAgCrdnIntervalsFilter::GetFilterType ( ) {
    enum AgECrdnPruneFilter _result;
    HRESULT _hr = get_FilterType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

enum AgECrdnIntervalDurationKind _IAgCrdnIntervalsFilter::GetDurationKind ( ) {
    enum AgECrdnIntervalDurationKind _result;
    HRESULT _hr = get_DurationKind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnIntervalsFilter::PutDurationKind ( enum AgECrdnIntervalDurationKind pRetVal ) {
    HRESULT _hr = put_DurationKind(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnIntervalsFilter::GetIntervalDuration ( ) {
    double _result = 0;
    HRESULT _hr = get_IntervalDuration(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnIntervalsFilter::PutIntervalDuration ( double pRetVal ) {
    HRESULT _hr = put_IntervalDuration(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnLastIntervalsFilter wrapper method implementations
//

enum AgECrdnPruneFilter _IAgCrdnLastIntervalsFilter::GetFilterType ( ) {
    enum AgECrdnPruneFilter _result;
    HRESULT _hr = get_FilterType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

int _IAgCrdnLastIntervalsFilter::GetMaximumNumberOfIntervals ( ) {
    int _result = 0;
    HRESULT _hr = get_MaximumNumberOfIntervals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnLastIntervalsFilter::PutMaximumNumberOfIntervals ( int pRetVal ) {
    HRESULT _hr = put_MaximumNumberOfIntervals(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnParameterSet wrapper method implementations
//

enum AgECrdnParameterSetType IAgCrdnParameterSet::GetType ( ) {
    enum AgECrdnParameterSetType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgCrdnParameterSet::GetLabels ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgCrdnParameterSet::GetDimensions ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Dimensions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgCrdnParameterSet::GetScalarNames ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_ScalarNames(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgCrdnParameterSet::Calculate ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_Calculate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgCrdnParameterSet::CalculateWithDerivative ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_CalculateWithDerivative(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnParameterSetFactory wrapper method implementations
//

IAgCrdnParameterSetPtr _IAgCrdnParameterSetFactory::Create ( _bstr_t Name, _bstr_t Description, enum AgECrdnParameterSetType Type ) {
    struct IAgCrdnParameterSet * _result = 0;
    HRESULT _hr = raw_Create(Name, Description, Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnParameterSetPtr(_result, false);
}

IAgCrdnParameterSetPtr _IAgCrdnParameterSetFactory::CreateParameterSetAttitude ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnParameterSet * _result = 0;
    HRESULT _hr = raw_CreateParameterSetAttitude(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnParameterSetPtr(_result, false);
}

IAgCrdnParameterSetPtr _IAgCrdnParameterSetFactory::CreateParameterSetGroundTrajectory ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnParameterSet * _result = 0;
    HRESULT _hr = raw_CreateParameterSetGroundTrajectory(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnParameterSetPtr(_result, false);
}

IAgCrdnParameterSetPtr _IAgCrdnParameterSetFactory::CreateParameterSetTrajectory ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnParameterSet * _result = 0;
    HRESULT _hr = raw_CreateParameterSetTrajectory(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnParameterSetPtr(_result, false);
}

IAgCrdnParameterSetPtr _IAgCrdnParameterSetFactory::CreateParameterSetOrbit ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnParameterSet * _result = 0;
    HRESULT _hr = raw_CreateParameterSetOrbit(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnParameterSetPtr(_result, false);
}

IAgCrdnParameterSetPtr _IAgCrdnParameterSetFactory::CreateParameterSetVector ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnParameterSet * _result = 0;
    HRESULT _hr = raw_CreateParameterSetVector(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnParameterSetPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnParameterSetFactory::IsTypeSupported ( enum AgECrdnParameterSetType EType ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(EType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnPruneFilter wrapper method implementations
//

enum AgECrdnPruneFilter _IAgCrdnPruneFilter::GetFilterType ( ) {
    enum AgECrdnPruneFilter _result;
    HRESULT _hr = get_FilterType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnPruneFilterFactory wrapper method implementations
//

IAgCrdnPruneFilterPtr _IAgCrdnPruneFilterFactory::Create ( enum AgECrdnPruneFilter EFilter ) {
    struct IAgCrdnPruneFilter * _result = 0;
    HRESULT _hr = raw_Create(EFilter, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPruneFilterPtr(_result, false);
}

//
// interface _IAgCrdnRelativeSatisfactionConditionFilter wrapper method implementations
//

enum AgECrdnPruneFilter _IAgCrdnRelativeSatisfactionConditionFilter::GetFilterType ( ) {
    enum AgECrdnPruneFilter _result;
    HRESULT _hr = get_FilterType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnConditionPtr _IAgCrdnRelativeSatisfactionConditionFilter::GetCondition ( ) {
    struct IAgCrdnCondition * _result = 0;
    HRESULT _hr = get_Condition(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConditionPtr(_result, false);
}

void _IAgCrdnRelativeSatisfactionConditionFilter::PutCondition ( struct IAgCrdnCondition * ppRetVal ) {
    HRESULT _hr = put_Condition(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnIntervalDurationKind _IAgCrdnRelativeSatisfactionConditionFilter::GetDurationKind ( ) {
    enum AgECrdnIntervalDurationKind _result;
    HRESULT _hr = get_DurationKind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnRelativeSatisfactionConditionFilter::PutDurationKind ( enum AgECrdnIntervalDurationKind pRetVal ) {
    HRESULT _hr = put_DurationKind(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnRelativeSatisfactionConditionFilter::GetRelativeIntervalDuration ( ) {
    double _result = 0;
    HRESULT _hr = get_RelativeIntervalDuration(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnRelativeSatisfactionConditionFilter::PutRelativeIntervalDuration ( double pRetVal ) {
    HRESULT _hr = put_RelativeIntervalDuration(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnSamplingMethod wrapper method implementations
//

enum AgECrdnSamplingMethod IAgCrdnSamplingMethod::GetMethodType ( ) {
    enum AgECrdnSamplingMethod _result;
    HRESULT _hr = get_MethodType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCrdnSamplingMethodFactory wrapper method implementations
//

IAgCrdnSamplingMethodPtr IAgCrdnSamplingMethodFactory::CreateFixedStep ( double FixedStep ) {
    struct IAgCrdnSamplingMethod * _result = 0;
    HRESULT _hr = raw_CreateFixedStep(FixedStep, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSamplingMethodPtr(_result, false);
}

IAgCrdnSamplingMethodPtr IAgCrdnSamplingMethodFactory::CreateCurvatureTolerance ( double CurvatureTolerance ) {
    struct IAgCrdnSamplingMethod * _result = 0;
    HRESULT _hr = raw_CreateCurvatureTolerance(CurvatureTolerance, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSamplingMethodPtr(_result, false);
}

IAgCrdnSamplingMethodPtr IAgCrdnSamplingMethodFactory::CreateRelativeTolerance ( double RelativeTolerance ) {
    struct IAgCrdnSamplingMethod * _result = 0;
    HRESULT _hr = raw_CreateRelativeTolerance(RelativeTolerance, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSamplingMethodPtr(_result, false);
}

//
// interface _IAgCrdnSamplingCurvatureTolerance wrapper method implementations
//

enum AgECrdnSamplingMethod _IAgCrdnSamplingCurvatureTolerance::GetMethodType ( ) {
    enum AgECrdnSamplingMethod _result;
    HRESULT _hr = get_MethodType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

double _IAgCrdnSamplingCurvatureTolerance::GetMinimumTimeStep ( ) {
    double _result = 0;
    HRESULT _hr = get_MinimumTimeStep(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnSamplingCurvatureTolerance::PutMinimumTimeStep ( double pRetVal ) {
    HRESULT _hr = put_MinimumTimeStep(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnSamplingCurvatureTolerance::GetMaximumTimeStep ( ) {
    double _result = 0;
    HRESULT _hr = get_MaximumTimeStep(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnSamplingCurvatureTolerance::PutMaximumTimeStep ( double pRetVal ) {
    HRESULT _hr = put_MaximumTimeStep(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnSamplingCurvatureTolerance::GetStepAtBoundaries ( ) {
    double _result = 0;
    HRESULT _hr = get_StepAtBoundaries(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnSamplingCurvatureTolerance::PutStepAtBoundaries ( double pRetVal ) {
    HRESULT _hr = put_StepAtBoundaries(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnSamplingCurvatureTolerance::GetRelativeTolerance ( ) {
    double _result = 0;
    HRESULT _hr = get_RelativeTolerance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnSamplingCurvatureTolerance::PutRelativeTolerance ( double pRetVal ) {
    HRESULT _hr = put_RelativeTolerance(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnSamplingCurvatureTolerance::GetAbsoluteTolerance ( ) {
    double _result = 0;
    HRESULT _hr = get_AbsoluteTolerance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnSamplingCurvatureTolerance::PutAbsoluteTolerance ( double pRetVal ) {
    HRESULT _hr = put_AbsoluteTolerance(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnSamplingCurvatureTolerance::GetCurvatureTolerance ( ) {
    double _result = 0;
    HRESULT _hr = get_CurvatureTolerance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnSamplingCurvatureTolerance::PutCurvatureTolerance ( double pRetVal ) {
    HRESULT _hr = put_CurvatureTolerance(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnSamplingFixedStep wrapper method implementations
//

enum AgECrdnSamplingMethod _IAgCrdnSamplingFixedStep::GetMethodType ( ) {
    enum AgECrdnSamplingMethod _result;
    HRESULT _hr = get_MethodType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

double _IAgCrdnSamplingFixedStep::GetTimeStep ( ) {
    double _result = 0;
    HRESULT _hr = get_TimeStep(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnSamplingFixedStep::PutTimeStep ( double pRetVal ) {
    HRESULT _hr = put_TimeStep(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnSamplingMethod wrapper method implementations
//

enum AgECrdnSamplingMethod _IAgCrdnSamplingMethod::GetMethodType ( ) {
    enum AgECrdnSamplingMethod _result;
    HRESULT _hr = get_MethodType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnSamplingMethodFactory wrapper method implementations
//

IAgCrdnSamplingMethodPtr _IAgCrdnSamplingMethodFactory::CreateFixedStep ( double FixedStep ) {
    struct IAgCrdnSamplingMethod * _result = 0;
    HRESULT _hr = raw_CreateFixedStep(FixedStep, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSamplingMethodPtr(_result, false);
}

IAgCrdnSamplingMethodPtr _IAgCrdnSamplingMethodFactory::CreateCurvatureTolerance ( double CurvatureTolerance ) {
    struct IAgCrdnSamplingMethod * _result = 0;
    HRESULT _hr = raw_CreateCurvatureTolerance(CurvatureTolerance, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSamplingMethodPtr(_result, false);
}

IAgCrdnSamplingMethodPtr _IAgCrdnSamplingMethodFactory::CreateRelativeTolerance ( double RelativeTolerance ) {
    struct IAgCrdnSamplingMethod * _result = 0;
    HRESULT _hr = raw_CreateRelativeTolerance(RelativeTolerance, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSamplingMethodPtr(_result, false);
}

//
// interface _IAgCrdnSamplingRelativeTolerance wrapper method implementations
//

enum AgECrdnSamplingMethod _IAgCrdnSamplingRelativeTolerance::GetMethodType ( ) {
    enum AgECrdnSamplingMethod _result;
    HRESULT _hr = get_MethodType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

double _IAgCrdnSamplingRelativeTolerance::GetMinimumTimeStep ( ) {
    double _result = 0;
    HRESULT _hr = get_MinimumTimeStep(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnSamplingRelativeTolerance::PutMinimumTimeStep ( double pRetVal ) {
    HRESULT _hr = put_MinimumTimeStep(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnSamplingRelativeTolerance::GetMaximumTimeStep ( ) {
    double _result = 0;
    HRESULT _hr = get_MaximumTimeStep(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnSamplingRelativeTolerance::PutMaximumTimeStep ( double pRetVal ) {
    HRESULT _hr = put_MaximumTimeStep(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnSamplingRelativeTolerance::GetStepAtBoundaries ( ) {
    double _result = 0;
    HRESULT _hr = get_StepAtBoundaries(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnSamplingRelativeTolerance::PutStepAtBoundaries ( double pRetVal ) {
    HRESULT _hr = put_StepAtBoundaries(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnSamplingRelativeTolerance::GetRelativeTolerance ( ) {
    double _result = 0;
    HRESULT _hr = get_RelativeTolerance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnSamplingRelativeTolerance::PutRelativeTolerance ( double pRetVal ) {
    HRESULT _hr = put_RelativeTolerance(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnSamplingRelativeTolerance::GetAbsoluteTolerance ( ) {
    double _result = 0;
    HRESULT _hr = get_AbsoluteTolerance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnSamplingRelativeTolerance::PutAbsoluteTolerance ( double pRetVal ) {
    HRESULT _hr = put_AbsoluteTolerance(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnSatisfactionConditionFilter wrapper method implementations
//

enum AgECrdnPruneFilter _IAgCrdnSatisfactionConditionFilter::GetFilterType ( ) {
    enum AgECrdnPruneFilter _result;
    HRESULT _hr = get_FilterType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnConditionPtr _IAgCrdnSatisfactionConditionFilter::GetCondition ( ) {
    struct IAgCrdnCondition * _result = 0;
    HRESULT _hr = get_Condition(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConditionPtr(_result, false);
}

void _IAgCrdnSatisfactionConditionFilter::PutCondition ( struct IAgCrdnCondition * ppRetVal ) {
    HRESULT _hr = put_Condition(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnIntervalDurationKind _IAgCrdnSatisfactionConditionFilter::GetDurationKind ( ) {
    enum AgECrdnIntervalDurationKind _result;
    HRESULT _hr = get_DurationKind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnSatisfactionConditionFilter::PutDurationKind ( enum AgECrdnIntervalDurationKind pRetVal ) {
    HRESULT _hr = put_DurationKind(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnSatisfactionConditionFilter::GetIntervalDuration ( ) {
    double _result = 0;
    HRESULT _hr = get_IntervalDuration(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnSatisfactionConditionFilter::PutIntervalDuration ( double pRetVal ) {
    HRESULT _hr = put_IntervalDuration(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnVolumeFactory wrapper method implementations
//

IAgCrdnVolumePtr _IAgCrdnVolumeFactory::Create ( _bstr_t Name, _bstr_t Description, enum AgECrdnVolumeType Type ) {
    struct IAgCrdnVolume * _result = 0;
    HRESULT _hr = raw_Create(Name, Description, Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumePtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeFactory::IsTypeSupported ( enum AgECrdnVolumeType EType ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(EType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVolumePtr _IAgCrdnVolumeFactory::CreateVolumeCombined ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnVolume * _result = 0;
    HRESULT _hr = raw_CreateVolumeCombined(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumePtr(_result, false);
}

IAgCrdnVolumePtr _IAgCrdnVolumeFactory::CreateVolumeLighting ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnVolume * _result = 0;
    HRESULT _hr = raw_CreateVolumeLighting(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumePtr(_result, false);
}

IAgCrdnVolumePtr _IAgCrdnVolumeFactory::CreateVolumeOverTime ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnVolume * _result = 0;
    HRESULT _hr = raw_CreateVolumeOverTime(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumePtr(_result, false);
}

IAgCrdnVolumePtr _IAgCrdnVolumeFactory::CreateVolumeFromGrid ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnVolume * _result = 0;
    HRESULT _hr = raw_CreateVolumeFromGrid(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumePtr(_result, false);
}

IAgCrdnVolumePtr _IAgCrdnVolumeFactory::CreateVolumeFromCalc ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnVolume * _result = 0;
    HRESULT _hr = raw_CreateVolumeFromCalc(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumePtr(_result, false);
}

IAgCrdnVolumePtr _IAgCrdnVolumeFactory::CreateVolumeFromTimeSatisfaction ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnVolume * _result = 0;
    HRESULT _hr = raw_CreateVolumeFromTimeSatisfaction(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumePtr(_result, false);
}

IAgCrdnVolumePtr _IAgCrdnVolumeFactory::CreateVolumeFromCondition ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnVolume * _result = 0;
    HRESULT _hr = raw_CreateVolumeFromCondition(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumePtr(_result, false);
}

IAgCrdnVolumePtr _IAgCrdnVolumeFactory::CreateVolumeInview ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnVolume * _result = 0;
    HRESULT _hr = raw_CreateVolumeInview(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumePtr(_result, false);
}

//
// interface _IAgCrdnVolumeGridFactory wrapper method implementations
//

IAgCrdnVolumeGridPtr _IAgCrdnVolumeGridFactory::Create ( _bstr_t Name, _bstr_t Description, enum AgECrdnVolumeGridType Type ) {
    struct IAgCrdnVolumeGrid * _result = 0;
    HRESULT _hr = raw_Create(Name, Description, Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumeGridPtr(_result, false);
}

IAgCrdnVolumeGridPtr _IAgCrdnVolumeGridFactory::CreateVolumeGridCartesian ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnVolumeGrid * _result = 0;
    HRESULT _hr = raw_CreateVolumeGridCartesian(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumeGridPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeGridFactory::IsTypeSupported ( enum AgECrdnVolumeGridType EType ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(EType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVolumeGridPtr _IAgCrdnVolumeGridFactory::CreateVolumeGridCylindrical ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnVolumeGrid * _result = 0;
    HRESULT _hr = raw_CreateVolumeGridCylindrical(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumeGridPtr(_result, false);
}

IAgCrdnVolumeGridPtr _IAgCrdnVolumeGridFactory::CreateVolumeGridSpherical ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnVolumeGrid * _result = 0;
    HRESULT _hr = raw_CreateVolumeGridSpherical(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumeGridPtr(_result, false);
}

IAgCrdnVolumeGridPtr _IAgCrdnVolumeGridFactory::CreateVolumeGridConstrained ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnVolumeGrid * _result = 0;
    HRESULT _hr = raw_CreateVolumeGridConstrained(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumeGridPtr(_result, false);
}

IAgCrdnVolumeGridPtr _IAgCrdnVolumeGridFactory::CreateVolumeGridLatLonAlt ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnVolumeGrid * _result = 0;
    HRESULT _hr = raw_CreateVolumeGridLatLonAlt(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumeGridPtr(_result, false);
}

IAgCrdnVolumeGridPtr _IAgCrdnVolumeGridFactory::CreateVolumeGridBearingAlt ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnVolumeGrid * _result = 0;
    HRESULT _hr = raw_CreateVolumeGridBearingAlt(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumeGridPtr(_result, false);
}

//
// interface IAgCrdnGridValuesMethod wrapper method implementations
//

enum AgECrdnVolumetricGridValuesMethodType IAgCrdnGridValuesMethod::GetMethodType ( ) {
    enum AgECrdnVolumetricGridValuesMethodType _result;
    HRESULT _hr = get_MethodType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCrdnGridValuesFixedStep wrapper method implementations
//

double IAgCrdnGridValuesFixedStep::GetMin ( ) {
    double _result = 0;
    HRESULT _hr = get_Min(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnGridValuesFixedStep::PutMin ( double pRetVal ) {
    HRESULT _hr = put_Min(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnGridValuesFixedStep::GetMax ( ) {
    double _result = 0;
    HRESULT _hr = get_Max(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnGridValuesFixedStep::PutMax ( double pRetVal ) {
    HRESULT _hr = put_Max(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnGridValuesFixedStep::GetIncludeMinMax ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IncludeMinMax(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnGridValuesFixedStep::PutIncludeMinMax ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_IncludeMinMax(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnGridValuesFixedStep::GetReferenceValue ( ) {
    double _result = 0;
    HRESULT _hr = get_ReferenceValue(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnGridValuesFixedStep::PutReferenceValue ( double pRetVal ) {
    HRESULT _hr = put_ReferenceValue(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnGridValuesFixedStep::GetStep ( ) {
    double _result = 0;
    HRESULT _hr = get_Step(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnGridValuesFixedStep::PutStep ( double pRetVal ) {
    HRESULT _hr = put_Step(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnGridValuesFixedNumberOfSteps wrapper method implementations
//

double IAgCrdnGridValuesFixedNumberOfSteps::GetMin ( ) {
    double _result = 0;
    HRESULT _hr = get_Min(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnGridValuesFixedNumberOfSteps::PutMin ( double pRetVal ) {
    HRESULT _hr = put_Min(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnGridValuesFixedNumberOfSteps::GetMax ( ) {
    double _result = 0;
    HRESULT _hr = get_Max(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnGridValuesFixedNumberOfSteps::PutMax ( double pRetVal ) {
    HRESULT _hr = put_Max(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

int IAgCrdnGridValuesFixedNumberOfSteps::GetNumberOfSteps ( ) {
    int _result = 0;
    HRESULT _hr = get_NumberOfSteps(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnGridValuesFixedNumberOfSteps::PutNumberOfSteps ( int pRetVal ) {
    HRESULT _hr = put_NumberOfSteps(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnGridValuesCustom wrapper method implementations
//

SAFEARRAY * IAgCrdnGridValuesCustom::GetValues ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Values(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnGridValuesCustom::PutValues ( SAFEARRAY * ppRetVal ) {
    HRESULT _hr = put_Values(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnGridCoordinateDefinition wrapper method implementations
//

enum AgECrdnVolumetricGridValuesMethodType _IAgCrdnGridCoordinateDefinition::GetMethodType ( ) {
    enum AgECrdnVolumetricGridValuesMethodType _result;
    HRESULT _hr = get_MethodType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnGridValuesMethodPtr _IAgCrdnGridCoordinateDefinition::GetGridValuesMethod ( ) {
    struct IAgCrdnGridValuesMethod * _result = 0;
    HRESULT _hr = get_GridValuesMethod(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnGridValuesMethodPtr(_result, false);
}

IAgCrdnGridValuesFixedStepPtr _IAgCrdnGridCoordinateDefinition::SetGridValuesFixedStep ( double Min, double Max, VARIANT_BOOL IncludeMinMax, double RefValue, double FixedStep ) {
    struct IAgCrdnGridValuesFixedStep * _result = 0;
    HRESULT _hr = raw_SetGridValuesFixedStep(Min, Max, IncludeMinMax, RefValue, FixedStep, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnGridValuesFixedStepPtr(_result, false);
}

IAgCrdnGridValuesFixedNumberOfStepsPtr _IAgCrdnGridCoordinateDefinition::SetGridValuesFixedNumberOfSteps ( double Min, double Max, int NumSteps ) {
    struct IAgCrdnGridValuesFixedNumberOfSteps * _result = 0;
    HRESULT _hr = raw_SetGridValuesFixedNumberOfSteps(Min, Max, NumSteps, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnGridValuesFixedNumberOfStepsPtr(_result, false);
}

IAgCrdnGridValuesCustomPtr _IAgCrdnGridCoordinateDefinition::SetGridValuesCustom ( SAFEARRAY * * Values ) {
    struct IAgCrdnGridValuesCustom * _result = 0;
    HRESULT _hr = raw_SetGridValuesCustom(Values, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnGridValuesCustomPtr(_result, false);
}

//
// interface _IAgCrdnGridValuesCustom wrapper method implementations
//

enum AgECrdnVolumetricGridValuesMethodType _IAgCrdnGridValuesCustom::GetMethodType ( ) {
    enum AgECrdnVolumetricGridValuesMethodType _result;
    HRESULT _hr = get_MethodType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnGridValuesCustom::GetValues ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Values(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnGridValuesCustom::PutValues ( SAFEARRAY * ppRetVal ) {
    HRESULT _hr = put_Values(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnGridValuesFixedNumberOfSteps wrapper method implementations
//

enum AgECrdnVolumetricGridValuesMethodType _IAgCrdnGridValuesFixedNumberOfSteps::GetMethodType ( ) {
    enum AgECrdnVolumetricGridValuesMethodType _result;
    HRESULT _hr = get_MethodType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

double _IAgCrdnGridValuesFixedNumberOfSteps::GetMin ( ) {
    double _result = 0;
    HRESULT _hr = get_Min(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnGridValuesFixedNumberOfSteps::PutMin ( double pRetVal ) {
    HRESULT _hr = put_Min(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnGridValuesFixedNumberOfSteps::GetMax ( ) {
    double _result = 0;
    HRESULT _hr = get_Max(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnGridValuesFixedNumberOfSteps::PutMax ( double pRetVal ) {
    HRESULT _hr = put_Max(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

int _IAgCrdnGridValuesFixedNumberOfSteps::GetNumberOfSteps ( ) {
    int _result = 0;
    HRESULT _hr = get_NumberOfSteps(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnGridValuesFixedNumberOfSteps::PutNumberOfSteps ( int pRetVal ) {
    HRESULT _hr = put_NumberOfSteps(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnGridValuesFixedStep wrapper method implementations
//

enum AgECrdnVolumetricGridValuesMethodType _IAgCrdnGridValuesFixedStep::GetMethodType ( ) {
    enum AgECrdnVolumetricGridValuesMethodType _result;
    HRESULT _hr = get_MethodType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

double _IAgCrdnGridValuesFixedStep::GetMin ( ) {
    double _result = 0;
    HRESULT _hr = get_Min(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnGridValuesFixedStep::PutMin ( double pRetVal ) {
    HRESULT _hr = put_Min(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnGridValuesFixedStep::GetMax ( ) {
    double _result = 0;
    HRESULT _hr = get_Max(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnGridValuesFixedStep::PutMax ( double pRetVal ) {
    HRESULT _hr = put_Max(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnGridValuesFixedStep::GetIncludeMinMax ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IncludeMinMax(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnGridValuesFixedStep::PutIncludeMinMax ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_IncludeMinMax(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnGridValuesFixedStep::GetReferenceValue ( ) {
    double _result = 0;
    HRESULT _hr = get_ReferenceValue(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnGridValuesFixedStep::PutReferenceValue ( double pRetVal ) {
    HRESULT _hr = put_ReferenceValue(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnGridValuesFixedStep::GetStep ( ) {
    double _result = 0;
    HRESULT _hr = get_Step(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnGridValuesFixedStep::PutStep ( double pRetVal ) {
    HRESULT _hr = put_Step(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnGridValuesMethod wrapper method implementations
//

enum AgECrdnVolumetricGridValuesMethodType _IAgCrdnGridValuesMethod::GetMethodType ( ) {
    enum AgECrdnVolumetricGridValuesMethodType _result;
    HRESULT _hr = get_MethodType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnLightTimeDelay wrapper method implementations
//

VARIANT_BOOL _IAgCrdnLightTimeDelay::GetUseLightTimeDelay ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseLightTimeDelay(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnLightTimeDelay::PutUseLightTimeDelay ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseLightTimeDelay(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnLightTimeDelay::GetTimeDelayConvergence ( ) {
    double _result = 0;
    HRESULT _hr = get_TimeDelayConvergence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnLightTimeDelay::PutTimeDelayConvergence ( double pRetVal ) {
    HRESULT _hr = put_TimeDelayConvergence(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnVolumeAberrationType _IAgCrdnLightTimeDelay::GetAberrationType ( ) {
    enum AgECrdnVolumeAberrationType _result;
    HRESULT _hr = get_AberrationType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnLightTimeDelay::PutAberrationType ( enum AgECrdnVolumeAberrationType pRetVal ) {
    HRESULT _hr = put_AberrationType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnVolumeClockHostType _IAgCrdnLightTimeDelay::GetClockHost ( ) {
    enum AgECrdnVolumeClockHostType _result;
    HRESULT _hr = get_ClockHost(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnLightTimeDelay::PutClockHost ( enum AgECrdnVolumeClockHostType pRetVal ) {
    HRESULT _hr = put_ClockHost(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnVolumeTimeSenseType _IAgCrdnLightTimeDelay::GetTimeSense ( ) {
    enum AgECrdnVolumeTimeSenseType _result;
    HRESULT _hr = get_TimeSense(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnLightTimeDelay::PutTimeSense ( enum AgECrdnVolumeTimeSenseType pRetVal ) {
    HRESULT _hr = put_TimeSense(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnGridCoordinateDefinition wrapper method implementations
//

enum AgECrdnVolumetricGridValuesMethodType IAgCrdnGridCoordinateDefinition::GetMethodType ( ) {
    enum AgECrdnVolumetricGridValuesMethodType _result;
    HRESULT _hr = get_MethodType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnGridValuesMethodPtr IAgCrdnGridCoordinateDefinition::GetGridValuesMethod ( ) {
    struct IAgCrdnGridValuesMethod * _result = 0;
    HRESULT _hr = get_GridValuesMethod(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnGridValuesMethodPtr(_result, false);
}

IAgCrdnGridValuesFixedStepPtr IAgCrdnGridCoordinateDefinition::SetGridValuesFixedStep ( double Min, double Max, VARIANT_BOOL IncludeMinMax, double RefValue, double FixedStep ) {
    struct IAgCrdnGridValuesFixedStep * _result = 0;
    HRESULT _hr = raw_SetGridValuesFixedStep(Min, Max, IncludeMinMax, RefValue, FixedStep, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnGridValuesFixedStepPtr(_result, false);
}

IAgCrdnGridValuesFixedNumberOfStepsPtr IAgCrdnGridCoordinateDefinition::SetGridValuesFixedNumberOfSteps ( double Min, double Max, int NumSteps ) {
    struct IAgCrdnGridValuesFixedNumberOfSteps * _result = 0;
    HRESULT _hr = raw_SetGridValuesFixedNumberOfSteps(Min, Max, NumSteps, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnGridValuesFixedNumberOfStepsPtr(_result, false);
}

IAgCrdnGridValuesCustomPtr IAgCrdnGridCoordinateDefinition::SetGridValuesCustom ( SAFEARRAY * * Values ) {
    struct IAgCrdnGridValuesCustom * _result = 0;
    HRESULT _hr = raw_SetGridValuesCustom(Values, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnGridValuesCustomPtr(_result, false);
}

//
// interface _IAgCrdnVolumeGridResult wrapper method implementations
//

_variant_t _IAgCrdnVolumeGridResult::GetEpoch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Epoch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

int _IAgCrdnVolumeGridResult::GetSizeI ( ) {
    int _result = 0;
    HRESULT _hr = get_SizeI(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

int _IAgCrdnVolumeGridResult::GetSizeJ ( ) {
    int _result = 0;
    HRESULT _hr = get_SizeJ(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

int _IAgCrdnVolumeGridResult::GetSizeK ( ) {
    int _result = 0;
    HRESULT _hr = get_SizeK(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnVolumeGridResult::GetVolumeMetricDataVector ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_VolumeMetricDataVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnVolumeGridResult::GetVolumeMetricPositionVector ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_VolumeMetricPositionVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnVolumeGridResult::GetVolumeMetricNativePositionVector ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_VolumeMetricNativePositionVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnVolumeGridResult::GetVolumeMetricGradientVector ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_VolumeMetricGradientVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCrdnLightTimeDelay wrapper method implementations
//

VARIANT_BOOL IAgCrdnLightTimeDelay::GetUseLightTimeDelay ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseLightTimeDelay(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnLightTimeDelay::PutUseLightTimeDelay ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseLightTimeDelay(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnLightTimeDelay::GetTimeDelayConvergence ( ) {
    double _result = 0;
    HRESULT _hr = get_TimeDelayConvergence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnLightTimeDelay::PutTimeDelayConvergence ( double pRetVal ) {
    HRESULT _hr = put_TimeDelayConvergence(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnVolumeAberrationType IAgCrdnLightTimeDelay::GetAberrationType ( ) {
    enum AgECrdnVolumeAberrationType _result;
    HRESULT _hr = get_AberrationType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnLightTimeDelay::PutAberrationType ( enum AgECrdnVolumeAberrationType pRetVal ) {
    HRESULT _hr = put_AberrationType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnVolumeClockHostType IAgCrdnLightTimeDelay::GetClockHost ( ) {
    enum AgECrdnVolumeClockHostType _result;
    HRESULT _hr = get_ClockHost(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnLightTimeDelay::PutClockHost ( enum AgECrdnVolumeClockHostType pRetVal ) {
    HRESULT _hr = put_ClockHost(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnVolumeTimeSenseType IAgCrdnLightTimeDelay::GetTimeSense ( ) {
    enum AgECrdnVolumeTimeSenseType _result;
    HRESULT _hr = get_TimeSense(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnLightTimeDelay::PutTimeSense ( enum AgECrdnVolumeTimeSenseType pRetVal ) {
    HRESULT _hr = put_TimeSense(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnEventFactory wrapper method implementations
//

IAgCrdnEventPtr IAgCrdnEventFactory::GetToday ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_Today(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventPtr IAgCrdnEventFactory::GetTomorrow ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_Tomorrow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventPtr IAgCrdnEventFactory::Create ( _bstr_t Name, _bstr_t Description, enum AgECrdnEventType Type ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = raw_Create(Name, Description, Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventPtr IAgCrdnEventFactory::CreateEventEpoch ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = raw_CreateEventEpoch(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventPtr IAgCrdnEventFactory::CreateEventExtremum ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = raw_CreateEventExtremum(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventPtr IAgCrdnEventFactory::CreateEventStartStopTime ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = raw_CreateEventStartStopTime(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventPtr IAgCrdnEventFactory::CreateEventSignaled ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = raw_CreateEventSignaled(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventPtr IAgCrdnEventFactory::CreateEventTimeOffset ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = raw_CreateEventTimeOffset(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventSmartEpochPtr IAgCrdnEventFactory::CreateSmartEpochFromTime ( const _variant_t & Epoch ) {
    struct IAgCrdnEventSmartEpoch * _result = 0;
    HRESULT _hr = raw_CreateSmartEpochFromTime(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventSmartEpochPtr(_result, false);
}

IAgCrdnEventSmartEpochPtr IAgCrdnEventFactory::CreateSmartEpochFromEvent ( struct IAgCrdnEvent * RefEvent ) {
    struct IAgCrdnEventSmartEpoch * _result = 0;
    HRESULT _hr = raw_CreateSmartEpochFromEvent(RefEvent, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventSmartEpochPtr(_result, false);
}

VARIANT_BOOL IAgCrdnEventFactory::IsTypeSupported ( enum AgECrdnEventType EType ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(EType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCrdnEventGroup wrapper method implementations
//

HRESULT IAgCrdnEventGroup::Remove ( _bstr_t EventName ) {
    HRESULT _hr = raw_Remove(EventName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnContextPtr IAgCrdnEventGroup::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

VARIANT_BOOL IAgCrdnEventGroup::Contains ( _bstr_t Name ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Contains(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IAgCrdnEventGroup::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEventFactoryPtr IAgCrdnEventGroup::GetFactory ( ) {
    struct IAgCrdnEventFactory * _result = 0;
    HRESULT _hr = get_Factory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventFactoryPtr(_result, false);
}

IAgCrdnEventPtr IAgCrdnEventGroup::GetItem ( const _variant_t & IndexOrName ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IUnknownPtr IAgCrdnEventGroup::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface IAgCrdnEventIntervalFactory wrapper method implementations
//

IAgCrdnEventIntervalPtr IAgCrdnEventIntervalFactory::Create ( _bstr_t Name, _bstr_t Description, enum AgECrdnEventIntervalType Type ) {
    struct IAgCrdnEventInterval * _result = 0;
    HRESULT _hr = raw_Create(Name, Description, Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalPtr(_result, false);
}

IAgCrdnEventIntervalPtr IAgCrdnEventIntervalFactory::CreateEventIntervalFixed ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventInterval * _result = 0;
    HRESULT _hr = raw_CreateEventIntervalFixed(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalPtr(_result, false);
}

IAgCrdnEventIntervalPtr IAgCrdnEventIntervalFactory::CreateEventIntervalFixedDuration ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventInterval * _result = 0;
    HRESULT _hr = raw_CreateEventIntervalFixedDuration(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalPtr(_result, false);
}

IAgCrdnEventIntervalPtr IAgCrdnEventIntervalFactory::CreateEventIntervalBetweenTimeInstants ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventInterval * _result = 0;
    HRESULT _hr = raw_CreateEventIntervalBetweenTimeInstants(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalPtr(_result, false);
}

IAgCrdnEventIntervalPtr IAgCrdnEventIntervalFactory::CreateEventIntervalFromIntervalList ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventInterval * _result = 0;
    HRESULT _hr = raw_CreateEventIntervalFromIntervalList(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalPtr(_result, false);
}

IAgCrdnEventIntervalPtr IAgCrdnEventIntervalFactory::CreateEventIntervalScaled ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventInterval * _result = 0;
    HRESULT _hr = raw_CreateEventIntervalScaled(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalPtr(_result, false);
}

IAgCrdnEventIntervalPtr IAgCrdnEventIntervalFactory::CreateEventIntervalSignaled ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventInterval * _result = 0;
    HRESULT _hr = raw_CreateEventIntervalSignaled(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalPtr(_result, false);
}

IAgCrdnEventIntervalPtr IAgCrdnEventIntervalFactory::CreateEventIntervalTimeOffset ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventInterval * _result = 0;
    HRESULT _hr = raw_CreateEventIntervalTimeOffset(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalPtr(_result, false);
}

VARIANT_BOOL IAgCrdnEventIntervalFactory::IsTypeSupported ( enum AgECrdnEventIntervalType EType ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(EType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCrdnEventIntervalGroup wrapper method implementations
//

HRESULT IAgCrdnEventIntervalGroup::Remove ( _bstr_t EventIntervalName ) {
    HRESULT _hr = raw_Remove(EventIntervalName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnContextPtr IAgCrdnEventIntervalGroup::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

VARIANT_BOOL IAgCrdnEventIntervalGroup::Contains ( _bstr_t Name ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Contains(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IAgCrdnEventIntervalGroup::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEventIntervalFactoryPtr IAgCrdnEventIntervalGroup::GetFactory ( ) {
    struct IAgCrdnEventIntervalFactory * _result = 0;
    HRESULT _hr = get_Factory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalFactoryPtr(_result, false);
}

IAgCrdnEventIntervalPtr IAgCrdnEventIntervalGroup::GetItem ( const _variant_t & IndexOrName ) {
    struct IAgCrdnEventInterval * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalPtr(_result, false);
}

IUnknownPtr IAgCrdnEventIntervalGroup::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface IAgCrdnEventIntervalListFactory wrapper method implementations
//

IAgCrdnEventIntervalListPtr IAgCrdnEventIntervalListFactory::Create ( _bstr_t Name, _bstr_t Description, enum AgECrdnEventIntervalListType Type ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = raw_Create(Name, Description, Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

IAgCrdnEventIntervalListPtr IAgCrdnEventIntervalListFactory::CreateEventIntervalListFromFile ( _bstr_t Name, _bstr_t Description, _bstr_t Filepath ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = raw_CreateEventIntervalListFromFile(Name, Description, Filepath, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

IAgCrdnEventIntervalListPtr IAgCrdnEventIntervalListFactory::CreateEventIntervalListMerged ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = raw_CreateEventIntervalListMerged(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

IAgCrdnEventIntervalListPtr IAgCrdnEventIntervalListFactory::CreateEventIntervalListFiltered ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = raw_CreateEventIntervalListFiltered(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

IAgCrdnEventIntervalListPtr IAgCrdnEventIntervalListFactory::CreateEventIntervalListCondition ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = raw_CreateEventIntervalListCondition(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

IAgCrdnEventIntervalListPtr IAgCrdnEventIntervalListFactory::CreateEventIntervalListScaled ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = raw_CreateEventIntervalListScaled(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

IAgCrdnEventIntervalListPtr IAgCrdnEventIntervalListFactory::CreateEventIntervalListSignaled ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = raw_CreateEventIntervalListSignaled(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

IAgCrdnEventIntervalListPtr IAgCrdnEventIntervalListFactory::CreateEventIntervalListTimeOffset ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = raw_CreateEventIntervalListTimeOffset(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

VARIANT_BOOL IAgCrdnEventIntervalListFactory::IsTypeSupported ( enum AgECrdnEventIntervalListType EType ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(EType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEventIntervalListPtr IAgCrdnEventIntervalListFactory::CreateEventIntervalListFile ( _bstr_t Name, _bstr_t Description, _bstr_t Filepath ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = raw_CreateEventIntervalListFile(Name, Description, Filepath, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

IAgCrdnEventIntervalListPtr IAgCrdnEventIntervalListFactory::CreateEventIntervalListFixed ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = raw_CreateEventIntervalListFixed(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

//
// interface IAgCrdnEventIntervalListGroup wrapper method implementations
//

HRESULT IAgCrdnEventIntervalListGroup::Remove ( _bstr_t EventName ) {
    HRESULT _hr = raw_Remove(EventName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnContextPtr IAgCrdnEventIntervalListGroup::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

VARIANT_BOOL IAgCrdnEventIntervalListGroup::Contains ( _bstr_t Name ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Contains(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IAgCrdnEventIntervalListGroup::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEventIntervalListFactoryPtr IAgCrdnEventIntervalListGroup::GetFactory ( ) {
    struct IAgCrdnEventIntervalListFactory * _result = 0;
    HRESULT _hr = get_Factory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListFactoryPtr(_result, false);
}

IAgCrdnEventIntervalListPtr IAgCrdnEventIntervalListGroup::GetItem ( const _variant_t & IndexOrName ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

IUnknownPtr IAgCrdnEventIntervalListGroup::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface IAgCrdnEventArrayFactory wrapper method implementations
//

IAgCrdnEventArrayPtr IAgCrdnEventArrayFactory::Create ( _bstr_t Name, _bstr_t Description, enum AgECrdnEventArrayType Type ) {
    struct IAgCrdnEventArray * _result = 0;
    HRESULT _hr = raw_Create(Name, Description, Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventArrayPtr(_result, false);
}

IAgCrdnEventArrayPtr IAgCrdnEventArrayFactory::CreateEventArrayExtrema ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventArray * _result = 0;
    HRESULT _hr = raw_CreateEventArrayExtrema(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventArrayPtr(_result, false);
}

IAgCrdnEventArrayPtr IAgCrdnEventArrayFactory::CreateEventArrayStartStopTimes ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventArray * _result = 0;
    HRESULT _hr = raw_CreateEventArrayStartStopTimes(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventArrayPtr(_result, false);
}

IAgCrdnEventArrayPtr IAgCrdnEventArrayFactory::CreateEventArrayMerged ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventArray * _result = 0;
    HRESULT _hr = raw_CreateEventArrayMerged(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventArrayPtr(_result, false);
}

IAgCrdnEventArrayPtr IAgCrdnEventArrayFactory::CreateEventArrayFiltered ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventArray * _result = 0;
    HRESULT _hr = raw_CreateEventArrayFiltered(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventArrayPtr(_result, false);
}

IAgCrdnEventArrayPtr IAgCrdnEventArrayFactory::CreateEventArrayFixedStep ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventArray * _result = 0;
    HRESULT _hr = raw_CreateEventArrayFixedStep(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventArrayPtr(_result, false);
}

IAgCrdnEventArrayPtr IAgCrdnEventArrayFactory::CreateEventArrayConditionCrossings ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventArray * _result = 0;
    HRESULT _hr = raw_CreateEventArrayConditionCrossings(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventArrayPtr(_result, false);
}

IAgCrdnEventArrayPtr IAgCrdnEventArrayFactory::CreateEventArraySignaled ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventArray * _result = 0;
    HRESULT _hr = raw_CreateEventArraySignaled(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventArrayPtr(_result, false);
}

VARIANT_BOOL IAgCrdnEventArrayFactory::IsTypeSupported ( enum AgECrdnEventArrayType EType ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(EType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEventArrayPtr IAgCrdnEventArrayFactory::CreateEventArrayFixedTimes ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventArray * _result = 0;
    HRESULT _hr = raw_CreateEventArrayFixedTimes(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventArrayPtr(_result, false);
}

//
// interface IAgCrdnEventArrayGroup wrapper method implementations
//

HRESULT IAgCrdnEventArrayGroup::Remove ( _bstr_t EventName ) {
    HRESULT _hr = raw_Remove(EventName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnContextPtr IAgCrdnEventArrayGroup::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

VARIANT_BOOL IAgCrdnEventArrayGroup::Contains ( _bstr_t Name ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Contains(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IAgCrdnEventArrayGroup::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEventArrayFactoryPtr IAgCrdnEventArrayGroup::GetFactory ( ) {
    struct IAgCrdnEventArrayFactory * _result = 0;
    HRESULT _hr = get_Factory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventArrayFactoryPtr(_result, false);
}

IAgCrdnEventArrayPtr IAgCrdnEventArrayGroup::GetItem ( const _variant_t & IndexOrName ) {
    struct IAgCrdnEventArray * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventArrayPtr(_result, false);
}

IUnknownPtr IAgCrdnEventArrayGroup::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface IAgCrdnCalcScalarFactory wrapper method implementations
//

SAFEARRAY * IAgCrdnCalcScalarFactory::GetAvailableCalcScalarPluginDisplayNames ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_AvailableCalcScalarPluginDisplayNames(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCalcScalarPtr IAgCrdnCalcScalarFactory::Create ( _bstr_t Name, _bstr_t Description, enum AgECrdnCalcScalarType Type ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = raw_Create(Name, Description, Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

IAgCrdnCalcScalarPtr IAgCrdnCalcScalarFactory::CreateCalcScalarAngle ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = raw_CreateCalcScalarAngle(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

IAgCrdnCalcScalarPtr IAgCrdnCalcScalarFactory::CreateCalcScalarFixedAtTimeInstant ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = raw_CreateCalcScalarFixedAtTimeInstant(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

IAgCrdnCalcScalarPtr IAgCrdnCalcScalarFactory::CreateCalcScalarConstant ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = raw_CreateCalcScalarConstant(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

IAgCrdnCalcScalarPtr IAgCrdnCalcScalarFactory::CreateCalcScalarDataElement ( _bstr_t Name, _bstr_t Description, _bstr_t DataProvider, _bstr_t ElementName ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = raw_CreateCalcScalarDataElement(Name, Description, DataProvider, ElementName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

IAgCrdnCalcScalarPtr IAgCrdnCalcScalarFactory::CreateCalcScalarDataElementWithGroup ( _bstr_t Name, _bstr_t Description, _bstr_t DataProvider, _bstr_t GroupName, _bstr_t ElementName ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = raw_CreateCalcScalarDataElementWithGroup(Name, Description, DataProvider, GroupName, ElementName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

IAgCrdnCalcScalarPtr IAgCrdnCalcScalarFactory::CreateCalcScalarDerivative ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = raw_CreateCalcScalarDerivative(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

IAgCrdnCalcScalarPtr IAgCrdnCalcScalarFactory::CreateCalcScalarElapsedTime ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = raw_CreateCalcScalarElapsedTime(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

IAgCrdnCalcScalarPtr IAgCrdnCalcScalarFactory::CreateCalcScalarFile ( _bstr_t Name, _bstr_t Description, _bstr_t Filepath ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = raw_CreateCalcScalarFile(Name, Description, Filepath, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

IAgCrdnCalcScalarPtr IAgCrdnCalcScalarFactory::CreateCalcScalarFunction ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = raw_CreateCalcScalarFunction(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

IAgCrdnCalcScalarPtr IAgCrdnCalcScalarFactory::CreateCalcScalarIntegral ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = raw_CreateCalcScalarIntegral(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

IAgCrdnCalcScalarPtr IAgCrdnCalcScalarFactory::CreateCalcScalarFunction2Var ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = raw_CreateCalcScalarFunction2Var(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

IAgCrdnCalcScalarPtr IAgCrdnCalcScalarFactory::CreateCalcScalarVectorMagnitude ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = raw_CreateCalcScalarVectorMagnitude(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

IAgCrdnCalcScalarPtr IAgCrdnCalcScalarFactory::CreateCalcScalarPluginFromDisplayName ( _bstr_t Name, _bstr_t Description, _bstr_t DisplayName ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = raw_CreateCalcScalarPluginFromDisplayName(Name, Description, DisplayName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

VARIANT_BOOL IAgCrdnCalcScalarFactory::IsTypeSupported ( enum AgECrdnCalcScalarType EType ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(EType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCalcScalarPtr IAgCrdnCalcScalarFactory::CreateCalcScalarFromCustomScript ( _bstr_t Name, _bstr_t Description, _bstr_t Filepath ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = raw_CreateCalcScalarFromCustomScript(Name, Description, Filepath, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

IAgCrdnCalcScalarPtr IAgCrdnCalcScalarFactory::CreateCalcScalarSurfaceDistanceBetweenPoints ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = raw_CreateCalcScalarSurfaceDistanceBetweenPoints(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

//
// interface IAgCrdnCalcScalarGroup wrapper method implementations
//

HRESULT IAgCrdnCalcScalarGroup::Remove ( _bstr_t EventName ) {
    HRESULT _hr = raw_Remove(EventName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnContextPtr IAgCrdnCalcScalarGroup::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

VARIANT_BOOL IAgCrdnCalcScalarGroup::Contains ( _bstr_t Name ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Contains(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IAgCrdnCalcScalarGroup::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCalcScalarFactoryPtr IAgCrdnCalcScalarGroup::GetFactory ( ) {
    struct IAgCrdnCalcScalarFactory * _result = 0;
    HRESULT _hr = get_Factory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarFactoryPtr(_result, false);
}

IAgCrdnCalcScalarPtr IAgCrdnCalcScalarGroup::GetItem ( const _variant_t & IndexOrName ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

IUnknownPtr IAgCrdnCalcScalarGroup::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface IAgCrdnEventIntervalCollectionFactory wrapper method implementations
//

IAgCrdnEventIntervalCollectionPtr IAgCrdnEventIntervalCollectionFactory::Create ( _bstr_t Name, _bstr_t Description, enum AgECrdnEventIntervalCollectionType Type ) {
    struct IAgCrdnEventIntervalCollection * _result = 0;
    HRESULT _hr = raw_Create(Name, Description, Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalCollectionPtr(_result, false);
}

IAgCrdnEventIntervalCollectionPtr IAgCrdnEventIntervalCollectionFactory::CreateEventIntervalCollectionLighting ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventIntervalCollection * _result = 0;
    HRESULT _hr = raw_CreateEventIntervalCollectionLighting(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalCollectionPtr(_result, false);
}

IAgCrdnEventIntervalCollectionPtr IAgCrdnEventIntervalCollectionFactory::CreateEventIntervalCollectionSignaled ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventIntervalCollection * _result = 0;
    HRESULT _hr = raw_CreateEventIntervalCollectionSignaled(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalCollectionPtr(_result, false);
}

VARIANT_BOOL IAgCrdnEventIntervalCollectionFactory::IsTypeSupported ( enum AgECrdnEventIntervalCollectionType EType ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(EType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEventIntervalCollectionPtr IAgCrdnEventIntervalCollectionFactory::CreateEventIntervalCollectionSatisfaction ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnEventIntervalCollection * _result = 0;
    HRESULT _hr = raw_CreateEventIntervalCollectionSatisfaction(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalCollectionPtr(_result, false);
}

//
// interface IAgCrdnEventIntervalCollectionGroup wrapper method implementations
//

HRESULT IAgCrdnEventIntervalCollectionGroup::Remove ( _bstr_t EventName ) {
    HRESULT _hr = raw_Remove(EventName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnContextPtr IAgCrdnEventIntervalCollectionGroup::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

VARIANT_BOOL IAgCrdnEventIntervalCollectionGroup::Contains ( _bstr_t Name ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Contains(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IAgCrdnEventIntervalCollectionGroup::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEventIntervalCollectionFactoryPtr IAgCrdnEventIntervalCollectionGroup::GetFactory ( ) {
    struct IAgCrdnEventIntervalCollectionFactory * _result = 0;
    HRESULT _hr = get_Factory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalCollectionFactoryPtr(_result, false);
}

IAgCrdnEventIntervalCollectionPtr IAgCrdnEventIntervalCollectionGroup::GetItem ( const _variant_t & IndexOrName ) {
    struct IAgCrdnEventIntervalCollection * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalCollectionPtr(_result, false);
}

IUnknownPtr IAgCrdnEventIntervalCollectionGroup::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface IAgCrdnParameterSetFactory wrapper method implementations
//

IAgCrdnParameterSetPtr IAgCrdnParameterSetFactory::Create ( _bstr_t Name, _bstr_t Description, enum AgECrdnParameterSetType Type ) {
    struct IAgCrdnParameterSet * _result = 0;
    HRESULT _hr = raw_Create(Name, Description, Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnParameterSetPtr(_result, false);
}

IAgCrdnParameterSetPtr IAgCrdnParameterSetFactory::CreateParameterSetAttitude ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnParameterSet * _result = 0;
    HRESULT _hr = raw_CreateParameterSetAttitude(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnParameterSetPtr(_result, false);
}

IAgCrdnParameterSetPtr IAgCrdnParameterSetFactory::CreateParameterSetGroundTrajectory ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnParameterSet * _result = 0;
    HRESULT _hr = raw_CreateParameterSetGroundTrajectory(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnParameterSetPtr(_result, false);
}

IAgCrdnParameterSetPtr IAgCrdnParameterSetFactory::CreateParameterSetTrajectory ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnParameterSet * _result = 0;
    HRESULT _hr = raw_CreateParameterSetTrajectory(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnParameterSetPtr(_result, false);
}

IAgCrdnParameterSetPtr IAgCrdnParameterSetFactory::CreateParameterSetOrbit ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnParameterSet * _result = 0;
    HRESULT _hr = raw_CreateParameterSetOrbit(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnParameterSetPtr(_result, false);
}

IAgCrdnParameterSetPtr IAgCrdnParameterSetFactory::CreateParameterSetVector ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnParameterSet * _result = 0;
    HRESULT _hr = raw_CreateParameterSetVector(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnParameterSetPtr(_result, false);
}

VARIANT_BOOL IAgCrdnParameterSetFactory::IsTypeSupported ( enum AgECrdnParameterSetType EType ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(EType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCrdnParameterSetGroup wrapper method implementations
//

HRESULT IAgCrdnParameterSetGroup::Remove ( _bstr_t EventName ) {
    HRESULT _hr = raw_Remove(EventName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnContextPtr IAgCrdnParameterSetGroup::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

VARIANT_BOOL IAgCrdnParameterSetGroup::Contains ( _bstr_t Name ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Contains(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IAgCrdnParameterSetGroup::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnParameterSetFactoryPtr IAgCrdnParameterSetGroup::GetFactory ( ) {
    struct IAgCrdnParameterSetFactory * _result = 0;
    HRESULT _hr = get_Factory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnParameterSetFactoryPtr(_result, false);
}

IAgCrdnParameterSetPtr IAgCrdnParameterSetGroup::GetItem ( const _variant_t & IndexOrName ) {
    struct IAgCrdnParameterSet * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnParameterSetPtr(_result, false);
}

IUnknownPtr IAgCrdnParameterSetGroup::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface IAgCrdnConditionFactory wrapper method implementations
//

IAgCrdnConditionPtr IAgCrdnConditionFactory::Create ( _bstr_t Name, _bstr_t Description, enum AgECrdnConditionType Type ) {
    struct IAgCrdnCondition * _result = 0;
    HRESULT _hr = raw_Create(Name, Description, Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConditionPtr(_result, false);
}

IAgCrdnConditionPtr IAgCrdnConditionFactory::CreateConditionScalarBounds ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnCondition * _result = 0;
    HRESULT _hr = raw_CreateConditionScalarBounds(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConditionPtr(_result, false);
}

VARIANT_BOOL IAgCrdnConditionFactory::IsTypeSupported ( enum AgECrdnConditionType EType ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(EType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnConditionPtr IAgCrdnConditionFactory::CreateConditionCombined ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnCondition * _result = 0;
    HRESULT _hr = raw_CreateConditionCombined(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConditionPtr(_result, false);
}

//
// interface IAgCrdnConditionGroup wrapper method implementations
//

HRESULT IAgCrdnConditionGroup::Remove ( _bstr_t EventName ) {
    HRESULT _hr = raw_Remove(EventName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnContextPtr IAgCrdnConditionGroup::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

VARIANT_BOOL IAgCrdnConditionGroup::Contains ( _bstr_t Name ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Contains(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IAgCrdnConditionGroup::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnConditionFactoryPtr IAgCrdnConditionGroup::GetFactory ( ) {
    struct IAgCrdnConditionFactory * _result = 0;
    HRESULT _hr = get_Factory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConditionFactoryPtr(_result, false);
}

IAgCrdnConditionPtr IAgCrdnConditionGroup::GetItem ( const _variant_t & IndexOrName ) {
    struct IAgCrdnCondition * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConditionPtr(_result, false);
}

IUnknownPtr IAgCrdnConditionGroup::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface IAgCrdnConditionSetFactory wrapper method implementations
//

IAgCrdnConditionSetPtr IAgCrdnConditionSetFactory::Create ( _bstr_t Name, _bstr_t Description, enum AgECrdnConditionSetType Type ) {
    struct IAgCrdnConditionSet * _result = 0;
    HRESULT _hr = raw_Create(Name, Description, Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConditionSetPtr(_result, false);
}

IAgCrdnConditionSetPtr IAgCrdnConditionSetFactory::CreateScalarThresholds ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnConditionSet * _result = 0;
    HRESULT _hr = raw_CreateScalarThresholds(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConditionSetPtr(_result, false);
}

VARIANT_BOOL IAgCrdnConditionSetFactory::IsTypeSupported ( enum AgECrdnConditionSetType EType ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(EType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCrdnConditionSetGroup wrapper method implementations
//

HRESULT IAgCrdnConditionSetGroup::Remove ( _bstr_t EventName ) {
    HRESULT _hr = raw_Remove(EventName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnContextPtr IAgCrdnConditionSetGroup::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

VARIANT_BOOL IAgCrdnConditionSetGroup::Contains ( _bstr_t Name ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Contains(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IAgCrdnConditionSetGroup::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnConditionSetFactoryPtr IAgCrdnConditionSetGroup::GetFactory ( ) {
    struct IAgCrdnConditionSetFactory * _result = 0;
    HRESULT _hr = get_Factory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConditionSetFactoryPtr(_result, false);
}

IAgCrdnConditionSetPtr IAgCrdnConditionSetGroup::GetItem ( const _variant_t & IndexOrName ) {
    struct IAgCrdnConditionSet * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConditionSetPtr(_result, false);
}

IUnknownPtr IAgCrdnConditionSetGroup::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface IAgCrdnVolumeGridFactory wrapper method implementations
//

IAgCrdnVolumeGridPtr IAgCrdnVolumeGridFactory::Create ( _bstr_t Name, _bstr_t Description, enum AgECrdnVolumeGridType Type ) {
    struct IAgCrdnVolumeGrid * _result = 0;
    HRESULT _hr = raw_Create(Name, Description, Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumeGridPtr(_result, false);
}

IAgCrdnVolumeGridPtr IAgCrdnVolumeGridFactory::CreateVolumeGridCartesian ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnVolumeGrid * _result = 0;
    HRESULT _hr = raw_CreateVolumeGridCartesian(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumeGridPtr(_result, false);
}

VARIANT_BOOL IAgCrdnVolumeGridFactory::IsTypeSupported ( enum AgECrdnVolumeGridType EType ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(EType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVolumeGridPtr IAgCrdnVolumeGridFactory::CreateVolumeGridCylindrical ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnVolumeGrid * _result = 0;
    HRESULT _hr = raw_CreateVolumeGridCylindrical(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumeGridPtr(_result, false);
}

IAgCrdnVolumeGridPtr IAgCrdnVolumeGridFactory::CreateVolumeGridSpherical ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnVolumeGrid * _result = 0;
    HRESULT _hr = raw_CreateVolumeGridSpherical(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumeGridPtr(_result, false);
}

IAgCrdnVolumeGridPtr IAgCrdnVolumeGridFactory::CreateVolumeGridConstrained ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnVolumeGrid * _result = 0;
    HRESULT _hr = raw_CreateVolumeGridConstrained(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumeGridPtr(_result, false);
}

IAgCrdnVolumeGridPtr IAgCrdnVolumeGridFactory::CreateVolumeGridLatLonAlt ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnVolumeGrid * _result = 0;
    HRESULT _hr = raw_CreateVolumeGridLatLonAlt(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumeGridPtr(_result, false);
}

IAgCrdnVolumeGridPtr IAgCrdnVolumeGridFactory::CreateVolumeGridBearingAlt ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnVolumeGrid * _result = 0;
    HRESULT _hr = raw_CreateVolumeGridBearingAlt(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumeGridPtr(_result, false);
}

//
// interface IAgCrdnVolumeGridGroup wrapper method implementations
//

HRESULT IAgCrdnVolumeGridGroup::Remove ( _bstr_t EventName ) {
    HRESULT _hr = raw_Remove(EventName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnContextPtr IAgCrdnVolumeGridGroup::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

VARIANT_BOOL IAgCrdnVolumeGridGroup::Contains ( _bstr_t Name ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Contains(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IAgCrdnVolumeGridGroup::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVolumeGridFactoryPtr IAgCrdnVolumeGridGroup::GetFactory ( ) {
    struct IAgCrdnVolumeGridFactory * _result = 0;
    HRESULT _hr = get_Factory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumeGridFactoryPtr(_result, false);
}

IAgCrdnVolumeGridPtr IAgCrdnVolumeGridGroup::GetItem ( const _variant_t & IndexOrName ) {
    struct IAgCrdnVolumeGrid * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumeGridPtr(_result, false);
}

IUnknownPtr IAgCrdnVolumeGridGroup::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface IAgCrdnVolumeFactory wrapper method implementations
//

IAgCrdnVolumePtr IAgCrdnVolumeFactory::Create ( _bstr_t Name, _bstr_t Description, enum AgECrdnVolumeType Type ) {
    struct IAgCrdnVolume * _result = 0;
    HRESULT _hr = raw_Create(Name, Description, Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumePtr(_result, false);
}

VARIANT_BOOL IAgCrdnVolumeFactory::IsTypeSupported ( enum AgECrdnVolumeType EType ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(EType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVolumePtr IAgCrdnVolumeFactory::CreateVolumeCombined ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnVolume * _result = 0;
    HRESULT _hr = raw_CreateVolumeCombined(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumePtr(_result, false);
}

IAgCrdnVolumePtr IAgCrdnVolumeFactory::CreateVolumeLighting ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnVolume * _result = 0;
    HRESULT _hr = raw_CreateVolumeLighting(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumePtr(_result, false);
}

IAgCrdnVolumePtr IAgCrdnVolumeFactory::CreateVolumeOverTime ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnVolume * _result = 0;
    HRESULT _hr = raw_CreateVolumeOverTime(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumePtr(_result, false);
}

IAgCrdnVolumePtr IAgCrdnVolumeFactory::CreateVolumeFromGrid ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnVolume * _result = 0;
    HRESULT _hr = raw_CreateVolumeFromGrid(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumePtr(_result, false);
}

IAgCrdnVolumePtr IAgCrdnVolumeFactory::CreateVolumeFromCalc ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnVolume * _result = 0;
    HRESULT _hr = raw_CreateVolumeFromCalc(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumePtr(_result, false);
}

IAgCrdnVolumePtr IAgCrdnVolumeFactory::CreateVolumeFromTimeSatisfaction ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnVolume * _result = 0;
    HRESULT _hr = raw_CreateVolumeFromTimeSatisfaction(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumePtr(_result, false);
}

IAgCrdnVolumePtr IAgCrdnVolumeFactory::CreateVolumeFromCondition ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnVolume * _result = 0;
    HRESULT _hr = raw_CreateVolumeFromCondition(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumePtr(_result, false);
}

IAgCrdnVolumePtr IAgCrdnVolumeFactory::CreateVolumeInview ( _bstr_t Name, _bstr_t Description ) {
    struct IAgCrdnVolume * _result = 0;
    HRESULT _hr = raw_CreateVolumeInview(Name, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumePtr(_result, false);
}

//
// interface IAgCrdnVolumeGroup wrapper method implementations
//

HRESULT IAgCrdnVolumeGroup::Remove ( _bstr_t EventName ) {
    HRESULT _hr = raw_Remove(EventName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnContextPtr IAgCrdnVolumeGroup::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

VARIANT_BOOL IAgCrdnVolumeGroup::Contains ( _bstr_t Name ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Contains(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IAgCrdnVolumeGroup::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVolumeFactoryPtr IAgCrdnVolumeGroup::GetFactory ( ) {
    struct IAgCrdnVolumeFactory * _result = 0;
    HRESULT _hr = get_Factory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumeFactoryPtr(_result, false);
}

IAgCrdnVolumePtr IAgCrdnVolumeGroup::GetItem ( const _variant_t & IndexOrName ) {
    struct IAgCrdnVolume * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumePtr(_result, false);
}

IUnknownPtr IAgCrdnVolumeGroup::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface IAgCrdnCalcScalarConstant wrapper method implementations
//

double IAgCrdnCalcScalarConstant::GetValue ( ) {
    double _result = 0;
    HRESULT _hr = get_Value(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnCalcScalarConstant::PutValue ( double pRetVal ) {
    HRESULT _hr = put_Value(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IAgCrdnCalcScalarConstant::GetDimension ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Dimension(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnCalcScalarConstant::PutDimension ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Dimension(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnCalcScalarCustom wrapper method implementations
//

_bstr_t IAgCrdnCalcScalarCustom::GetFilename ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Filename(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnCalcScalarCustom::PutFilename ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Filename(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgCrdnCalcScalarCustom::Reload ( ) {
    HRESULT _hr = raw_Reload();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IAgCrdnCalcScalarDataElement wrapper method implementations
//

_bstr_t IAgCrdnCalcScalarDataElement::GetDataProvider ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DataProvider(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t IAgCrdnCalcScalarDataElement::GetElementName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ElementName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t IAgCrdnCalcScalarDataElement::GetGroup ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Group(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

IAgCrdnInterpPtr IAgCrdnCalcScalarDataElement::GetInterpolation ( ) {
    struct IAgCrdnInterp * _result = 0;
    HRESULT _hr = get_Interpolation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnInterpPtr(_result, false);
}

void IAgCrdnCalcScalarDataElement::PutInterpolation ( struct IAgCrdnInterp * ppRetVal ) {
    HRESULT _hr = put_Interpolation(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSamplingPtr IAgCrdnCalcScalarDataElement::GetSampling ( ) {
    struct IAgCrdnSampling * _result = 0;
    HRESULT _hr = get_Sampling(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSamplingPtr(_result, false);
}

void IAgCrdnCalcScalarDataElement::PutSampling ( struct IAgCrdnSampling * ppRetVal ) {
    HRESULT _hr = put_Sampling(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnCalcScalarDataElement::GetUseSamples ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseSamples(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnCalcScalarDataElement::PutUseSamples ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseSamples(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSaveDataOption IAgCrdnCalcScalarDataElement::GetSaveDataOption ( ) {
    enum AgECrdnSaveDataOption _result;
    HRESULT _hr = get_SaveDataOption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnCalcScalarDataElement::PutSaveDataOption ( enum AgECrdnSaveDataOption pRetVal ) {
    HRESULT _hr = put_SaveDataOption(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgCrdnCalcScalarDataElement::Set ( _bstr_t DataProvider, _bstr_t ElementName ) {
    HRESULT _hr = raw_Set(DataProvider, ElementName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgCrdnCalcScalarDataElement::SetWithGroup ( _bstr_t DataProvider, _bstr_t TypeName, _bstr_t ElementName ) {
    HRESULT _hr = raw_SetWithGroup(DataProvider, TypeName, ElementName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

double IAgCrdnCalcScalarDataElement::GetInvalidDataIndicator ( ) {
    double _result = 0;
    HRESULT _hr = get_InvalidDataIndicator(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnCalcScalarDataElement::PutInvalidDataIndicator ( double pRetVal ) {
    HRESULT _hr = put_InvalidDataIndicator(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnCalcScalarDerivative wrapper method implementations
//

IAgCrdnCalcScalarPtr IAgCrdnCalcScalarDerivative::GetScalar ( ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = get_Scalar(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

void IAgCrdnCalcScalarDerivative::PutScalar ( struct IAgCrdnCalcScalar * ppRetVal ) {
    HRESULT _hr = put_Scalar(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnCalcScalarDerivative::GetDifferencingTimeStep ( ) {
    double _result = 0;
    HRESULT _hr = get_DifferencingTimeStep(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnCalcScalarDerivative::PutDifferencingTimeStep ( double pRetVal ) {
    HRESULT _hr = put_DifferencingTimeStep(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnCalcScalarElapsedTime wrapper method implementations
//

IAgCrdnEventPtr IAgCrdnCalcScalarElapsedTime::GetReferenceTimeInstant ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_ReferenceTimeInstant(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

void IAgCrdnCalcScalarElapsedTime::PutReferenceTimeInstant ( struct IAgCrdnEvent * ppRetVal ) {
    HRESULT _hr = put_ReferenceTimeInstant(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnCalcScalarFile wrapper method implementations
//

_bstr_t IAgCrdnCalcScalarFile::GetFilename ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Filename(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnCalcScalarFile::PutFilename ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Filename(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgCrdnCalcScalarFile::Reload ( ) {
    HRESULT _hr = raw_Reload();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnEventIntervalResultPtr IAgCrdnCalcScalarFile::GetFileSpan ( ) {
    struct IAgCrdnEventIntervalResult * _result = 0;
    HRESULT _hr = raw_GetFileSpan(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalResultPtr(_result, false);
}

enum AgECrdnFileInterpolatorType IAgCrdnCalcScalarFile::GetFileInterpolationType ( ) {
    enum AgECrdnFileInterpolatorType _result;
    HRESULT _hr = get_FileInterpolationType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnCalcScalarFile::PutFileInterpolationType ( enum AgECrdnFileInterpolatorType pRetVal ) {
    HRESULT _hr = put_FileInterpolationType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

int IAgCrdnCalcScalarFile::GetFileInterpolationOrder ( ) {
    int _result = 0;
    HRESULT _hr = get_FileInterpolationOrder(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnCalcScalarFile::PutFileInterpolationOrder ( int pRetVal ) {
    HRESULT _hr = put_FileInterpolationOrder(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnCalcScalarFile::GetUseNativeFileInterpolationSettings ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseNativeFileInterpolationSettings(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnCalcScalarFile::PutUseNativeFileInterpolationSettings ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseNativeFileInterpolationSettings(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnCalcScalarFixedAtTimeInstant wrapper method implementations
//

IAgCrdnCalcScalarPtr IAgCrdnCalcScalarFixedAtTimeInstant::GetInputScalar ( ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = get_InputScalar(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

void IAgCrdnCalcScalarFixedAtTimeInstant::PutInputScalar ( struct IAgCrdnCalcScalar * ppRetVal ) {
    HRESULT _hr = put_InputScalar(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnEventPtr IAgCrdnCalcScalarFixedAtTimeInstant::GetReferenceTimeInstant ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_ReferenceTimeInstant(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

void IAgCrdnCalcScalarFixedAtTimeInstant::PutReferenceTimeInstant ( struct IAgCrdnEvent * ppRetVal ) {
    HRESULT _hr = put_ReferenceTimeInstant(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnCalcScalarFunction wrapper method implementations
//

VARIANT_BOOL IAgCrdnCalcScalarFunction::GetUseScalar ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseScalar(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnCalcScalarFunction::PutUseScalar ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseScalar(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnCalcScalarPtr IAgCrdnCalcScalarFunction::GetInputScalar ( ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = get_InputScalar(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

void IAgCrdnCalcScalarFunction::PutInputScalar ( struct IAgCrdnCalcScalar * ppRetVal ) {
    HRESULT _hr = put_InputScalar(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnEventPtr IAgCrdnCalcScalarFunction::GetInputTime ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_InputTime(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

void IAgCrdnCalcScalarFunction::PutInputTime ( struct IAgCrdnEvent * ppRetVal ) {
    HRESULT _hr = put_InputTime(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnCalcScalarFunction::GetA ( ) {
    double _result = 0;
    HRESULT _hr = get_A(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnCalcScalarFunction::PutA ( double pRetVal ) {
    HRESULT _hr = put_A(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnCalcScalarFunction::GetB ( ) {
    double _result = 0;
    HRESULT _hr = get_B(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnCalcScalarFunction::PutB ( double pRetVal ) {
    HRESULT _hr = put_B(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnCalcScalarFunction::GetC ( ) {
    double _result = 0;
    HRESULT _hr = get_C(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnCalcScalarFunction::PutC ( double pRetVal ) {
    HRESULT _hr = put_C(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnCalcScalarFunction::GetD ( ) {
    double _result = 0;
    HRESULT _hr = get_D(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnCalcScalarFunction::PutD ( double pRetVal ) {
    HRESULT _hr = put_D(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

SAFEARRAY * IAgCrdnCalcScalarFunction::GetCoefficients ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Coefficients(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnCalcScalarFunction::PutCoefficients ( SAFEARRAY * ppRetVal ) {
    HRESULT _hr = put_Coefficients(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IAgCrdnCalcScalarFunction::GetSelectedFunction ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_SelectedFunction(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnCalcScalarFunction::PutSelectedFunction ( _bstr_t pRetVal ) {
    HRESULT _hr = put_SelectedFunction(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

SAFEARRAY * IAgCrdnCalcScalarFunction::GetAvailableFunctions ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_AvailableFunctions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IAgCrdnCalcScalarFunction::GetInheritDimensionFromInput ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_InheritDimensionFromInput(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnCalcScalarFunction::PutInheritDimensionFromInput ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_InheritDimensionFromInput(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IAgCrdnCalcScalarFunction::GetOutputDimension ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_OutputDimension(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnCalcScalarFunction::PutOutputDimension ( _bstr_t pRetVal ) {
    HRESULT _hr = put_OutputDimension(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IAgCrdnCalcScalarFunction::GetOutputUnit ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_OutputUnit(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnCalcScalarFunction::PutOutputUnit ( _bstr_t pRetVal ) {
    HRESULT _hr = put_OutputUnit(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSamplingPtr IAgCrdnCalcScalarFunction::GetSampling ( ) {
    struct IAgCrdnSampling * _result = 0;
    HRESULT _hr = get_Sampling(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSamplingPtr(_result, false);
}

void IAgCrdnCalcScalarFunction::PutSampling ( struct IAgCrdnSampling * ppRetVal ) {
    HRESULT _hr = put_Sampling(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnConvergePtr IAgCrdnCalcScalarFunction::GetConvergence ( ) {
    struct IAgCrdnConverge * _result = 0;
    HRESULT _hr = get_Convergence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConvergePtr(_result, false);
}

void IAgCrdnCalcScalarFunction::PutConvergence ( struct IAgCrdnConverge * ppRetVal ) {
    HRESULT _hr = put_Convergence(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnCalcScalarFunction2Var wrapper method implementations
//

IAgCrdnCalcScalarPtr IAgCrdnCalcScalarFunction2Var::GetX ( ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = get_X(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

void IAgCrdnCalcScalarFunction2Var::PutX ( struct IAgCrdnCalcScalar * ppRetVal ) {
    HRESULT _hr = put_X(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IAgCrdnCalcScalarFunction2Var::GetUnitX ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_UnitX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnCalcScalarFunction2Var::PutUnitX ( _bstr_t pRetVal ) {
    HRESULT _hr = put_UnitX(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnCalcScalarFunction2Var::GetA ( ) {
    double _result = 0;
    HRESULT _hr = get_A(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnCalcScalarFunction2Var::PutA ( double pRetVal ) {
    HRESULT _hr = put_A(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnCalcScalarPtr IAgCrdnCalcScalarFunction2Var::GetY ( ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = get_Y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

void IAgCrdnCalcScalarFunction2Var::PutY ( struct IAgCrdnCalcScalar * ppRetVal ) {
    HRESULT _hr = put_Y(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IAgCrdnCalcScalarFunction2Var::GetUnitY ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_UnitY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnCalcScalarFunction2Var::PutUnitY ( _bstr_t pRetVal ) {
    HRESULT _hr = put_UnitY(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnCalcScalarFunction2Var::GetB ( ) {
    double _result = 0;
    HRESULT _hr = get_B(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnCalcScalarFunction2Var::PutB ( double pRetVal ) {
    HRESULT _hr = put_B(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnCalcScalarFunction2Var::GetC ( ) {
    double _result = 0;
    HRESULT _hr = get_C(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnCalcScalarFunction2Var::PutC ( double pRetVal ) {
    HRESULT _hr = put_C(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnDimensionInheritance IAgCrdnCalcScalarFunction2Var::GetOutputDimensionInheritance ( ) {
    enum AgECrdnDimensionInheritance _result;
    HRESULT _hr = get_OutputDimensionInheritance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnCalcScalarFunction2Var::PutOutputDimensionInheritance ( enum AgECrdnDimensionInheritance pRetVal ) {
    HRESULT _hr = put_OutputDimensionInheritance(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IAgCrdnCalcScalarFunction2Var::GetOutputDimension ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_OutputDimension(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnCalcScalarFunction2Var::PutOutputDimension ( _bstr_t pRetVal ) {
    HRESULT _hr = put_OutputDimension(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

SAFEARRAY * IAgCrdnCalcScalarFunction2Var::GetAvailableFunctions ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_AvailableFunctions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t IAgCrdnCalcScalarFunction2Var::GetSelectedFunction ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_SelectedFunction(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnCalcScalarFunction2Var::PutSelectedFunction ( _bstr_t pRetVal ) {
    HRESULT _hr = put_SelectedFunction(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IAgCrdnCalcScalarFunction2Var::GetOutputUnit ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_OutputUnit(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnCalcScalarFunction2Var::PutOutputUnit ( _bstr_t pRetVal ) {
    HRESULT _hr = put_OutputUnit(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnCalcScalarIntegral wrapper method implementations
//

IAgCrdnCalcScalarPtr IAgCrdnCalcScalarIntegral::GetInputScalar ( ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = get_InputScalar(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

void IAgCrdnCalcScalarIntegral::PutInputScalar ( struct IAgCrdnCalcScalar * ppRetVal ) {
    HRESULT _hr = put_InputScalar(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnCalcScalarIntegral::GetComputeAsAverage ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ComputeAsAverage(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnCalcScalarIntegral::PutComputeAsAverage ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_ComputeAsAverage(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnIntegrationWindowType IAgCrdnCalcScalarIntegral::GetIntegrationWindowType ( ) {
    enum AgECrdnIntegrationWindowType _result;
    HRESULT _hr = get_IntegrationWindowType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnCalcScalarIntegral::PutIntegrationWindowType ( enum AgECrdnIntegrationWindowType pRetVal ) {
    HRESULT _hr = put_IntegrationWindowType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnCalcScalarIntegral::GetStartOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_StartOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnCalcScalarIntegral::PutStartOffset ( double pRetVal ) {
    HRESULT _hr = put_StartOffset(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnCalcScalarIntegral::GetStopOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_StopOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnCalcScalarIntegral::PutStopOffset ( double pRetVal ) {
    HRESULT _hr = put_StopOffset(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnCalcScalarIntegral::GetUseCustomTimeLimits ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseCustomTimeLimits(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnCalcScalarIntegral::PutUseCustomTimeLimits ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseCustomTimeLimits(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnEventIntervalListPtr IAgCrdnCalcScalarIntegral::GetCustomTimeLimits ( ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = get_CustomTimeLimits(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

void IAgCrdnCalcScalarIntegral::PutCustomTimeLimits ( struct IAgCrdnEventIntervalList * ppRetVal ) {
    HRESULT _hr = put_CustomTimeLimits(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSaveDataOption IAgCrdnCalcScalarIntegral::GetSaveDataOption ( ) {
    enum AgECrdnSaveDataOption _result;
    HRESULT _hr = get_SaveDataOption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnCalcScalarIntegral::PutSaveDataOption ( enum AgECrdnSaveDataOption pRetVal ) {
    HRESULT _hr = put_SaveDataOption(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnInterpPtr IAgCrdnCalcScalarIntegral::GetInterpolation ( ) {
    struct IAgCrdnInterp * _result = 0;
    HRESULT _hr = get_Interpolation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnInterpPtr(_result, false);
}

void IAgCrdnCalcScalarIntegral::PutInterpolation ( struct IAgCrdnInterp * ppRetVal ) {
    HRESULT _hr = put_Interpolation(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSamplingPtr IAgCrdnCalcScalarIntegral::GetSampling ( ) {
    struct IAgCrdnSampling * _result = 0;
    HRESULT _hr = get_Sampling(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSamplingPtr(_result, false);
}

void IAgCrdnCalcScalarIntegral::PutSampling ( struct IAgCrdnSampling * ppRetVal ) {
    HRESULT _hr = put_Sampling(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnIntegralPtr IAgCrdnCalcScalarIntegral::GetIntegral ( ) {
    struct IAgCrdnIntegral * _result = 0;
    HRESULT _hr = get_Integral(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntegralPtr(_result, false);
}

void IAgCrdnCalcScalarIntegral::PutIntegral ( struct IAgCrdnIntegral * ppRetVal ) {
    HRESULT _hr = put_Integral(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnCalcScalarIntegral::GetKeepConstantOutsideTimeLimits ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_KeepConstantOutsideTimeLimits(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnCalcScalarIntegral::PutKeepConstantOutsideTimeLimits ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_KeepConstantOutsideTimeLimits(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgCrdnCalcScalarIntegral::SetOffsets ( double StartOffset, double StopOffset ) {
    HRESULT _hr = raw_SetOffsets(StartOffset, StopOffset);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IAgCrdnCalcScalarPlugin wrapper method implementations
//

_bstr_t IAgCrdnCalcScalarPlugin::GetProgID ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ProgID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t IAgCrdnCalcScalarPlugin::GetDisplayName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DisplayName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

SAFEARRAY * IAgCrdnCalcScalarPlugin::GetAvailableProperties ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_AvailableProperties(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IAgCrdnCalcScalarPlugin::Reset ( ) {
    HRESULT _hr = raw_Reset();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgCrdnCalcScalarPlugin::SetProperty ( _bstr_t Name, _bstr_t Value ) {
    HRESULT _hr = raw_SetProperty(Name, Value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t IAgCrdnCalcScalarPlugin::GetProperty ( _bstr_t Name ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetProperty(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface IAgCrdnCalcScalarSurfaceDistanceBetweenPoints wrapper method implementations
//

IAgCrdnPointPtr IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::GetPoint1 ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = get_Point1(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

void IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::PutPoint1 ( struct IAgCrdnPoint * ppRetVal ) {
    HRESULT _hr = put_Point1(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPointPtr IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::GetPoint2 ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = get_Point2(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

void IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::PutPoint2 ( struct IAgCrdnPoint * ppRetVal ) {
    HRESULT _hr = put_Point2(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::GetSurfaceCentralBody ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_SurfaceCentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::PutSurfaceCentralBody ( _bstr_t pRetVal ) {
    HRESULT _hr = put_SurfaceCentralBody(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::GetDifferencingTimeStep ( ) {
    double _result = 0;
    HRESULT _hr = get_DifferencingTimeStep(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::PutDifferencingTimeStep ( double pRetVal ) {
    HRESULT _hr = put_DifferencingTimeStep(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnConditionCombined wrapper method implementations
//

enum AgECrdnConditionCombinedOperationType IAgCrdnConditionCombined::GetCombineOperation ( ) {
    enum AgECrdnConditionCombinedOperationType _result;
    HRESULT _hr = get_CombineOperation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnConditionCombined::PutCombineOperation ( enum AgECrdnConditionCombinedOperationType pRetVal ) {
    HRESULT _hr = put_CombineOperation(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

int IAgCrdnConditionCombined::GetConditionCount ( ) {
    int _result = 0;
    HRESULT _hr = get_ConditionCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgCrdnConditionCombined::GetAllConditions ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetAllConditions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IAgCrdnConditionCombined::SetAllConditions ( SAFEARRAY * * Conditions ) {
    HRESULT _hr = raw_SetAllConditions(Conditions);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnConditionPtr IAgCrdnConditionCombined::GetCondition ( int Pos ) {
    struct IAgCrdnCondition * _result = 0;
    HRESULT _hr = raw_GetCondition(Pos, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConditionPtr(_result, false);
}

HRESULT IAgCrdnConditionCombined::SetCondition ( struct IAgCrdnCondition * Ref, int Pos ) {
    HRESULT _hr = raw_SetCondition(Ref, Pos);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgCrdnConditionCombined::RemoveCondition ( int Pos ) {
    HRESULT _hr = raw_RemoveCondition(Pos);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgCrdnConditionCombined::AddCondition ( struct IAgCrdnCondition * Ref ) {
    HRESULT _hr = raw_AddCondition(Ref);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IAgCrdnConditionScalarBounds wrapper method implementations
//

IAgCrdnCalcScalarPtr IAgCrdnConditionScalarBounds::GetScalar ( ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = get_Scalar(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

void IAgCrdnConditionScalarBounds::PutScalar ( struct IAgCrdnCalcScalar * ppRetVal ) {
    HRESULT _hr = put_Scalar(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnConditionThresholdOption IAgCrdnConditionScalarBounds::GetOperation ( ) {
    enum AgECrdnConditionThresholdOption _result;
    HRESULT _hr = get_Operation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnConditionScalarBounds::PutOperation ( enum AgECrdnConditionThresholdOption pRetVal ) {
    HRESULT _hr = put_Operation(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

STKUtil::IAgQuantityPtr IAgCrdnConditionScalarBounds::GetMinimum ( ) {
    struct STKUtil::IAgQuantity * _result = 0;
    HRESULT _hr = raw_GetMinimum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgQuantityPtr(_result, false);
}

HRESULT IAgCrdnConditionScalarBounds::SetMinimum ( struct STKUtil::IAgQuantity * Value ) {
    HRESULT _hr = raw_SetMinimum(Value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

STKUtil::IAgQuantityPtr IAgCrdnConditionScalarBounds::GetMaximum ( ) {
    struct STKUtil::IAgQuantity * _result = 0;
    HRESULT _hr = raw_GetMaximum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgQuantityPtr(_result, false);
}

HRESULT IAgCrdnConditionScalarBounds::SetMaximum ( struct STKUtil::IAgQuantity * Value ) {
    HRESULT _hr = raw_SetMaximum(Value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgCrdnConditionScalarBounds::Set ( struct STKUtil::IAgQuantity * Min, struct STKUtil::IAgQuantity * Max ) {
    HRESULT _hr = raw_Set(Min, Max);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IAgCrdnConditionSetScalarThresholds wrapper method implementations
//

IAgCrdnCalcScalarPtr IAgCrdnConditionSetScalarThresholds::GetScalar ( ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = get_Scalar(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

void IAgCrdnConditionSetScalarThresholds::PutScalar ( struct IAgCrdnCalcScalar * ppRetVal ) {
    HRESULT _hr = put_Scalar(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

SAFEARRAY * IAgCrdnConditionSetScalarThresholds::GetThresholds ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Thresholds(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgCrdnConditionSetScalarThresholds::GetThresholdLabels ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_ThresholdLabels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IAgCrdnConditionSetScalarThresholds::GetIncludeAboveHighestThreshold ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IncludeAboveHighestThreshold(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnConditionSetScalarThresholds::PutIncludeAboveHighestThreshold ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_IncludeAboveHighestThreshold(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnConditionSetScalarThresholds::GetIncludeBelowLowestThreshold ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IncludeBelowLowestThreshold(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnConditionSetScalarThresholds::PutIncludeBelowLowestThreshold ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_IncludeBelowLowestThreshold(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgCrdnConditionSetScalarThresholds::SetThresholdsAndLabels ( SAFEARRAY * * Thresholds, SAFEARRAY * * ThresholdLabels ) {
    HRESULT _hr = raw_SetThresholdsAndLabels(Thresholds, ThresholdLabels);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IAgCrdnConvergeBasic wrapper method implementations
//

enum AgECrdnThreshConvergeSense IAgCrdnConvergeBasic::GetSense ( ) {
    enum AgECrdnThreshConvergeSense _result;
    HRESULT _hr = get_Sense(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnConvergeBasic::PutSense ( enum AgECrdnThreshConvergeSense pRetVal ) {
    HRESULT _hr = put_Sense(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnConvergeBasic::GetTimeTolerance ( ) {
    double _result = 0;
    HRESULT _hr = get_TimeTolerance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnConvergeBasic::PutTimeTolerance ( double pRetVal ) {
    HRESULT _hr = put_TimeTolerance(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnConvergeBasic::GetAbsoluteTolerance ( ) {
    double _result = 0;
    HRESULT _hr = get_AbsoluteTolerance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnConvergeBasic::PutAbsoluteTolerance ( double pRetVal ) {
    HRESULT _hr = put_AbsoluteTolerance(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnConvergeBasic::GetRelativeTolerance ( ) {
    double _result = 0;
    HRESULT _hr = get_RelativeTolerance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnConvergeBasic::PutRelativeTolerance ( double pRetVal ) {
    HRESULT _hr = put_RelativeTolerance(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnDerivativeBasic wrapper method implementations
//

double IAgCrdnDerivativeBasic::GetTimeStep ( ) {
    double _result = 0;
    HRESULT _hr = get_TimeStep(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnDerivativeBasic::PutTimeStep ( double pRetVal ) {
    HRESULT _hr = put_TimeStep(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnEventArrayConditionCrossings wrapper method implementations
//

enum AgECrdnSatisfactionCrossing IAgCrdnEventArrayConditionCrossings::GetSatisfactionCrossing ( ) {
    enum AgECrdnSatisfactionCrossing _result;
    HRESULT _hr = get_SatisfactionCrossing(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventArrayConditionCrossings::PutSatisfactionCrossing ( enum AgECrdnSatisfactionCrossing pRetVal ) {
    HRESULT _hr = put_SatisfactionCrossing(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnConditionPtr IAgCrdnEventArrayConditionCrossings::GetCondition ( ) {
    struct IAgCrdnCondition * _result = 0;
    HRESULT _hr = get_Condition(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConditionPtr(_result, false);
}

void IAgCrdnEventArrayConditionCrossings::PutCondition ( struct IAgCrdnCondition * ppRetVal ) {
    HRESULT _hr = put_Condition(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnEventIntervalListPtr IAgCrdnEventArrayConditionCrossings::GetCustomTimeLimits ( ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = get_CustomTimeLimits(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

void IAgCrdnEventArrayConditionCrossings::PutCustomTimeLimits ( struct IAgCrdnEventIntervalList * ppRetVal ) {
    HRESULT _hr = put_CustomTimeLimits(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnEventArrayConditionCrossings::GetUseCustomTimeLimits ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseCustomTimeLimits(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventArrayConditionCrossings::PutUseCustomTimeLimits ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseCustomTimeLimits(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSaveDataOption IAgCrdnEventArrayConditionCrossings::GetSaveDataOption ( ) {
    enum AgECrdnSaveDataOption _result;
    HRESULT _hr = get_SaveDataOption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventArrayConditionCrossings::PutSaveDataOption ( enum AgECrdnSaveDataOption pRetVal ) {
    HRESULT _hr = put_SaveDataOption(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSamplingPtr IAgCrdnEventArrayConditionCrossings::GetSampling ( ) {
    struct IAgCrdnSampling * _result = 0;
    HRESULT _hr = get_Sampling(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSamplingPtr(_result, false);
}

void IAgCrdnEventArrayConditionCrossings::PutSampling ( struct IAgCrdnSampling * ppRetVal ) {
    HRESULT _hr = put_Sampling(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnConvergePtr IAgCrdnEventArrayConditionCrossings::GetConvergence ( ) {
    struct IAgCrdnConverge * _result = 0;
    HRESULT _hr = get_Convergence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConvergePtr(_result, false);
}

void IAgCrdnEventArrayConditionCrossings::PutConvergence ( struct IAgCrdnConverge * ppRetVal ) {
    HRESULT _hr = put_Convergence(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnEventArrayExtrema wrapper method implementations
//

enum AgECrdnExtremumConstants IAgCrdnEventArrayExtrema::GetExtremumType ( ) {
    enum AgECrdnExtremumConstants _result;
    HRESULT _hr = get_ExtremumType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventArrayExtrema::PutExtremumType ( enum AgECrdnExtremumConstants pRetVal ) {
    HRESULT _hr = put_ExtremumType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnEventArrayExtrema::GetIsGlobal ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsGlobal(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventArrayExtrema::PutIsGlobal ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_IsGlobal(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnCalcScalarPtr IAgCrdnEventArrayExtrema::GetCalculation ( ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = get_Calculation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

void IAgCrdnEventArrayExtrema::PutCalculation ( struct IAgCrdnCalcScalar * ppRetVal ) {
    HRESULT _hr = put_Calculation(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnEventIntervalListPtr IAgCrdnEventArrayExtrema::GetCustomTimeLimits ( ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = get_CustomTimeLimits(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

void IAgCrdnEventArrayExtrema::PutCustomTimeLimits ( struct IAgCrdnEventIntervalList * ppRetVal ) {
    HRESULT _hr = put_CustomTimeLimits(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnEventArrayExtrema::GetUseCustomTimeLimits ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseCustomTimeLimits(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventArrayExtrema::PutUseCustomTimeLimits ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseCustomTimeLimits(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSaveDataOption IAgCrdnEventArrayExtrema::GetSaveDataOption ( ) {
    enum AgECrdnSaveDataOption _result;
    HRESULT _hr = get_SaveDataOption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventArrayExtrema::PutSaveDataOption ( enum AgECrdnSaveDataOption pRetVal ) {
    HRESULT _hr = put_SaveDataOption(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSamplingPtr IAgCrdnEventArrayExtrema::GetSampling ( ) {
    struct IAgCrdnSampling * _result = 0;
    HRESULT _hr = get_Sampling(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSamplingPtr(_result, false);
}

void IAgCrdnEventArrayExtrema::PutSampling ( struct IAgCrdnSampling * ppRetVal ) {
    HRESULT _hr = put_Sampling(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnConvergePtr IAgCrdnEventArrayExtrema::GetConvergence ( ) {
    struct IAgCrdnConverge * _result = 0;
    HRESULT _hr = get_Convergence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConvergePtr(_result, false);
}

void IAgCrdnEventArrayExtrema::PutConvergence ( struct IAgCrdnConverge * ppRetVal ) {
    HRESULT _hr = put_Convergence(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnEventArrayFiltered wrapper method implementations
//

IAgCrdnEventArrayPtr IAgCrdnEventArrayFiltered::GetOriginalTimeArray ( ) {
    struct IAgCrdnEventArray * _result = 0;
    HRESULT _hr = get_OriginalTimeArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventArrayPtr(_result, false);
}

void IAgCrdnEventArrayFiltered::PutOriginalTimeArray ( struct IAgCrdnEventArray * ppRetVal ) {
    HRESULT _hr = put_OriginalTimeArray(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnEventArrayFilterType IAgCrdnEventArrayFiltered::GetFilterType ( ) {
    enum AgECrdnEventArrayFilterType _result;
    HRESULT _hr = get_FilterType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventArrayFiltered::PutFilterType ( enum AgECrdnEventArrayFilterType pRetVal ) {
    HRESULT _hr = put_FilterType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

int IAgCrdnEventArrayFiltered::GetCount ( ) {
    int _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventArrayFiltered::PutCount ( int pRetVal ) {
    HRESULT _hr = put_Count(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnEventArrayFiltered::GetStep ( ) {
    double _result = 0;
    HRESULT _hr = get_Step(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventArrayFiltered::PutStep ( double pRetVal ) {
    HRESULT _hr = put_Step(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnEventArrayFiltered::GetIncludeIntervalStopTimes ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IncludeIntervalStopTimes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventArrayFiltered::PutIncludeIntervalStopTimes ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_IncludeIntervalStopTimes(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnEventArrayFixedStep wrapper method implementations
//

IAgCrdnEventIntervalListPtr IAgCrdnEventArrayFixedStep::GetBoundingIntervalList ( ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = get_BoundingIntervalList(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

void IAgCrdnEventArrayFixedStep::PutBoundingIntervalList ( struct IAgCrdnEventIntervalList * ppRetVal ) {
    HRESULT _hr = put_BoundingIntervalList(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnEventArrayFixedStep::GetSamplingTimeStep ( ) {
    double _result = 0;
    HRESULT _hr = get_SamplingTimeStep(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventArrayFixedStep::PutSamplingTimeStep ( double pRetVal ) {
    HRESULT _hr = put_SamplingTimeStep(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnEventArrayFixedStep::GetIncludeIntervalEdges ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IncludeIntervalEdges(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventArrayFixedStep::PutIncludeIntervalEdges ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_IncludeIntervalEdges(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSampledReferenceTime IAgCrdnEventArrayFixedStep::GetReferenceType ( ) {
    enum AgECrdnSampledReferenceTime _result;
    HRESULT _hr = get_ReferenceType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventArrayFixedStep::PutReferenceType ( enum AgECrdnSampledReferenceTime pRetVal ) {
    HRESULT _hr = put_ReferenceType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnEventPtr IAgCrdnEventArrayFixedStep::GetReferenceTimeInstant ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_ReferenceTimeInstant(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

void IAgCrdnEventArrayFixedStep::PutReferenceTimeInstant ( struct IAgCrdnEvent * ppRetVal ) {
    HRESULT _hr = put_ReferenceTimeInstant(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnEventArrayFixedTimes wrapper method implementations
//

SAFEARRAY * IAgCrdnEventArrayFixedTimes::GetArrayTimes ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_ArrayTimes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IAgCrdnEventArrayFixedTimes::SetArrayTimes ( SAFEARRAY * * Times ) {
    HRESULT _hr = raw_SetArrayTimes(Times);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IAgCrdnEventArrayMerged wrapper method implementations
//

IAgCrdnEventArrayPtr IAgCrdnEventArrayMerged::GetTimeArrayA ( ) {
    struct IAgCrdnEventArray * _result = 0;
    HRESULT _hr = get_TimeArrayA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventArrayPtr(_result, false);
}

void IAgCrdnEventArrayMerged::PutTimeArrayA ( struct IAgCrdnEventArray * ppRetVal ) {
    HRESULT _hr = put_TimeArrayA(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnEventArrayPtr IAgCrdnEventArrayMerged::GetTimeArrayB ( ) {
    struct IAgCrdnEventArray * _result = 0;
    HRESULT _hr = get_TimeArrayB(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventArrayPtr(_result, false);
}

void IAgCrdnEventArrayMerged::PutTimeArrayB ( struct IAgCrdnEventArray * ppRetVal ) {
    HRESULT _hr = put_TimeArrayB(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnEventArraySignaled wrapper method implementations
//

IAgCrdnEventArrayPtr IAgCrdnEventArraySignaled::GetOriginalTimeArray ( ) {
    struct IAgCrdnEventArray * _result = 0;
    HRESULT _hr = get_OriginalTimeArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventArrayPtr(_result, false);
}

void IAgCrdnEventArraySignaled::PutOriginalTimeArray ( struct IAgCrdnEventArray * ppRetVal ) {
    HRESULT _hr = put_OriginalTimeArray(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSignalSense IAgCrdnEventArraySignaled::GetSignalSense ( ) {
    enum AgECrdnSignalSense _result;
    HRESULT _hr = get_SignalSense(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventArraySignaled::PutSignalSense ( enum AgECrdnSignalSense pRetVal ) {
    HRESULT _hr = put_SignalSense(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPointPtr IAgCrdnEventArraySignaled::GetBaseClockLocation ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = get_BaseClockLocation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

void IAgCrdnEventArraySignaled::PutBaseClockLocation ( struct IAgCrdnPoint * ppRetVal ) {
    HRESULT _hr = put_BaseClockLocation(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPointPtr IAgCrdnEventArraySignaled::GetTargetClockLocation ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = get_TargetClockLocation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

void IAgCrdnEventArraySignaled::PutTargetClockLocation ( struct IAgCrdnPoint * ppRetVal ) {
    HRESULT _hr = put_TargetClockLocation(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSignalDelayPtr IAgCrdnEventArraySignaled::GetSignalDelay ( ) {
    struct IAgCrdnSignalDelay * _result = 0;
    HRESULT _hr = get_SignalDelay(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSignalDelayPtr(_result, false);
}

void IAgCrdnEventArraySignaled::PutSignalDelay ( struct IAgCrdnSignalDelay * ppRetVal ) {
    HRESULT _hr = put_SignalDelay(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnEventArrayStartStopTimes wrapper method implementations
//

enum AgECrdnStartStopOption IAgCrdnEventArrayStartStopTimes::GetStartStopOption ( ) {
    enum AgECrdnStartStopOption _result;
    HRESULT _hr = get_StartStopOption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventArrayStartStopTimes::PutStartStopOption ( enum AgECrdnStartStopOption pRetVal ) {
    HRESULT _hr = put_StartStopOption(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnEventIntervalListPtr IAgCrdnEventArrayStartStopTimes::GetReferenceIntervals ( ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = get_ReferenceIntervals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

void IAgCrdnEventArrayStartStopTimes::PutReferenceIntervals ( struct IAgCrdnEventIntervalList * ppRetVal ) {
    HRESULT _hr = put_ReferenceIntervals(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnEventEpoch wrapper method implementations
//

_variant_t IAgCrdnEventEpoch::GetEpoch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Epoch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgCrdnEventEpoch::PutEpoch ( const _variant_t & pRetVal ) {
    HRESULT _hr = put_Epoch(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnEventExtremum wrapper method implementations
//

enum AgECrdnExtremumConstants IAgCrdnEventExtremum::GetExtremumType ( ) {
    enum AgECrdnExtremumConstants _result;
    HRESULT _hr = get_ExtremumType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventExtremum::PutExtremumType ( enum AgECrdnExtremumConstants pRetVal ) {
    HRESULT _hr = put_ExtremumType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnCalcScalarPtr IAgCrdnEventExtremum::GetCalculation ( ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = get_Calculation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

void IAgCrdnEventExtremum::PutCalculation ( struct IAgCrdnCalcScalar * ppRetVal ) {
    HRESULT _hr = put_Calculation(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnEventIntervalListPtr IAgCrdnEventExtremum::GetCustomTimeLimits ( ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = get_CustomTimeLimits(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

void IAgCrdnEventExtremum::PutCustomTimeLimits ( struct IAgCrdnEventIntervalList * ppRetVal ) {
    HRESULT _hr = put_CustomTimeLimits(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnEventExtremum::GetUseCustomTimeLimits ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseCustomTimeLimits(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventExtremum::PutUseCustomTimeLimits ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseCustomTimeLimits(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSaveDataOption IAgCrdnEventExtremum::GetSaveDataOption ( ) {
    enum AgECrdnSaveDataOption _result;
    HRESULT _hr = get_SaveDataOption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventExtremum::PutSaveDataOption ( enum AgECrdnSaveDataOption pRetVal ) {
    HRESULT _hr = put_SaveDataOption(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSamplingPtr IAgCrdnEventExtremum::GetSampling ( ) {
    struct IAgCrdnSampling * _result = 0;
    HRESULT _hr = get_Sampling(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSamplingPtr(_result, false);
}

void IAgCrdnEventExtremum::PutSampling ( struct IAgCrdnSampling * ppRetVal ) {
    HRESULT _hr = put_Sampling(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnConvergePtr IAgCrdnEventExtremum::GetConvergence ( ) {
    struct IAgCrdnConverge * _result = 0;
    HRESULT _hr = get_Convergence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConvergePtr(_result, false);
}

void IAgCrdnEventExtremum::PutConvergence ( struct IAgCrdnConverge * ppRetVal ) {
    HRESULT _hr = put_Convergence(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnEventIntervalBetweenTimeInstants wrapper method implementations
//

IAgCrdnEventPtr IAgCrdnEventIntervalBetweenTimeInstants::GetStartTimeInstant ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_StartTimeInstant(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

void IAgCrdnEventIntervalBetweenTimeInstants::PutStartTimeInstant ( struct IAgCrdnEvent * ppRetVal ) {
    HRESULT _hr = put_StartTimeInstant(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnEventPtr IAgCrdnEventIntervalBetweenTimeInstants::GetStopTimeInstant ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_StopTimeInstant(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

void IAgCrdnEventIntervalBetweenTimeInstants::PutStopTimeInstant ( struct IAgCrdnEvent * ppRetVal ) {
    HRESULT _hr = put_StopTimeInstant(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnEventIntervalCollectionCondition wrapper method implementations
//

IAgCrdnConditionSetPtr IAgCrdnEventIntervalCollectionCondition::GetConditionSet ( ) {
    struct IAgCrdnConditionSet * _result = 0;
    HRESULT _hr = get_ConditionSet(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConditionSetPtr(_result, false);
}

void IAgCrdnEventIntervalCollectionCondition::PutConditionSet ( struct IAgCrdnConditionSet * ppRetVal ) {
    HRESULT _hr = put_ConditionSet(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnEventIntervalListPtr IAgCrdnEventIntervalCollectionCondition::GetCustomTimeLimits ( ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = get_CustomTimeLimits(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

void IAgCrdnEventIntervalCollectionCondition::PutCustomTimeLimits ( struct IAgCrdnEventIntervalList * ppRetVal ) {
    HRESULT _hr = put_CustomTimeLimits(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnEventIntervalCollectionCondition::GetUseCustomTimeLimits ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseCustomTimeLimits(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventIntervalCollectionCondition::PutUseCustomTimeLimits ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseCustomTimeLimits(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSaveDataOption IAgCrdnEventIntervalCollectionCondition::GetSaveDataOption ( ) {
    enum AgECrdnSaveDataOption _result;
    HRESULT _hr = get_SaveDataOption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventIntervalCollectionCondition::PutSaveDataOption ( enum AgECrdnSaveDataOption pRetVal ) {
    HRESULT _hr = put_SaveDataOption(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSamplingPtr IAgCrdnEventIntervalCollectionCondition::GetSampling ( ) {
    struct IAgCrdnSampling * _result = 0;
    HRESULT _hr = get_Sampling(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSamplingPtr(_result, false);
}

void IAgCrdnEventIntervalCollectionCondition::PutSampling ( struct IAgCrdnSampling * ppRetVal ) {
    HRESULT _hr = put_Sampling(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnConvergePtr IAgCrdnEventIntervalCollectionCondition::GetConvergence ( ) {
    struct IAgCrdnConverge * _result = 0;
    HRESULT _hr = get_Convergence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConvergePtr(_result, false);
}

void IAgCrdnEventIntervalCollectionCondition::PutConvergence ( struct IAgCrdnConverge * ppRetVal ) {
    HRESULT _hr = put_Convergence(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnEventIntervalCollectionLighting wrapper method implementations
//

IAgCrdnPointPtr IAgCrdnEventIntervalCollectionLighting::GetLocation ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = get_Location(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

void IAgCrdnEventIntervalCollectionLighting::PutLocation ( struct IAgCrdnPoint * ppRetVal ) {
    HRESULT _hr = put_Location(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

SAFEARRAY * IAgCrdnEventIntervalCollectionLighting::GetEclipsingBodies ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_EclipsingBodies(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventIntervalCollectionLighting::PutEclipsingBodies ( SAFEARRAY * ppRetVal ) {
    HRESULT _hr = put_EclipsingBodies(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnEventIntervalCollectionLighting::GetUseObjectEclipsingBodies ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseObjectEclipsingBodies(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventIntervalCollectionLighting::PutUseObjectEclipsingBodies ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseObjectEclipsingBodies(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnEventIntervalCollectionSignaled wrapper method implementations
//

IAgCrdnEventIntervalCollectionPtr IAgCrdnEventIntervalCollectionSignaled::GetOriginalCollection ( ) {
    struct IAgCrdnEventIntervalCollection * _result = 0;
    HRESULT _hr = get_OriginalCollection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalCollectionPtr(_result, false);
}

void IAgCrdnEventIntervalCollectionSignaled::PutOriginalCollection ( struct IAgCrdnEventIntervalCollection * ppRetVal ) {
    HRESULT _hr = put_OriginalCollection(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSignalSense IAgCrdnEventIntervalCollectionSignaled::GetSignalSense ( ) {
    enum AgECrdnSignalSense _result;
    HRESULT _hr = get_SignalSense(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventIntervalCollectionSignaled::PutSignalSense ( enum AgECrdnSignalSense pRetVal ) {
    HRESULT _hr = put_SignalSense(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPointPtr IAgCrdnEventIntervalCollectionSignaled::GetBaseClockLocation ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = get_BaseClockLocation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

void IAgCrdnEventIntervalCollectionSignaled::PutBaseClockLocation ( struct IAgCrdnPoint * ppRetVal ) {
    HRESULT _hr = put_BaseClockLocation(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPointPtr IAgCrdnEventIntervalCollectionSignaled::GetTargetClockLocation ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = get_TargetClockLocation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

void IAgCrdnEventIntervalCollectionSignaled::PutTargetClockLocation ( struct IAgCrdnPoint * ppRetVal ) {
    HRESULT _hr = put_TargetClockLocation(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSignalDelayPtr IAgCrdnEventIntervalCollectionSignaled::GetSignalDelay ( ) {
    struct IAgCrdnSignalDelay * _result = 0;
    HRESULT _hr = get_SignalDelay(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSignalDelayPtr(_result, false);
}

void IAgCrdnEventIntervalCollectionSignaled::PutSignalDelay ( struct IAgCrdnSignalDelay * ppRetVal ) {
    HRESULT _hr = put_SignalDelay(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnEventIntervalFixed wrapper method implementations
//

_variant_t IAgCrdnEventIntervalFixed::GetStartTime ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_StartTime(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

_variant_t IAgCrdnEventIntervalFixed::GetStopTime ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_StopTime(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

HRESULT IAgCrdnEventIntervalFixed::SetInterval ( const _variant_t & StartEpoch, const _variant_t & StopEpoch ) {
    HRESULT _hr = raw_SetInterval(StartEpoch, StopEpoch);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IAgCrdnEventIntervalFixedDuration wrapper method implementations
//

IAgCrdnEventPtr IAgCrdnEventIntervalFixedDuration::GetReferenceTimeInstant ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_ReferenceTimeInstant(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

void IAgCrdnEventIntervalFixedDuration::PutReferenceTimeInstant ( struct IAgCrdnEvent * ppRetVal ) {
    HRESULT _hr = put_ReferenceTimeInstant(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnEventIntervalFixedDuration::GetStartOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_StartOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventIntervalFixedDuration::PutStartOffset ( double pRetVal ) {
    HRESULT _hr = put_StartOffset(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnEventIntervalFixedDuration::GetStopOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_StopOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventIntervalFixedDuration::PutStopOffset ( double pRetVal ) {
    HRESULT _hr = put_StopOffset(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnEventIntervalFromIntervalList wrapper method implementations
//

IAgCrdnEventIntervalListPtr IAgCrdnEventIntervalFromIntervalList::GetReferenceIntervals ( ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = get_ReferenceIntervals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

void IAgCrdnEventIntervalFromIntervalList::PutReferenceIntervals ( struct IAgCrdnEventIntervalList * ppRetVal ) {
    HRESULT _hr = put_ReferenceIntervals(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnIntervalSelection IAgCrdnEventIntervalFromIntervalList::GetIntervalSelection ( ) {
    enum AgECrdnIntervalSelection _result;
    HRESULT _hr = get_IntervalSelection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventIntervalFromIntervalList::PutIntervalSelection ( enum AgECrdnIntervalSelection pRetVal ) {
    HRESULT _hr = put_IntervalSelection(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

int IAgCrdnEventIntervalFromIntervalList::GetIntervalNumber ( ) {
    int _result = 0;
    HRESULT _hr = get_IntervalNumber(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventIntervalFromIntervalList::PutIntervalNumber ( int pRetVal ) {
    HRESULT _hr = put_IntervalNumber(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnEventIntervalListCondition wrapper method implementations
//

IAgCrdnConditionPtr IAgCrdnEventIntervalListCondition::GetCondition ( ) {
    struct IAgCrdnCondition * _result = 0;
    HRESULT _hr = get_Condition(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConditionPtr(_result, false);
}

void IAgCrdnEventIntervalListCondition::PutCondition ( struct IAgCrdnCondition * ppRetVal ) {
    HRESULT _hr = put_Condition(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnEventIntervalListPtr IAgCrdnEventIntervalListCondition::GetCustomTimeLimits ( ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = get_CustomTimeLimits(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

void IAgCrdnEventIntervalListCondition::PutCustomTimeLimits ( struct IAgCrdnEventIntervalList * ppRetVal ) {
    HRESULT _hr = put_CustomTimeLimits(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnEventIntervalListCondition::GetUseCustomTimeLimits ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseCustomTimeLimits(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventIntervalListCondition::PutUseCustomTimeLimits ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseCustomTimeLimits(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSaveDataOption IAgCrdnEventIntervalListCondition::GetSaveDataOption ( ) {
    enum AgECrdnSaveDataOption _result;
    HRESULT _hr = get_SaveDataOption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventIntervalListCondition::PutSaveDataOption ( enum AgECrdnSaveDataOption pRetVal ) {
    HRESULT _hr = put_SaveDataOption(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSamplingPtr IAgCrdnEventIntervalListCondition::GetSampling ( ) {
    struct IAgCrdnSampling * _result = 0;
    HRESULT _hr = get_Sampling(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSamplingPtr(_result, false);
}

void IAgCrdnEventIntervalListCondition::PutSampling ( struct IAgCrdnSampling * ppRetVal ) {
    HRESULT _hr = put_Sampling(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnConvergePtr IAgCrdnEventIntervalListCondition::GetConvergence ( ) {
    struct IAgCrdnConverge * _result = 0;
    HRESULT _hr = get_Convergence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConvergePtr(_result, false);
}

void IAgCrdnEventIntervalListCondition::PutConvergence ( struct IAgCrdnConverge * ppRetVal ) {
    HRESULT _hr = put_Convergence(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnEventIntervalListFile wrapper method implementations
//

_bstr_t IAgCrdnEventIntervalListFile::GetFilename ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Filename(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnEventIntervalListFile::PutFilename ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Filename(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgCrdnEventIntervalListFile::Reload ( ) {
    HRESULT _hr = raw_Reload();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnEventIntervalResultPtr IAgCrdnEventIntervalListFile::GetFileSpan ( ) {
    struct IAgCrdnEventIntervalResult * _result = 0;
    HRESULT _hr = raw_GetFileSpan(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalResultPtr(_result, false);
}

//
// interface IAgCrdnEventIntervalListFiltered wrapper method implementations
//

IAgCrdnEventIntervalListPtr IAgCrdnEventIntervalListFiltered::GetOriginalIntervals ( ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = get_OriginalIntervals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

void IAgCrdnEventIntervalListFiltered::PutOriginalIntervals ( struct IAgCrdnEventIntervalList * ppRetVal ) {
    HRESULT _hr = put_OriginalIntervals(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPruneFilterFactoryPtr IAgCrdnEventIntervalListFiltered::GetFilterFactory ( ) {
    struct IAgCrdnPruneFilterFactory * _result = 0;
    HRESULT _hr = get_FilterFactory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPruneFilterFactoryPtr(_result, false);
}

IAgCrdnPruneFilterPtr IAgCrdnEventIntervalListFiltered::GetFilter ( ) {
    struct IAgCrdnPruneFilter * _result = 0;
    HRESULT _hr = get_Filter(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPruneFilterPtr(_result, false);
}

void IAgCrdnEventIntervalListFiltered::PutFilter ( struct IAgCrdnPruneFilter * ppRetVal ) {
    HRESULT _hr = put_Filter(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnEventIntervalListFixed wrapper method implementations
//

SAFEARRAY * IAgCrdnEventIntervalListFixed::GetIntervals ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetIntervals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IAgCrdnEventIntervalListFixed::SetIntervals ( SAFEARRAY * * Intervals ) {
    HRESULT _hr = raw_SetIntervals(Intervals);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IAgCrdnEventIntervalListScaled wrapper method implementations
//

IAgCrdnEventIntervalListPtr IAgCrdnEventIntervalListScaled::GetOriginalIntervals ( ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = get_OriginalIntervals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

void IAgCrdnEventIntervalListScaled::PutOriginalIntervals ( struct IAgCrdnEventIntervalList * ppRetVal ) {
    HRESULT _hr = put_OriginalIntervals(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnEventIntervalListScaled::GetAbsoluteIncrement ( ) {
    double _result = 0;
    HRESULT _hr = get_AbsoluteIncrement(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventIntervalListScaled::PutAbsoluteIncrement ( double pRetVal ) {
    HRESULT _hr = put_AbsoluteIncrement(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnEventIntervalListScaled::GetRelativeIncrement ( ) {
    double _result = 0;
    HRESULT _hr = get_RelativeIncrement(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventIntervalListScaled::PutRelativeIncrement ( double pRetVal ) {
    HRESULT _hr = put_RelativeIncrement(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnEventIntervalListScaled::GetUseAbsoluteIncrement ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseAbsoluteIncrement(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventIntervalListScaled::PutUseAbsoluteIncrement ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseAbsoluteIncrement(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnEventIntervalListSignaled wrapper method implementations
//

IAgCrdnEventIntervalListPtr IAgCrdnEventIntervalListSignaled::GetOriginalIntervals ( ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = get_OriginalIntervals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

void IAgCrdnEventIntervalListSignaled::PutOriginalIntervals ( struct IAgCrdnEventIntervalList * ppRetVal ) {
    HRESULT _hr = put_OriginalIntervals(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSignalSense IAgCrdnEventIntervalListSignaled::GetSignalSense ( ) {
    enum AgECrdnSignalSense _result;
    HRESULT _hr = get_SignalSense(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventIntervalListSignaled::PutSignalSense ( enum AgECrdnSignalSense pRetVal ) {
    HRESULT _hr = put_SignalSense(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPointPtr IAgCrdnEventIntervalListSignaled::GetBaseClockLocation ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = get_BaseClockLocation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

void IAgCrdnEventIntervalListSignaled::PutBaseClockLocation ( struct IAgCrdnPoint * ppRetVal ) {
    HRESULT _hr = put_BaseClockLocation(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPointPtr IAgCrdnEventIntervalListSignaled::GetTargetClockLocation ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = get_TargetClockLocation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

void IAgCrdnEventIntervalListSignaled::PutTargetClockLocation ( struct IAgCrdnPoint * ppRetVal ) {
    HRESULT _hr = put_TargetClockLocation(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSignalDelayPtr IAgCrdnEventIntervalListSignaled::GetSignalDelay ( ) {
    struct IAgCrdnSignalDelay * _result = 0;
    HRESULT _hr = get_SignalDelay(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSignalDelayPtr(_result, false);
}

void IAgCrdnEventIntervalListSignaled::PutSignalDelay ( struct IAgCrdnSignalDelay * ppRetVal ) {
    HRESULT _hr = put_SignalDelay(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnEventIntervalListTimeOffset wrapper method implementations
//

IAgCrdnEventIntervalListPtr IAgCrdnEventIntervalListTimeOffset::GetReferenceIntervals ( ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = get_ReferenceIntervals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

void IAgCrdnEventIntervalListTimeOffset::PutReferenceIntervals ( struct IAgCrdnEventIntervalList * ppRetVal ) {
    HRESULT _hr = put_ReferenceIntervals(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnEventIntervalListTimeOffset::GetTimeOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_TimeOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventIntervalListTimeOffset::PutTimeOffset ( double pRetVal ) {
    HRESULT _hr = put_TimeOffset(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnEventIntervalScaled wrapper method implementations
//

IAgCrdnEventIntervalPtr IAgCrdnEventIntervalScaled::GetOriginalInterval ( ) {
    struct IAgCrdnEventInterval * _result = 0;
    HRESULT _hr = get_OriginalInterval(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalPtr(_result, false);
}

void IAgCrdnEventIntervalScaled::PutOriginalInterval ( struct IAgCrdnEventInterval * ppRetVal ) {
    HRESULT _hr = put_OriginalInterval(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnEventIntervalScaled::GetAbsoluteIncrement ( ) {
    double _result = 0;
    HRESULT _hr = get_AbsoluteIncrement(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventIntervalScaled::PutAbsoluteIncrement ( double pRetVal ) {
    HRESULT _hr = put_AbsoluteIncrement(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnEventIntervalScaled::GetRelativeIncrement ( ) {
    double _result = 0;
    HRESULT _hr = get_RelativeIncrement(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventIntervalScaled::PutRelativeIncrement ( double pRetVal ) {
    HRESULT _hr = put_RelativeIncrement(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnEventIntervalScaled::GetUseAbsoluteIncrement ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseAbsoluteIncrement(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventIntervalScaled::PutUseAbsoluteIncrement ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseAbsoluteIncrement(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnEventIntervalSignaled wrapper method implementations
//

IAgCrdnEventIntervalPtr IAgCrdnEventIntervalSignaled::GetOriginalInterval ( ) {
    struct IAgCrdnEventInterval * _result = 0;
    HRESULT _hr = get_OriginalInterval(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalPtr(_result, false);
}

void IAgCrdnEventIntervalSignaled::PutOriginalInterval ( struct IAgCrdnEventInterval * ppRetVal ) {
    HRESULT _hr = put_OriginalInterval(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSignalSense IAgCrdnEventIntervalSignaled::GetSignalSense ( ) {
    enum AgECrdnSignalSense _result;
    HRESULT _hr = get_SignalSense(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventIntervalSignaled::PutSignalSense ( enum AgECrdnSignalSense pRetVal ) {
    HRESULT _hr = put_SignalSense(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPointPtr IAgCrdnEventIntervalSignaled::GetBaseClockLocation ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = get_BaseClockLocation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

void IAgCrdnEventIntervalSignaled::PutBaseClockLocation ( struct IAgCrdnPoint * ppRetVal ) {
    HRESULT _hr = put_BaseClockLocation(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPointPtr IAgCrdnEventIntervalSignaled::GetTargetClockLocation ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = get_TargetClockLocation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

void IAgCrdnEventIntervalSignaled::PutTargetClockLocation ( struct IAgCrdnPoint * ppRetVal ) {
    HRESULT _hr = put_TargetClockLocation(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSignalDelayPtr IAgCrdnEventIntervalSignaled::GetSignalDelay ( ) {
    struct IAgCrdnSignalDelay * _result = 0;
    HRESULT _hr = get_SignalDelay(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSignalDelayPtr(_result, false);
}

void IAgCrdnEventIntervalSignaled::PutSignalDelay ( struct IAgCrdnSignalDelay * ppRetVal ) {
    HRESULT _hr = put_SignalDelay(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnEventIntervalSmartInterval wrapper method implementations
//

IAgCrdnEventIntervalPtr IAgCrdnEventIntervalSmartInterval::GetReferenceInterval ( ) {
    struct IAgCrdnEventInterval * _result = 0;
    HRESULT _hr = get_ReferenceInterval(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalPtr(_result, false);
}

_bstr_t IAgCrdnEventIntervalSmartInterval::GetDurationAsString ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DurationAsString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnEventIntervalSmartInterval::PutDurationAsString ( _bstr_t pRetVal ) {
    HRESULT _hr = put_DurationAsString(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSmartIntervalState IAgCrdnEventIntervalSmartInterval::GetState ( ) {
    enum AgECrdnSmartIntervalState _result;
    HRESULT _hr = get_State(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventIntervalSmartInterval::PutState ( enum AgECrdnSmartIntervalState pRetVal ) {
    HRESULT _hr = put_State(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgCrdnEventIntervalSmartInterval::SetImplicitInterval ( struct IAgCrdnEventInterval * EventInterval ) {
    HRESULT _hr = raw_SetImplicitInterval(EventInterval);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_variant_t IAgCrdnEventIntervalSmartInterval::FindStartTime ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_FindStartTime(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

_variant_t IAgCrdnEventIntervalSmartInterval::FindStopTime ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_FindStopTime(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

IAgCrdnEventSmartEpochPtr IAgCrdnEventIntervalSmartInterval::GetStartEpoch ( ) {
    struct IAgCrdnEventSmartEpoch * _result = 0;
    HRESULT _hr = raw_GetStartEpoch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventSmartEpochPtr(_result, false);
}

HRESULT IAgCrdnEventIntervalSmartInterval::SetStartEpoch ( struct IAgCrdnEventSmartEpoch * StartEpoch ) {
    HRESULT _hr = raw_SetStartEpoch(StartEpoch);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnEventSmartEpochPtr IAgCrdnEventIntervalSmartInterval::GetStopEpoch ( ) {
    struct IAgCrdnEventSmartEpoch * _result = 0;
    HRESULT _hr = raw_GetStopEpoch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventSmartEpochPtr(_result, false);
}

HRESULT IAgCrdnEventIntervalSmartInterval::SetStopEpoch ( struct IAgCrdnEventSmartEpoch * StopEpoch ) {
    HRESULT _hr = raw_SetStopEpoch(StopEpoch);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgCrdnEventIntervalSmartInterval::SetExplicitInterval ( const _variant_t & Start, const _variant_t & Stop ) {
    HRESULT _hr = raw_SetExplicitInterval(Start, Stop);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgCrdnEventIntervalSmartInterval::SetStartAndStopEpochs ( struct IAgCrdnEventSmartEpoch * RefStartEpoch, struct IAgCrdnEventSmartEpoch * RefStopEpoch ) {
    HRESULT _hr = raw_SetStartAndStopEpochs(RefStartEpoch, RefStopEpoch);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgCrdnEventIntervalSmartInterval::SetStartAndStopTimes ( const _variant_t & StartTime, const _variant_t & StopTime ) {
    HRESULT _hr = raw_SetStartAndStopTimes(StartTime, StopTime);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgCrdnEventIntervalSmartInterval::SetStartEpochAndDuration ( struct IAgCrdnEventSmartEpoch * RefStartEpoch, _bstr_t DurationStr ) {
    HRESULT _hr = raw_SetStartEpochAndDuration(RefStartEpoch, DurationStr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgCrdnEventIntervalSmartInterval::SetStartTimeAndDuration ( const _variant_t & Epoch, _bstr_t DurationStr ) {
    HRESULT _hr = raw_SetStartTimeAndDuration(Epoch, DurationStr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IAgCrdnEventIntervalTimeOffset wrapper method implementations
//

IAgCrdnEventIntervalPtr IAgCrdnEventIntervalTimeOffset::GetReferenceInterval ( ) {
    struct IAgCrdnEventInterval * _result = 0;
    HRESULT _hr = get_ReferenceInterval(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalPtr(_result, false);
}

void IAgCrdnEventIntervalTimeOffset::PutReferenceInterval ( struct IAgCrdnEventInterval * ppRetVal ) {
    HRESULT _hr = put_ReferenceInterval(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnEventIntervalTimeOffset::GetTimeOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_TimeOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventIntervalTimeOffset::PutTimeOffset ( double pRetVal ) {
    HRESULT _hr = put_TimeOffset(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnEventSignaled wrapper method implementations
//

IAgCrdnEventPtr IAgCrdnEventSignaled::GetOriginalTimeInstant ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_OriginalTimeInstant(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

void IAgCrdnEventSignaled::PutOriginalTimeInstant ( struct IAgCrdnEvent * ppRetVal ) {
    HRESULT _hr = put_OriginalTimeInstant(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSignalSense IAgCrdnEventSignaled::GetSignalSense ( ) {
    enum AgECrdnSignalSense _result;
    HRESULT _hr = get_SignalSense(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventSignaled::PutSignalSense ( enum AgECrdnSignalSense pRetVal ) {
    HRESULT _hr = put_SignalSense(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPointPtr IAgCrdnEventSignaled::GetBaseClockLocation ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = get_BaseClockLocation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

void IAgCrdnEventSignaled::PutBaseClockLocation ( struct IAgCrdnPoint * ppRetVal ) {
    HRESULT _hr = put_BaseClockLocation(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPointPtr IAgCrdnEventSignaled::GetTargetClockLocation ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = get_TargetClockLocation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

void IAgCrdnEventSignaled::PutTargetClockLocation ( struct IAgCrdnPoint * ppRetVal ) {
    HRESULT _hr = put_TargetClockLocation(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSignalDelayPtr IAgCrdnEventSignaled::GetSignalDelay ( ) {
    struct IAgCrdnSignalDelay * _result = 0;
    HRESULT _hr = get_SignalDelay(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSignalDelayPtr(_result, false);
}

void IAgCrdnEventSignaled::PutSignalDelay ( struct IAgCrdnSignalDelay * ppRetVal ) {
    HRESULT _hr = put_SignalDelay(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnEventStartStopTime wrapper method implementations
//

VARIANT_BOOL IAgCrdnEventStartStopTime::GetUseStart ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseStart(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventStartStopTime::PutUseStart ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseStart(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnEventIntervalPtr IAgCrdnEventStartStopTime::GetReferenceEventInterval ( ) {
    struct IAgCrdnEventInterval * _result = 0;
    HRESULT _hr = get_ReferenceEventInterval(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalPtr(_result, false);
}

void IAgCrdnEventStartStopTime::PutReferenceEventInterval ( struct IAgCrdnEventInterval * ppRetVal ) {
    HRESULT _hr = put_ReferenceEventInterval(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnEventTimeOffset wrapper method implementations
//

double IAgCrdnEventTimeOffset::GetTimeOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_TimeOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventTimeOffset::PutTimeOffset ( double pRetVal ) {
    HRESULT _hr = put_TimeOffset(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnEventPtr IAgCrdnEventTimeOffset::GetReferenceTimeInstant ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_ReferenceTimeInstant(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

void IAgCrdnEventTimeOffset::PutReferenceTimeInstant ( struct IAgCrdnEvent * ppRetVal ) {
    HRESULT _hr = put_ReferenceTimeInstant(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnEventTimeOffset::GetTimeOffset2 ( ) {
    double _result = 0;
    HRESULT _hr = get_TimeOffset2(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventTimeOffset::PutTimeOffset2 ( double pRetVal ) {
    HRESULT _hr = put_TimeOffset2(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnFirstIntervalsFilter wrapper method implementations
//

int IAgCrdnFirstIntervalsFilter::GetMaximumNumberOfIntervals ( ) {
    int _result = 0;
    HRESULT _hr = get_MaximumNumberOfIntervals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnFirstIntervalsFilter::PutMaximumNumberOfIntervals ( int pRetVal ) {
    HRESULT _hr = put_MaximumNumberOfIntervals(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnGapsFilter wrapper method implementations
//

enum AgECrdnIntervalDurationKind IAgCrdnGapsFilter::GetDurationKind ( ) {
    enum AgECrdnIntervalDurationKind _result;
    HRESULT _hr = get_DurationKind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnGapsFilter::PutDurationKind ( enum AgECrdnIntervalDurationKind pRetVal ) {
    HRESULT _hr = put_DurationKind(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnGapsFilter::GetGapDuration ( ) {
    double _result = 0;
    HRESULT _hr = get_GapDuration(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnGapsFilter::PutGapDuration ( double pRetVal ) {
    HRESULT _hr = put_GapDuration(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnIntegralBasic wrapper method implementations
//

enum AgECrdnIntegralType IAgCrdnIntegralBasic::GetType ( ) {
    enum AgECrdnIntegralType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnIntegralBasic::PutType ( enum AgECrdnIntegralType pRetVal ) {
    HRESULT _hr = put_Type(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnIntegralBasic::GetTolerance ( ) {
    double _result = 0;
    HRESULT _hr = get_Tolerance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnIntegralBasic::PutTolerance ( double pRetVal ) {
    HRESULT _hr = put_Tolerance(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

int IAgCrdnIntegralBasic::GetMaximumIterations ( ) {
    int _result = 0;
    HRESULT _hr = get_MaximumIterations(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnIntegralBasic::PutMaximumIterations ( int pRetVal ) {
    HRESULT _hr = put_MaximumIterations(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnInterpBasic wrapper method implementations
//

enum AgECrdnInterpolatorType IAgCrdnInterpBasic::GetType ( ) {
    enum AgECrdnInterpolatorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnInterpBasic::PutType ( enum AgECrdnInterpolatorType pRetVal ) {
    HRESULT _hr = put_Type(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

int IAgCrdnInterpBasic::GetOrder ( ) {
    int _result = 0;
    HRESULT _hr = get_Order(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnInterpBasic::PutOrder ( int pRetVal ) {
    HRESULT _hr = put_Order(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnIntervalsFilter wrapper method implementations
//

enum AgECrdnIntervalDurationKind IAgCrdnIntervalsFilter::GetDurationKind ( ) {
    enum AgECrdnIntervalDurationKind _result;
    HRESULT _hr = get_DurationKind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnIntervalsFilter::PutDurationKind ( enum AgECrdnIntervalDurationKind pRetVal ) {
    HRESULT _hr = put_DurationKind(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnIntervalsFilter::GetIntervalDuration ( ) {
    double _result = 0;
    HRESULT _hr = get_IntervalDuration(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnIntervalsFilter::PutIntervalDuration ( double pRetVal ) {
    HRESULT _hr = put_IntervalDuration(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnLastIntervalsFilter wrapper method implementations
//

int IAgCrdnLastIntervalsFilter::GetMaximumNumberOfIntervals ( ) {
    int _result = 0;
    HRESULT _hr = get_MaximumNumberOfIntervals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnLastIntervalsFilter::PutMaximumNumberOfIntervals ( int pRetVal ) {
    HRESULT _hr = put_MaximumNumberOfIntervals(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnParameterSetGroundTrajectory wrapper method implementations
//

IAgCrdnPointPtr IAgCrdnParameterSetGroundTrajectory::GetLocation ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = get_Location(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

void IAgCrdnParameterSetGroundTrajectory::PutLocation ( struct IAgCrdnPoint * ppRetVal ) {
    HRESULT _hr = put_Location(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IAgCrdnParameterSetGroundTrajectory::GetCentralBody ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnParameterSetGroundTrajectory::PutCentralBody ( _bstr_t pRetVal ) {
    HRESULT _hr = put_CentralBody(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnParameterSetOrbit wrapper method implementations
//

IAgCrdnPointPtr IAgCrdnParameterSetOrbit::GetOrbitingPoint ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = get_OrbitingPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

void IAgCrdnParameterSetOrbit::PutOrbitingPoint ( struct IAgCrdnPoint * ppRetVal ) {
    HRESULT _hr = put_OrbitingPoint(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSystemPtr IAgCrdnParameterSetOrbit::GetReferenceSystem ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_ReferenceSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

void IAgCrdnParameterSetOrbit::PutReferenceSystem ( struct IAgCrdnSystem * ppRetVal ) {
    HRESULT _hr = put_ReferenceSystem(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnParameterSetOrbit::GetGravitationalParameter ( ) {
    double _result = 0;
    HRESULT _hr = get_GravitationalParameter(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnParameterSetOrbit::PutGravitationalParameter ( double pRetVal ) {
    HRESULT _hr = put_GravitationalParameter(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IAgCrdnParameterSetOrbit::GetCentralBody ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnParameterSetOrbit::PutCentralBody ( _bstr_t pRetVal ) {
    HRESULT _hr = put_CentralBody(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnParameterSetOrbit::GetUseCentralBodyGravitationalParameter ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseCentralBodyGravitationalParameter(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnParameterSetOrbit::PutUseCentralBodyGravitationalParameter ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseCentralBodyGravitationalParameter(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnParameterSetOrbit::GetUseCentralBodyInertial ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseCentralBodyInertial(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnParameterSetOrbit::PutUseCentralBodyInertial ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseCentralBodyInertial(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnParameterSetTrajectory wrapper method implementations
//

IAgCrdnPointPtr IAgCrdnParameterSetTrajectory::GetPoint ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = get_Point(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

void IAgCrdnParameterSetTrajectory::PutPoint ( struct IAgCrdnPoint * ppRetVal ) {
    HRESULT _hr = put_Point(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSystemPtr IAgCrdnParameterSetTrajectory::GetReferenceSystem ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_ReferenceSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

void IAgCrdnParameterSetTrajectory::PutReferenceSystem ( struct IAgCrdnSystem * ppRetVal ) {
    HRESULT _hr = put_ReferenceSystem(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnRelativeSatisfactionConditionFilter wrapper method implementations
//

IAgCrdnConditionPtr IAgCrdnRelativeSatisfactionConditionFilter::GetCondition ( ) {
    struct IAgCrdnCondition * _result = 0;
    HRESULT _hr = get_Condition(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConditionPtr(_result, false);
}

void IAgCrdnRelativeSatisfactionConditionFilter::PutCondition ( struct IAgCrdnCondition * ppRetVal ) {
    HRESULT _hr = put_Condition(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnIntervalDurationKind IAgCrdnRelativeSatisfactionConditionFilter::GetDurationKind ( ) {
    enum AgECrdnIntervalDurationKind _result;
    HRESULT _hr = get_DurationKind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnRelativeSatisfactionConditionFilter::PutDurationKind ( enum AgECrdnIntervalDurationKind pRetVal ) {
    HRESULT _hr = put_DurationKind(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnRelativeSatisfactionConditionFilter::GetRelativeIntervalDuration ( ) {
    double _result = 0;
    HRESULT _hr = get_RelativeIntervalDuration(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnRelativeSatisfactionConditionFilter::PutRelativeIntervalDuration ( double pRetVal ) {
    HRESULT _hr = put_RelativeIntervalDuration(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnSamplingBasic wrapper method implementations
//

IAgCrdnSamplingMethodPtr IAgCrdnSamplingBasic::GetSamplingMethod ( ) {
    struct IAgCrdnSamplingMethod * _result = 0;
    HRESULT _hr = get_SamplingMethod(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSamplingMethodPtr(_result, false);
}

void IAgCrdnSamplingBasic::PutSamplingMethod ( struct IAgCrdnSamplingMethod * ppRetVal ) {
    HRESULT _hr = put_SamplingMethod(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSamplingMethodFactoryPtr IAgCrdnSamplingBasic::GetMethodFactory ( ) {
    struct IAgCrdnSamplingMethodFactory * _result = 0;
    HRESULT _hr = get_MethodFactory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSamplingMethodFactoryPtr(_result, false);
}

//
// interface IAgCrdnSamplingCurvatureTolerance wrapper method implementations
//

double IAgCrdnSamplingCurvatureTolerance::GetMinimumTimeStep ( ) {
    double _result = 0;
    HRESULT _hr = get_MinimumTimeStep(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnSamplingCurvatureTolerance::PutMinimumTimeStep ( double pRetVal ) {
    HRESULT _hr = put_MinimumTimeStep(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnSamplingCurvatureTolerance::GetMaximumTimeStep ( ) {
    double _result = 0;
    HRESULT _hr = get_MaximumTimeStep(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnSamplingCurvatureTolerance::PutMaximumTimeStep ( double pRetVal ) {
    HRESULT _hr = put_MaximumTimeStep(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnSamplingCurvatureTolerance::GetStepAtBoundaries ( ) {
    double _result = 0;
    HRESULT _hr = get_StepAtBoundaries(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnSamplingCurvatureTolerance::PutStepAtBoundaries ( double pRetVal ) {
    HRESULT _hr = put_StepAtBoundaries(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnSamplingCurvatureTolerance::GetRelativeTolerance ( ) {
    double _result = 0;
    HRESULT _hr = get_RelativeTolerance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnSamplingCurvatureTolerance::PutRelativeTolerance ( double pRetVal ) {
    HRESULT _hr = put_RelativeTolerance(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnSamplingCurvatureTolerance::GetAbsoluteTolerance ( ) {
    double _result = 0;
    HRESULT _hr = get_AbsoluteTolerance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnSamplingCurvatureTolerance::PutAbsoluteTolerance ( double pRetVal ) {
    HRESULT _hr = put_AbsoluteTolerance(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnSamplingCurvatureTolerance::GetCurvatureTolerance ( ) {
    double _result = 0;
    HRESULT _hr = get_CurvatureTolerance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnSamplingCurvatureTolerance::PutCurvatureTolerance ( double pRetVal ) {
    HRESULT _hr = put_CurvatureTolerance(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnSamplingFixedStep wrapper method implementations
//

double IAgCrdnSamplingFixedStep::GetTimeStep ( ) {
    double _result = 0;
    HRESULT _hr = get_TimeStep(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnSamplingFixedStep::PutTimeStep ( double pRetVal ) {
    HRESULT _hr = put_TimeStep(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnSamplingRelativeTolerance wrapper method implementations
//

double IAgCrdnSamplingRelativeTolerance::GetMinimumTimeStep ( ) {
    double _result = 0;
    HRESULT _hr = get_MinimumTimeStep(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnSamplingRelativeTolerance::PutMinimumTimeStep ( double pRetVal ) {
    HRESULT _hr = put_MinimumTimeStep(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnSamplingRelativeTolerance::GetMaximumTimeStep ( ) {
    double _result = 0;
    HRESULT _hr = get_MaximumTimeStep(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnSamplingRelativeTolerance::PutMaximumTimeStep ( double pRetVal ) {
    HRESULT _hr = put_MaximumTimeStep(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnSamplingRelativeTolerance::GetStepAtBoundaries ( ) {
    double _result = 0;
    HRESULT _hr = get_StepAtBoundaries(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnSamplingRelativeTolerance::PutStepAtBoundaries ( double pRetVal ) {
    HRESULT _hr = put_StepAtBoundaries(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnSamplingRelativeTolerance::GetRelativeTolerance ( ) {
    double _result = 0;
    HRESULT _hr = get_RelativeTolerance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnSamplingRelativeTolerance::PutRelativeTolerance ( double pRetVal ) {
    HRESULT _hr = put_RelativeTolerance(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnSamplingRelativeTolerance::GetAbsoluteTolerance ( ) {
    double _result = 0;
    HRESULT _hr = get_AbsoluteTolerance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnSamplingRelativeTolerance::PutAbsoluteTolerance ( double pRetVal ) {
    HRESULT _hr = put_AbsoluteTolerance(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnSatisfactionConditionFilter wrapper method implementations
//

IAgCrdnConditionPtr IAgCrdnSatisfactionConditionFilter::GetCondition ( ) {
    struct IAgCrdnCondition * _result = 0;
    HRESULT _hr = get_Condition(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConditionPtr(_result, false);
}

void IAgCrdnSatisfactionConditionFilter::PutCondition ( struct IAgCrdnCondition * ppRetVal ) {
    HRESULT _hr = put_Condition(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnIntervalDurationKind IAgCrdnSatisfactionConditionFilter::GetDurationKind ( ) {
    enum AgECrdnIntervalDurationKind _result;
    HRESULT _hr = get_DurationKind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnSatisfactionConditionFilter::PutDurationKind ( enum AgECrdnIntervalDurationKind pRetVal ) {
    HRESULT _hr = put_DurationKind(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnSatisfactionConditionFilter::GetIntervalDuration ( ) {
    double _result = 0;
    HRESULT _hr = get_IntervalDuration(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnSatisfactionConditionFilter::PutIntervalDuration ( double pRetVal ) {
    HRESULT _hr = put_IntervalDuration(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnSignalDelayBasic wrapper method implementations
//

enum AgECrdnSignalPathReferenceSystem IAgCrdnSignalDelayBasic::GetSignalPathReferenceSystem ( ) {
    enum AgECrdnSignalPathReferenceSystem _result;
    HRESULT _hr = get_SignalPathReferenceSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnSignalDelayBasic::PutSignalPathReferenceSystem ( enum AgECrdnSignalPathReferenceSystem pRetVal ) {
    HRESULT _hr = put_SignalPathReferenceSystem(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSystemPtr IAgCrdnSignalDelayBasic::GetReferenceSystem ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_ReferenceSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

void IAgCrdnSignalDelayBasic::PutReferenceSystem ( struct IAgCrdnSystem * ppRetVal ) {
    HRESULT _hr = put_ReferenceSystem(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSpeedOptions IAgCrdnSignalDelayBasic::GetSpeedOption ( ) {
    enum AgECrdnSpeedOptions _result;
    HRESULT _hr = get_SpeedOption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnSignalDelayBasic::PutSpeedOption ( enum AgECrdnSpeedOptions pRetVal ) {
    HRESULT _hr = put_SpeedOption(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnSignalDelayBasic::GetTransferSpeed ( ) {
    double _result = 0;
    HRESULT _hr = get_TransferSpeed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnSignalDelayBasic::PutTransferSpeed ( double pRetVal ) {
    HRESULT _hr = put_TransferSpeed(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnSignalDelayBasic::GetTimeDelayConvergence ( ) {
    double _result = 0;
    HRESULT _hr = get_TimeDelayConvergence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnSignalDelayBasic::PutTimeDelayConvergence ( double pRetVal ) {
    HRESULT _hr = put_TimeDelayConvergence(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVolumeCombined wrapper method implementations
//

enum AgECrdnVolumeCombinedOperationType IAgCrdnVolumeCombined::GetCombineOperation ( ) {
    enum AgECrdnVolumeCombinedOperationType _result;
    HRESULT _hr = get_CombineOperation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVolumeCombined::PutCombineOperation ( enum AgECrdnVolumeCombinedOperationType pRetVal ) {
    HRESULT _hr = put_CombineOperation(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

int IAgCrdnVolumeCombined::GetConditionCount ( ) {
    int _result = 0;
    HRESULT _hr = get_ConditionCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgCrdnVolumeCombined::GetAllConditions ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetAllConditions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IAgCrdnVolumeCombined::SetAllConditions ( SAFEARRAY * * Conditions ) {
    HRESULT _hr = raw_SetAllConditions(Conditions);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgCrdnVolumeCombined::SetCondition ( struct IAgCrdnVolume * Ref, int Pos ) {
    HRESULT _hr = raw_SetCondition(Ref, Pos);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnVolumePtr IAgCrdnVolumeCombined::GetCondition ( int Pos ) {
    struct IAgCrdnVolume * _result = 0;
    HRESULT _hr = raw_GetCondition(Pos, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumePtr(_result, false);
}

HRESULT IAgCrdnVolumeCombined::RemoveCondition ( int Pos ) {
    HRESULT _hr = raw_RemoveCondition(Pos);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IAgCrdnVolumeFromCalc wrapper method implementations
//

enum AgECrdnConditionThresholdOption IAgCrdnVolumeFromCalc::GetOperation ( ) {
    enum AgECrdnConditionThresholdOption _result;
    HRESULT _hr = get_Operation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVolumeFromCalc::PutOperation ( enum AgECrdnConditionThresholdOption pRetVal ) {
    HRESULT _hr = put_Operation(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

STKUtil::IAgQuantityPtr IAgCrdnVolumeFromCalc::GetMinimum ( ) {
    struct STKUtil::IAgQuantity * _result = 0;
    HRESULT _hr = raw_GetMinimum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgQuantityPtr(_result, false);
}

HRESULT IAgCrdnVolumeFromCalc::SetMinimum ( struct STKUtil::IAgQuantity * Value ) {
    HRESULT _hr = raw_SetMinimum(Value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

STKUtil::IAgQuantityPtr IAgCrdnVolumeFromCalc::GetMaximum ( ) {
    struct STKUtil::IAgQuantity * _result = 0;
    HRESULT _hr = raw_GetMaximum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgQuantityPtr(_result, false);
}

HRESULT IAgCrdnVolumeFromCalc::SetMaximum ( struct STKUtil::IAgQuantity * Value ) {
    HRESULT _hr = raw_SetMaximum(Value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgCrdnVolumeFromCalc::Set ( struct STKUtil::IAgQuantity * Min, struct STKUtil::IAgQuantity * Max ) {
    HRESULT _hr = raw_Set(Min, Max);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IAgCrdnVolumeFromCondition wrapper method implementations
//

IAgCrdnConditionPtr IAgCrdnVolumeFromCondition::GetCondition ( ) {
    struct IAgCrdnCondition * _result = 0;
    HRESULT _hr = get_Condition(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConditionPtr(_result, false);
}

void IAgCrdnVolumeFromCondition::PutCondition ( struct IAgCrdnCondition * ppRetVal ) {
    HRESULT _hr = put_Condition(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnVolumeFromCondition::GetUseCustomTimeLimits ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseCustomTimeLimits(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVolumeFromCondition::PutUseCustomTimeLimits ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseCustomTimeLimits(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnEventIntervalListPtr IAgCrdnVolumeFromCondition::GetCustomTimeLimits ( ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = get_CustomTimeLimits(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

void IAgCrdnVolumeFromCondition::PutCustomTimeLimits ( struct IAgCrdnEventIntervalList * ppRetVal ) {
    HRESULT _hr = put_CustomTimeLimits(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSamplingPtr IAgCrdnVolumeFromCondition::GetSampling ( ) {
    struct IAgCrdnSampling * _result = 0;
    HRESULT _hr = get_Sampling(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSamplingPtr(_result, false);
}

void IAgCrdnVolumeFromCondition::PutSampling ( struct IAgCrdnSampling * ppRetVal ) {
    HRESULT _hr = put_Sampling(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnConvergePtr IAgCrdnVolumeFromCondition::GetConvergence ( ) {
    struct IAgCrdnConverge * _result = 0;
    HRESULT _hr = get_Convergence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConvergePtr(_result, false);
}

void IAgCrdnVolumeFromCondition::PutConvergence ( struct IAgCrdnConverge * ppRetVal ) {
    HRESULT _hr = put_Convergence(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVolumeFromGrid wrapper method implementations
//

enum AgECrdnVolumeFromGridEdgeType IAgCrdnVolumeFromGrid::GetEdgeType ( ) {
    enum AgECrdnVolumeFromGridEdgeType _result;
    HRESULT _hr = get_EdgeType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVolumeFromGrid::PutEdgeType ( enum AgECrdnVolumeFromGridEdgeType pRetVal ) {
    HRESULT _hr = put_EdgeType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnVolumeGridPtr IAgCrdnVolumeFromGrid::GetVolumeGrid ( ) {
    struct IAgCrdnVolumeGrid * _result = 0;
    HRESULT _hr = get_VolumeGrid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumeGridPtr(_result, false);
}

void IAgCrdnVolumeFromGrid::PutVolumeGrid ( struct IAgCrdnVolumeGrid * ppRetVal ) {
    HRESULT _hr = put_VolumeGrid(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVolumeFromTimeSatisfaction wrapper method implementations
//

IAgCrdnEventIntervalListPtr IAgCrdnVolumeFromTimeSatisfaction::GetTimeSatisfaction ( ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = get_TimeSatisfaction(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

void IAgCrdnVolumeFromTimeSatisfaction::PutTimeSatisfaction ( struct IAgCrdnEventIntervalList * ppRetVal ) {
    HRESULT _hr = put_TimeSatisfaction(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVolumeGridBearingAlt wrapper method implementations
//

_bstr_t IAgCrdnVolumeGridBearingAlt::GetReferenceCentralBody ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ReferenceCentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnVolumeGridBearingAlt::PutReferenceCentralBody ( _bstr_t pRetVal ) {
    HRESULT _hr = put_ReferenceCentralBody(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnGridCoordinateDefinitionPtr IAgCrdnVolumeGridBearingAlt::GetAlongBearingCoordinates ( ) {
    struct IAgCrdnGridCoordinateDefinition * _result = 0;
    HRESULT _hr = get_AlongBearingCoordinates(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnGridCoordinateDefinitionPtr(_result, false);
}

IAgCrdnGridCoordinateDefinitionPtr IAgCrdnVolumeGridBearingAlt::GetCrossBearingCoordinates ( ) {
    struct IAgCrdnGridCoordinateDefinition * _result = 0;
    HRESULT _hr = get_CrossBearingCoordinates(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnGridCoordinateDefinitionPtr(_result, false);
}

IAgCrdnGridCoordinateDefinitionPtr IAgCrdnVolumeGridBearingAlt::GetAltitudeCoordinates ( ) {
    struct IAgCrdnGridCoordinateDefinition * _result = 0;
    HRESULT _hr = get_AltitudeCoordinates(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnGridCoordinateDefinitionPtr(_result, false);
}

VARIANT_BOOL IAgCrdnVolumeGridBearingAlt::GetAutoFitBounds ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AutoFitBounds(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVolumeGridBearingAlt::PutAutoFitBounds ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_AutoFitBounds(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnVolumeGridBearingAlt::GetBearingAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_BearingAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVolumeGridBearingAlt::PutBearingAngle ( double pRetVal ) {
    HRESULT _hr = put_BearingAngle(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

SAFEARRAY * IAgCrdnVolumeGridBearingAlt::GetReferenceLocation ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_ReferenceLocation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVolumeGridBearingAlt::PutReferenceLocation ( SAFEARRAY * ppRetVal ) {
    HRESULT _hr = put_ReferenceLocation(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVolumeGridCartesian wrapper method implementations
//

IAgCrdnSystemPtr IAgCrdnVolumeGridCartesian::GetReferenceSystem ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_ReferenceSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

void IAgCrdnVolumeGridCartesian::PutReferenceSystem ( struct IAgCrdnSystem * ppRetVal ) {
    HRESULT _hr = put_ReferenceSystem(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnGridCoordinateDefinitionPtr IAgCrdnVolumeGridCartesian::GetXCoordinates ( ) {
    struct IAgCrdnGridCoordinateDefinition * _result = 0;
    HRESULT _hr = get_XCoordinates(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnGridCoordinateDefinitionPtr(_result, false);
}

IAgCrdnGridCoordinateDefinitionPtr IAgCrdnVolumeGridCartesian::GetYCoordinates ( ) {
    struct IAgCrdnGridCoordinateDefinition * _result = 0;
    HRESULT _hr = get_YCoordinates(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnGridCoordinateDefinitionPtr(_result, false);
}

IAgCrdnGridCoordinateDefinitionPtr IAgCrdnVolumeGridCartesian::GetZCoordinates ( ) {
    struct IAgCrdnGridCoordinateDefinition * _result = 0;
    HRESULT _hr = get_ZCoordinates(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnGridCoordinateDefinitionPtr(_result, false);
}

//
// interface IAgCrdnVolumeGridConstrained wrapper method implementations
//

IAgCrdnVolumeGridPtr IAgCrdnVolumeGridConstrained::GetReferenceGrid ( ) {
    struct IAgCrdnVolumeGrid * _result = 0;
    HRESULT _hr = get_ReferenceGrid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumeGridPtr(_result, false);
}

void IAgCrdnVolumeGridConstrained::PutReferenceGrid ( struct IAgCrdnVolumeGrid * ppRetVal ) {
    HRESULT _hr = put_ReferenceGrid(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnVolumePtr IAgCrdnVolumeGridConstrained::GetConstraint ( ) {
    struct IAgCrdnVolume * _result = 0;
    HRESULT _hr = get_Constraint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumePtr(_result, false);
}

void IAgCrdnVolumeGridConstrained::PutConstraint ( struct IAgCrdnVolume * ppRetVal ) {
    HRESULT _hr = put_Constraint(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVolumeGridCylindrical wrapper method implementations
//

IAgCrdnSystemPtr IAgCrdnVolumeGridCylindrical::GetReferenceSystem ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_ReferenceSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

void IAgCrdnVolumeGridCylindrical::PutReferenceSystem ( struct IAgCrdnSystem * ppRetVal ) {
    HRESULT _hr = put_ReferenceSystem(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnGridCoordinateDefinitionPtr IAgCrdnVolumeGridCylindrical::GetThetaCoordinates ( ) {
    struct IAgCrdnGridCoordinateDefinition * _result = 0;
    HRESULT _hr = get_ThetaCoordinates(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnGridCoordinateDefinitionPtr(_result, false);
}

IAgCrdnGridCoordinateDefinitionPtr IAgCrdnVolumeGridCylindrical::GetRadiusCoordinates ( ) {
    struct IAgCrdnGridCoordinateDefinition * _result = 0;
    HRESULT _hr = get_RadiusCoordinates(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnGridCoordinateDefinitionPtr(_result, false);
}

IAgCrdnGridCoordinateDefinitionPtr IAgCrdnVolumeGridCylindrical::GetHeightCoordinates ( ) {
    struct IAgCrdnGridCoordinateDefinition * _result = 0;
    HRESULT _hr = get_HeightCoordinates(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnGridCoordinateDefinitionPtr(_result, false);
}

//
// interface IAgCrdnVolumeGridLatLonAlt wrapper method implementations
//

_bstr_t IAgCrdnVolumeGridLatLonAlt::GetReferenceCentralBody ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ReferenceCentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnVolumeGridLatLonAlt::PutReferenceCentralBody ( _bstr_t pRetVal ) {
    HRESULT _hr = put_ReferenceCentralBody(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnGridCoordinateDefinitionPtr IAgCrdnVolumeGridLatLonAlt::GetLatitudeCoordinates ( ) {
    struct IAgCrdnGridCoordinateDefinition * _result = 0;
    HRESULT _hr = get_LatitudeCoordinates(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnGridCoordinateDefinitionPtr(_result, false);
}

IAgCrdnGridCoordinateDefinitionPtr IAgCrdnVolumeGridLatLonAlt::GetLongitudeCoordinates ( ) {
    struct IAgCrdnGridCoordinateDefinition * _result = 0;
    HRESULT _hr = get_LongitudeCoordinates(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnGridCoordinateDefinitionPtr(_result, false);
}

IAgCrdnGridCoordinateDefinitionPtr IAgCrdnVolumeGridLatLonAlt::GetAltitudeCoordinates ( ) {
    struct IAgCrdnGridCoordinateDefinition * _result = 0;
    HRESULT _hr = get_AltitudeCoordinates(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnGridCoordinateDefinitionPtr(_result, false);
}

VARIANT_BOOL IAgCrdnVolumeGridLatLonAlt::GetAutoFitBounds ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AutoFitBounds(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVolumeGridLatLonAlt::PutAutoFitBounds ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_AutoFitBounds(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVolumeGridResult wrapper method implementations
//

_variant_t IAgCrdnVolumeGridResult::GetEpoch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Epoch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

int IAgCrdnVolumeGridResult::GetSizeI ( ) {
    int _result = 0;
    HRESULT _hr = get_SizeI(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

int IAgCrdnVolumeGridResult::GetSizeJ ( ) {
    int _result = 0;
    HRESULT _hr = get_SizeJ(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

int IAgCrdnVolumeGridResult::GetSizeK ( ) {
    int _result = 0;
    HRESULT _hr = get_SizeK(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgCrdnVolumeGridResult::GetVolumeMetricDataVector ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_VolumeMetricDataVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgCrdnVolumeGridResult::GetVolumeMetricPositionVector ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_VolumeMetricPositionVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgCrdnVolumeGridResult::GetVolumeMetricNativePositionVector ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_VolumeMetricNativePositionVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgCrdnVolumeGridResult::GetVolumeMetricGradientVector ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_VolumeMetricGradientVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCrdnVolumeGridSpherical wrapper method implementations
//

IAgCrdnSystemPtr IAgCrdnVolumeGridSpherical::GetReferenceSystem ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_ReferenceSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

void IAgCrdnVolumeGridSpherical::PutReferenceSystem ( struct IAgCrdnSystem * ppRetVal ) {
    HRESULT _hr = put_ReferenceSystem(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnGridCoordinateDefinitionPtr IAgCrdnVolumeGridSpherical::GetAzimuthCoordinates ( ) {
    struct IAgCrdnGridCoordinateDefinition * _result = 0;
    HRESULT _hr = get_AzimuthCoordinates(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnGridCoordinateDefinitionPtr(_result, false);
}

IAgCrdnGridCoordinateDefinitionPtr IAgCrdnVolumeGridSpherical::GetElevationCoordinates ( ) {
    struct IAgCrdnGridCoordinateDefinition * _result = 0;
    HRESULT _hr = get_ElevationCoordinates(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnGridCoordinateDefinitionPtr(_result, false);
}

IAgCrdnGridCoordinateDefinitionPtr IAgCrdnVolumeGridSpherical::GetRangeCoordinates ( ) {
    struct IAgCrdnGridCoordinateDefinition * _result = 0;
    HRESULT _hr = get_RangeCoordinates(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnGridCoordinateDefinitionPtr(_result, false);
}

//
// interface IAgCrdnVolumeInview wrapper method implementations
//

_variant_t IAgCrdnVolumeInview::GetConstraintObject ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_ConstraintObject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgCrdnVolumeInview::PutConstraintObject ( const _variant_t & pRetVal ) {
    HRESULT _hr = put_ConstraintObject(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnLightTimeDelayPtr IAgCrdnVolumeInview::GetLightTimeDelay ( ) {
    struct IAgCrdnLightTimeDelay * _result = 0;
    HRESULT _hr = get_LightTimeDelay(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnLightTimeDelayPtr(_result, false);
}

//
// interface IAgCrdnVolumeLighting wrapper method implementations
//

SAFEARRAY * IAgCrdnVolumeLighting::GetEclipsingBodies ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_EclipsingBodies(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVolumeLighting::PutEclipsingBodies ( SAFEARRAY * ppRetVal ) {
    HRESULT _hr = put_EclipsingBodies(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnVolumeLighting::GetUseObjectEclipsingBodies ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseObjectEclipsingBodies(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVolumeLighting::PutUseObjectEclipsingBodies ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseObjectEclipsingBodies(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnVolumeLightingConditionsType IAgCrdnVolumeLighting::GetLightingConditions ( ) {
    enum AgECrdnVolumeLightingConditionsType _result;
    HRESULT _hr = get_LightingConditions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVolumeLighting::PutLightingConditions ( enum AgECrdnVolumeLightingConditionsType pRetVal ) {
    HRESULT _hr = put_LightingConditions(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVolumeOverTime wrapper method implementations
//

enum AgECrdnVolumeOverTimeDurationType IAgCrdnVolumeOverTime::GetDurationType ( ) {
    enum AgECrdnVolumeOverTimeDurationType _result;
    HRESULT _hr = get_DurationType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVolumeOverTime::PutDurationType ( enum AgECrdnVolumeOverTimeDurationType pRetVal ) {
    HRESULT _hr = put_DurationType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnVolumePtr IAgCrdnVolumeOverTime::GetReferenceVolume ( ) {
    struct IAgCrdnVolume * _result = 0;
    HRESULT _hr = get_ReferenceVolume(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumePtr(_result, false);
}

void IAgCrdnVolumeOverTime::PutReferenceVolume ( struct IAgCrdnVolume * ppRetVal ) {
    HRESULT _hr = put_ReferenceVolume(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnEventIntervalListPtr IAgCrdnVolumeOverTime::GetReferenceIntervals ( ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = get_ReferenceIntervals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

void IAgCrdnVolumeOverTime::PutReferenceIntervals ( struct IAgCrdnEventIntervalList * ppRetVal ) {
    HRESULT _hr = put_ReferenceIntervals(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnVolumeOverTime::GetStartOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_StartOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVolumeOverTime::PutStartOffset ( double pRetVal ) {
    HRESULT _hr = put_StartOffset(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnVolumeOverTime::GetStopOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_StopOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVolumeOverTime::PutStopOffset ( double pRetVal ) {
    HRESULT _hr = put_StopOffset(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnTimeProperties wrapper method implementations
//

IAgCrdnIntervalCollectionPtr IAgCrdnTimeProperties::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

//
// interface IAgCrdnRefTo wrapper method implementations
//

_bstr_t IAgCrdnRefTo::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface IAgCrdnTemplate wrapper method implementations
//

_bstr_t IAgCrdnTemplate::GetClassName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ClassName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface IAgCrdnPointRefTo wrapper method implementations
//

HRESULT IAgCrdnPointRefTo::SetPath ( _bstr_t Path ) {
    HRESULT _hr = raw_SetPath(Path);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgCrdnPointRefTo::SetPoint ( struct IAgCrdnPoint * Point ) {
    HRESULT _hr = raw_SetPoint(Point);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnPointPtr IAgCrdnPointRefTo::GetPoint ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = raw_GetPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

VARIANT_BOOL IAgCrdnPointRefTo::HasCyclicDependency ( struct IAgCrdnPoint * Point ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_HasCyclicDependency(Point, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCrdnSystemRefTo wrapper method implementations
//

HRESULT IAgCrdnSystemRefTo::SetPath ( _bstr_t Path ) {
    HRESULT _hr = raw_SetPath(Path);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgCrdnSystemRefTo::SetSystem ( struct IAgCrdnSystem * System ) {
    HRESULT _hr = raw_SetSystem(System);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnSystemPtr IAgCrdnSystemRefTo::GetSystem ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = raw_GetSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

VARIANT_BOOL IAgCrdnSystemRefTo::HasCyclicDependency ( struct IAgCrdnSystem * System ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_HasCyclicDependency(System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCrdnCentralBody wrapper method implementations
//

_bstr_t IAgCrdnCentralBody::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface IAgCrdnCentralBodyRefTo wrapper method implementations
//

HRESULT IAgCrdnCentralBodyRefTo::SetPath ( _bstr_t Path ) {
    HRESULT _hr = raw_SetPath(Path);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgCrdnCentralBodyRefTo::SetCentralBody ( struct IAgCrdnCentralBody * CentralBody ) {
    HRESULT _hr = raw_SetCentralBody(CentralBody);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnCentralBodyPtr IAgCrdnCentralBodyRefTo::GetCentralBody ( ) {
    struct IAgCrdnCentralBody * _result = 0;
    HRESULT _hr = raw_GetCentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyPtr(_result, false);
}

//
// interface IAgCrdnAxesAttitudeFile wrapper method implementations
//

_bstr_t IAgCrdnAxesAttitudeFile::GetFilename ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Filename(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnAxesAttitudeFile::PutFilename ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Filename(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnAxesModelAttach wrapper method implementations
//

_bstr_t IAgCrdnAxesModelAttach::GetPointableElementName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_PointableElementName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnAxesModelAttach::PutPointableElementName ( _bstr_t pRetVal ) {
    HRESULT _hr = put_PointableElementName(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnAxesOnSurface wrapper method implementations
//

IAgCrdnCentralBodyRefToPtr IAgCrdnAxesOnSurface::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr IAgCrdnAxesOnSurface::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

VARIANT_BOOL IAgCrdnAxesOnSurface::GetUseMSL ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseMSL(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnAxesOnSurface::PutUseMSL ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseMSL(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnAxesTrajectory wrapper method implementations
//

IAgCrdnPointRefToPtr IAgCrdnAxesTrajectory::GetTrajectoryPoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_TrajectoryPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnSystemRefToPtr IAgCrdnAxesTrajectory::GetReferenceSystem ( ) {
    struct IAgCrdnSystemRefTo * _result = 0;
    HRESULT _hr = get_ReferenceSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemRefToPtr(_result, false);
}

enum AgECrdnTrajectoryAxesType IAgCrdnAxesTrajectory::GetTrajectoryAxesType ( ) {
    enum AgECrdnTrajectoryAxesType _result;
    HRESULT _hr = get_TrajectoryAxesType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnAxesTrajectory::PutTrajectoryAxesType ( enum AgECrdnTrajectoryAxesType pRetVal ) {
    HRESULT _hr = put_TrajectoryAxesType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnCentralBodyCollection wrapper method implementations
//

long IAgCrdnCentralBodyCollection::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t IAgCrdnCentralBodyCollection::GetItem ( long Index ) {
    BSTR _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

IUnknownPtr IAgCrdnCentralBodyCollection::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

VARIANT_BOOL IAgCrdnCentralBodyCollection::Add ( _bstr_t CentralBodyName ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Add(CentralBodyName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IAgCrdnCentralBodyCollection::Remove ( _bstr_t CentralBodyName ) {
    HRESULT _hr = raw_Remove(CentralBodyName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IAgCrdnAxesLagrangeLibration wrapper method implementations
//

IAgCrdnCentralBodyRefToPtr IAgCrdnAxesLagrangeLibration::GetPrimaryCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_PrimaryCentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

enum AgECrdnLagrangeLibrationPointType IAgCrdnAxesLagrangeLibration::GetPointType ( ) {
    enum AgECrdnLagrangeLibrationPointType _result;
    HRESULT _hr = get_PointType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnAxesLagrangeLibration::PutPointType ( enum AgECrdnLagrangeLibrationPointType pRetVal ) {
    HRESULT _hr = put_PointType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnCentralBodyCollectionPtr IAgCrdnAxesLagrangeLibration::GetSecondaryCentralBodies ( ) {
    struct IAgCrdnCentralBodyCollection * _result = 0;
    HRESULT _hr = get_SecondaryCentralBodies(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyCollectionPtr(_result, false);
}

//
// interface IAgCrdnAxesSamplingInterval wrapper method implementations
//

SAFEARRAY * IAgCrdnAxesSamplingInterval::GetTimes ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Times(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgCrdnAxesSamplingInterval::GetQuaternions ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Quaternions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgCrdnAxesSamplingInterval::GetVelocities ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Velocities(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_variant_t IAgCrdnAxesSamplingInterval::GetStart ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Start(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

_variant_t IAgCrdnAxesSamplingInterval::GetStop ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Stop(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface IAgCrdnAxesSamplingIntervalCollection wrapper method implementations
//

long IAgCrdnAxesSamplingIntervalCollection::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAxesSamplingIntervalPtr IAgCrdnAxesSamplingIntervalCollection::GetItem ( long Index ) {
    struct IAgCrdnAxesSamplingInterval * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesSamplingIntervalPtr(_result, false);
}

IUnknownPtr IAgCrdnAxesSamplingIntervalCollection::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface IAgCrdnAxesSamplingResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnAxesSamplingResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAxesSamplingIntervalCollectionPtr IAgCrdnAxesSamplingResult::GetIntervals ( ) {
    struct IAgCrdnAxesSamplingIntervalCollection * _result = 0;
    HRESULT _hr = get_Intervals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesSamplingIntervalCollectionPtr(_result, false);
}

//
// interface IAgCrdnAxesPlugin wrapper method implementations
//

_bstr_t IAgCrdnAxesPlugin::GetProgID ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ProgID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t IAgCrdnAxesPlugin::GetDisplayName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DisplayName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

SAFEARRAY * IAgCrdnAxesPlugin::GetAvailableProperties ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_AvailableProperties(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IAgCrdnAxesPlugin::Reset ( ) {
    HRESULT _hr = raw_Reset();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgCrdnAxesPlugin::SetProperty ( _bstr_t Name, _bstr_t Value ) {
    HRESULT _hr = raw_SetProperty(Name, Value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t IAgCrdnAxesPlugin::GetProperty ( _bstr_t Name ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetProperty(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface IAgCrdnPlaneQuadrant wrapper method implementations
//

IAgCrdnSystemRefToPtr IAgCrdnPlaneQuadrant::GetReferenceSystem ( ) {
    struct IAgCrdnSystemRefTo * _result = 0;
    HRESULT _hr = get_ReferenceSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemRefToPtr(_result, false);
}

enum AgECrdnQuadrantType IAgCrdnPlaneQuadrant::GetQuadrant ( ) {
    enum AgECrdnQuadrantType _result;
    HRESULT _hr = get_Quadrant(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnPlaneQuadrant::PutQuadrant ( enum AgECrdnQuadrantType pRetVal ) {
    HRESULT _hr = put_Quadrant(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnPlaneTrajectory wrapper method implementations
//

IAgCrdnPointRefToPtr IAgCrdnPlaneTrajectory::GetPoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_Point(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnSystemRefToPtr IAgCrdnPlaneTrajectory::GetReferenceSystem ( ) {
    struct IAgCrdnSystemRefTo * _result = 0;
    HRESULT _hr = get_ReferenceSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemRefToPtr(_result, false);
}

double IAgCrdnPlaneTrajectory::GetRotationOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_RotationOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnPlaneTrajectory::PutRotationOffset ( double pRetVal ) {
    HRESULT _hr = put_RotationOffset(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnPlaneTriad wrapper method implementations
//

IAgCrdnPointRefToPtr IAgCrdnPlaneTriad::GetPointA ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_PointA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr IAgCrdnPlaneTriad::GetPointB ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_PointB(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr IAgCrdnPlaneTriad::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

double IAgCrdnPlaneTriad::GetRotationOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_RotationOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnPlaneTriad::PutRotationOffset ( double pRetVal ) {
    HRESULT _hr = put_RotationOffset(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnPointBPlane wrapper method implementations
//

IAgCrdnCentralBodyRefToPtr IAgCrdnPointBPlane::GetTargetBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_TargetBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr IAgCrdnPointBPlane::GetTrajectory ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_Trajectory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

enum AgECrdnPointBPlaneType IAgCrdnPointBPlane::GetPointType ( ) {
    enum AgECrdnPointBPlaneType _result;
    HRESULT _hr = get_PointType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnPointBPlane::PutPointType ( enum AgECrdnPointBPlaneType pRetVal ) {
    HRESULT _hr = put_PointType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnDirectionType IAgCrdnPointBPlane::GetDirection ( ) {
    enum AgECrdnDirectionType _result;
    HRESULT _hr = get_Direction(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnPointBPlane::PutDirection ( enum AgECrdnDirectionType pRetVal ) {
    HRESULT _hr = put_Direction(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnPointFile wrapper method implementations
//

_bstr_t IAgCrdnPointFile::GetFilename ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Filename(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnPointFile::PutFilename ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Filename(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnPointFixedInSystem wrapper method implementations
//

IAgCrdnSystemRefToPtr IAgCrdnPointFixedInSystem::GetReference ( ) {
    struct IAgCrdnSystemRefTo * _result = 0;
    HRESULT _hr = get_Reference(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemRefToPtr(_result, false);
}

STKUtil::IAgPositionPtr IAgCrdnPointFixedInSystem::GetFixedPoint ( ) {
    struct STKUtil::IAgPosition * _result = 0;
    HRESULT _hr = get_FixedPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgPositionPtr(_result, false);
}

//
// interface IAgCrdnPointGlint wrapper method implementations
//

IAgCrdnCentralBodyRefToPtr IAgCrdnPointGlint::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr IAgCrdnPointGlint::GetSourcePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_SourcePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr IAgCrdnPointGlint::GetObserverPoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ObserverPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

//
// interface IAgCrdnPointOnSurface wrapper method implementations
//

IAgCrdnCentralBodyRefToPtr IAgCrdnPointOnSurface::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr IAgCrdnPointOnSurface::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

enum AgECrdnReferenceShapeType IAgCrdnPointOnSurface::GetReferenceShape ( ) {
    enum AgECrdnReferenceShapeType _result;
    HRESULT _hr = get_ReferenceShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnPointOnSurface::PutReferenceShape ( enum AgECrdnReferenceShapeType pRetVal ) {
    HRESULT _hr = put_ReferenceShape(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSurfaceType IAgCrdnPointOnSurface::GetSurfaceType ( ) {
    enum AgECrdnSurfaceType _result;
    HRESULT _hr = get_SurfaceType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnPointOnSurface::PutSurfaceType ( enum AgECrdnSurfaceType pRetVal ) {
    HRESULT _hr = put_SurfaceType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnPointModelAttach wrapper method implementations
//

_bstr_t IAgCrdnPointModelAttach::GetPointableElementName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_PointableElementName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnPointModelAttach::PutPointableElementName ( _bstr_t pRetVal ) {
    HRESULT _hr = put_PointableElementName(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnPointModelAttach::GetUseScale ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseScale(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnPointModelAttach::PutUseScale ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseScale(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnPointLagrangeLibration wrapper method implementations
//

IAgCrdnCentralBodyRefToPtr IAgCrdnPointLagrangeLibration::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

enum AgECrdnLagrangeLibrationPointType IAgCrdnPointLagrangeLibration::GetPointType ( ) {
    enum AgECrdnLagrangeLibrationPointType _result;
    HRESULT _hr = get_PointType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnPointLagrangeLibration::PutPointType ( enum AgECrdnLagrangeLibrationPointType pRetVal ) {
    HRESULT _hr = put_PointType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnCentralBodyCollectionPtr IAgCrdnPointLagrangeLibration::GetSecondaryCentralBodies ( ) {
    struct IAgCrdnCentralBodyCollection * _result = 0;
    HRESULT _hr = get_SecondaryCentralBodies(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyCollectionPtr(_result, false);
}

//
// interface IAgCrdnPointSamplingInterval wrapper method implementations
//

SAFEARRAY * IAgCrdnPointSamplingInterval::GetTimes ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Times(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgCrdnPointSamplingInterval::GetPositions ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Positions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgCrdnPointSamplingInterval::GetVelocities ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Velocities(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_variant_t IAgCrdnPointSamplingInterval::GetStart ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Start(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

_variant_t IAgCrdnPointSamplingInterval::GetStop ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Stop(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface IAgCrdnPointSamplingIntervalCollection wrapper method implementations
//

long IAgCrdnPointSamplingIntervalCollection::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointSamplingIntervalPtr IAgCrdnPointSamplingIntervalCollection::GetItem ( long Index ) {
    struct IAgCrdnPointSamplingInterval * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointSamplingIntervalPtr(_result, false);
}

IUnknownPtr IAgCrdnPointSamplingIntervalCollection::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface IAgCrdnPointSamplingResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnPointSamplingResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointSamplingIntervalCollectionPtr IAgCrdnPointSamplingResult::GetIntervals ( ) {
    struct IAgCrdnPointSamplingIntervalCollection * _result = 0;
    HRESULT _hr = get_Intervals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointSamplingIntervalCollectionPtr(_result, false);
}

//
// interface IAgCrdnPointCommonTasks wrapper method implementations
//

IAgCrdnPointFixedInSystemPtr IAgCrdnPointCommonTasks::CreateFixedInSystemCartographic ( struct IAgCrdnSystem * ReferenceSystem, const _variant_t & Latitude, const _variant_t & Longitude, double Altitude ) {
    struct IAgCrdnPointFixedInSystem * _result = 0;
    HRESULT _hr = raw_CreateFixedInSystemCartographic(ReferenceSystem, Latitude, Longitude, Altitude, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointFixedInSystemPtr(_result, false);
}

IAgCrdnPointFixedInSystemPtr IAgCrdnPointCommonTasks::CreateFixedInSystemCartesian ( struct IAgCrdnSystem * ReferenceSystem, double X, double Y, double Z ) {
    struct IAgCrdnPointFixedInSystem * _result = 0;
    HRESULT _hr = raw_CreateFixedInSystemCartesian(ReferenceSystem, X, Y, Z, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointFixedInSystemPtr(_result, false);
}

IAgCrdnPointSamplingResultPtr IAgCrdnPointCommonTasks::Sample ( struct IAgCrdnPoint * Point, struct IAgCrdnSystem * ReferenceSystem, SAFEARRAY * * Intervals, double MinStep, double MaxStep, const _variant_t & TargetRate ) {
    struct IAgCrdnPointSamplingResult * _result = 0;
    HRESULT _hr = raw_Sample(Point, ReferenceSystem, Intervals, MinStep, MaxStep, TargetRate, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointSamplingResultPtr(_result, false);
}

//
// interface IAgCrdnPointAtTimeInstant wrapper method implementations
//

IAgCrdnEventPtr IAgCrdnPointAtTimeInstant::GetReferenceTimeInstant ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_ReferenceTimeInstant(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

void IAgCrdnPointAtTimeInstant::PutReferenceTimeInstant ( struct IAgCrdnEvent * ppRetVal ) {
    HRESULT _hr = put_ReferenceTimeInstant(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPointPtr IAgCrdnPointAtTimeInstant::GetSourcePoint ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = get_SourcePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

void IAgCrdnPointAtTimeInstant::PutSourcePoint ( struct IAgCrdnPoint * ppRetVal ) {
    HRESULT _hr = put_SourcePoint(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSystemPtr IAgCrdnPointAtTimeInstant::GetReferenceSystem ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_ReferenceSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

void IAgCrdnPointAtTimeInstant::PutReferenceSystem ( struct IAgCrdnSystem * ppRetVal ) {
    HRESULT _hr = put_ReferenceSystem(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnPointPlugin wrapper method implementations
//

_bstr_t IAgCrdnPointPlugin::GetProgID ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ProgID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t IAgCrdnPointPlugin::GetDisplayName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DisplayName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

SAFEARRAY * IAgCrdnPointPlugin::GetAvailableProperties ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_AvailableProperties(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IAgCrdnPointPlugin::Reset ( ) {
    HRESULT _hr = raw_Reset();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgCrdnPointPlugin::SetProperty ( _bstr_t Name, _bstr_t Value ) {
    HRESULT _hr = raw_SetProperty(Name, Value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t IAgCrdnPointPlugin::GetProperty ( _bstr_t Name ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetProperty(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface IAgCrdnPointCBFixedOffset wrapper method implementations
//

_bstr_t IAgCrdnPointCBFixedOffset::GetCentralBody ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnPointCBFixedOffset::PutCentralBody ( _bstr_t pRetVal ) {
    HRESULT _hr = put_CentralBody(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnReferenceShapeType IAgCrdnPointCBFixedOffset::GetReferenceShape ( ) {
    enum AgECrdnReferenceShapeType _result;
    HRESULT _hr = get_ReferenceShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnPointCBFixedOffset::PutReferenceShape ( enum AgECrdnReferenceShapeType pRetVal ) {
    HRESULT _hr = put_ReferenceShape(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

STKUtil::IAgPositionPtr IAgCrdnPointCBFixedOffset::GetPosition ( ) {
    struct STKUtil::IAgPosition * _result = 0;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgPositionPtr(_result, false);
}

//
// interface IAgCrdnLLAPosition wrapper method implementations
//

double IAgCrdnLLAPosition::GetLatitude ( ) {
    double _result = 0;
    HRESULT _hr = get_Latitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnLLAPosition::PutLatitude ( double pRetVal ) {
    HRESULT _hr = put_Latitude(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnLLAPosition::GetLongitude ( ) {
    double _result = 0;
    HRESULT _hr = get_Longitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnLLAPosition::PutLongitude ( double pRetVal ) {
    HRESULT _hr = put_Longitude(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnLLAPosition::GetAltitude ( ) {
    double _result = 0;
    HRESULT _hr = get_Altitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnLLAPosition::PutAltitude ( double pRetVal ) {
    HRESULT _hr = put_Altitude(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnSystemOnSurface wrapper method implementations
//

IAgCrdnCentralBodyRefToPtr IAgCrdnSystemOnSurface::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

double IAgCrdnSystemOnSurface::GetAzimuthAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_AzimuthAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnSystemOnSurface::PutAzimuthAngle ( double pRetVal ) {
    HRESULT _hr = put_AzimuthAngle(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnSystemOnSurface::GetUseMSL ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseMSL(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnSystemOnSurface::PutUseMSL ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseMSL(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnLLAPositionPtr IAgCrdnSystemOnSurface::GetPosition ( ) {
    struct IAgCrdnLLAPosition * _result = 0;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnLLAPositionPtr(_result, false);
}

//
// interface IAgCrdnVectorApoapsis wrapper method implementations
//

IAgCrdnPointRefToPtr IAgCrdnVectorApoapsis::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnCentralBodyRefToPtr IAgCrdnVectorApoapsis::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

enum AgECrdnMeanElementTheory IAgCrdnVectorApoapsis::GetMeanElementType ( ) {
    enum AgECrdnMeanElementTheory _result;
    HRESULT _hr = get_MeanElementType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorApoapsis::PutMeanElementType ( enum AgECrdnMeanElementTheory pRetVal ) {
    HRESULT _hr = put_MeanElementType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVectorDisplacement wrapper method implementations
//

IAgCrdnPointRefToPtr IAgCrdnVectorDisplacement::GetOrigin ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_Origin(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr IAgCrdnVectorDisplacement::GetDestination ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_Destination(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

VARIANT_BOOL IAgCrdnVectorDisplacement::GetApparent ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Apparent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorDisplacement::PutApparent ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_Apparent(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnVectorDisplacement::GetIgnoreAbberation ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IgnoreAbberation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorDisplacement::PutIgnoreAbberation ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_IgnoreAbberation(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSignalSense IAgCrdnVectorDisplacement::GetSignalSense ( ) {
    enum AgECrdnSignalSense _result;
    HRESULT _hr = get_SignalSense(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorDisplacement::PutSignalSense ( enum AgECrdnSignalSense pRetVal ) {
    HRESULT _hr = put_SignalSense(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSystemRefToPtr IAgCrdnVectorDisplacement::GetReferenceSystem ( ) {
    struct IAgCrdnSystemRefTo * _result = 0;
    HRESULT _hr = get_ReferenceSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemRefToPtr(_result, false);
}

//
// interface IAgCrdnVectorModelAttach wrapper method implementations
//

_bstr_t IAgCrdnVectorModelAttach::GetPointableElementName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_PointableElementName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnVectorModelAttach::PutPointableElementName ( _bstr_t pRetVal ) {
    HRESULT _hr = put_PointableElementName(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVectorEccentricity wrapper method implementations
//

IAgCrdnCentralBodyRefToPtr IAgCrdnVectorEccentricity::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr IAgCrdnVectorEccentricity::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

enum AgECrdnMeanElementTheory IAgCrdnVectorEccentricity::GetMeanElementType ( ) {
    enum AgECrdnMeanElementTheory _result;
    HRESULT _hr = get_MeanElementType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorEccentricity::PutMeanElementType ( enum AgECrdnMeanElementTheory pRetVal ) {
    HRESULT _hr = put_MeanElementType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVectorLineOfNodes wrapper method implementations
//

IAgCrdnCentralBodyRefToPtr IAgCrdnVectorLineOfNodes::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr IAgCrdnVectorLineOfNodes::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

//
// interface IAgCrdnVectorOrbitAngularMomentum wrapper method implementations
//

IAgCrdnCentralBodyRefToPtr IAgCrdnVectorOrbitAngularMomentum::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr IAgCrdnVectorOrbitAngularMomentum::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

enum AgECrdnMeanElementTheory IAgCrdnVectorOrbitAngularMomentum::GetMeanElementType ( ) {
    enum AgECrdnMeanElementTheory _result;
    HRESULT _hr = get_MeanElementType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorOrbitAngularMomentum::PutMeanElementType ( enum AgECrdnMeanElementTheory pRetVal ) {
    HRESULT _hr = put_MeanElementType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVectorOrbitNormal wrapper method implementations
//

IAgCrdnCentralBodyRefToPtr IAgCrdnVectorOrbitNormal::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr IAgCrdnVectorOrbitNormal::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

enum AgECrdnMeanElementTheory IAgCrdnVectorOrbitNormal::GetMeanElementType ( ) {
    enum AgECrdnMeanElementTheory _result;
    HRESULT _hr = get_MeanElementType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorOrbitNormal::PutMeanElementType ( enum AgECrdnMeanElementTheory pRetVal ) {
    HRESULT _hr = put_MeanElementType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVectorPeriapsis wrapper method implementations
//

IAgCrdnCentralBodyRefToPtr IAgCrdnVectorPeriapsis::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr IAgCrdnVectorPeriapsis::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

enum AgECrdnMeanElementTheory IAgCrdnVectorPeriapsis::GetMeanElementType ( ) {
    enum AgECrdnMeanElementTheory _result;
    HRESULT _hr = get_MeanElementType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorPeriapsis::PutMeanElementType ( enum AgECrdnMeanElementTheory pRetVal ) {
    HRESULT _hr = put_MeanElementType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVectorDirectionToStar wrapper method implementations
//

_bstr_t IAgCrdnVectorDirectionToStar::GetSelectedStar ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_SelectedStar(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnVectorDirectionToStar::PutSelectedStar ( _bstr_t pRetVal ) {
    HRESULT _hr = put_SelectedStar(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVectorVelocityAcceleration wrapper method implementations
//

IAgCrdnSystemPtr IAgCrdnVectorVelocityAcceleration::GetReferenceSystem ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_ReferenceSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

void IAgCrdnVectorVelocityAcceleration::PutReferenceSystem ( struct IAgCrdnSystem * ppRetVal ) {
    HRESULT _hr = put_ReferenceSystem(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPointPtr IAgCrdnVectorVelocityAcceleration::GetPoint ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = get_Point(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

void IAgCrdnVectorVelocityAcceleration::PutPoint ( struct IAgCrdnPoint * ppRetVal ) {
    HRESULT _hr = put_Point(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnVectorVelocityAcceleration::GetDifferencingTimeStep ( ) {
    double _result = 0;
    HRESULT _hr = get_DifferencingTimeStep(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorVelocityAcceleration::PutDifferencingTimeStep ( double pRetVal ) {
    HRESULT _hr = put_DifferencingTimeStep(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVectorPlugin wrapper method implementations
//

_bstr_t IAgCrdnVectorPlugin::GetProgID ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ProgID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t IAgCrdnVectorPlugin::GetDisplayName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DisplayName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

SAFEARRAY * IAgCrdnVectorPlugin::GetAvailableProperties ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_AvailableProperties(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT IAgCrdnVectorPlugin::Reset ( ) {
    HRESULT _hr = raw_Reset();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgCrdnVectorPlugin::SetProperty ( _bstr_t Name, _bstr_t Value ) {
    HRESULT _hr = raw_SetProperty(Name, Value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t IAgCrdnVectorPlugin::GetProperty ( _bstr_t Name ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetProperty(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface IAgCrdnSystemFactory wrapper method implementations
//

IAgCrdnSystemPtr IAgCrdnSystemFactory::Create ( _bstr_t SystemName, _bstr_t Description, enum AgECrdnSystemType SystemType ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = raw_Create(SystemName, Description, SystemType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

VARIANT_BOOL IAgCrdnSystemFactory::IsTypeSupported ( enum AgECrdnSystemType Type ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCrdnPointFactory wrapper method implementations
//

IAgCrdnPointPtr IAgCrdnPointFactory::Create ( _bstr_t PointName, _bstr_t Description, enum AgECrdnPointType PointType ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = raw_Create(PointName, Description, PointType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

VARIANT_BOOL IAgCrdnPointFactory::IsTypeSupported ( enum AgECrdnPointType Type ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgCrdnPointFactory::GetAvailablePointPluginDisplayNames ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_AvailablePointPluginDisplayNames(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointPtr IAgCrdnPointFactory::CreatePointPluginFromDisplayName ( _bstr_t PointName, _bstr_t Description, _bstr_t DisplayName ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = raw_CreatePointPluginFromDisplayName(PointName, Description, DisplayName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

IAgCrdnPointPtr IAgCrdnPointFactory::CreatePointFixedOnCentralBody ( _bstr_t PointName, _bstr_t Description, const _variant_t & Longitude, const _variant_t & Latitude, double Altitude, enum AgECrdnReferenceShapeType ReferenceShape ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = raw_CreatePointFixedOnCentralBody(PointName, Description, Longitude, Latitude, Altitude, ReferenceShape, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

//
// interface IAgCrdnPointGroup wrapper method implementations
//

HRESULT IAgCrdnPointGroup::Remove ( _bstr_t PointName ) {
    HRESULT _hr = raw_Remove(PointName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnContextPtr IAgCrdnPointGroup::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

VARIANT_BOOL IAgCrdnPointGroup::Contains ( _bstr_t Name ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Contains(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IAgCrdnPointGroup::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointFactoryPtr IAgCrdnPointGroup::GetFactory ( ) {
    struct IAgCrdnPointFactory * _result = 0;
    HRESULT _hr = get_Factory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointFactoryPtr(_result, false);
}

IAgCrdnPointPtr IAgCrdnPointGroup::GetItem ( const _variant_t & IndexOrName ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

IUnknownPtr IAgCrdnPointGroup::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

IAgCrdnPointCommonTasksPtr IAgCrdnPointGroup::GetCommonTasks ( ) {
    struct IAgCrdnPointCommonTasks * _result = 0;
    HRESULT _hr = get_CommonTasks(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointCommonTasksPtr(_result, false);
}

//
// interface IAgCrdnWellKnownEarthSystems wrapper method implementations
//

IAgCrdnSystemPtr IAgCrdnWellKnownEarthSystems::GetFixed ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_Fixed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

IAgCrdnSystemPtr IAgCrdnWellKnownEarthSystems::GetICRF ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_ICRF(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

IAgCrdnSystemPtr IAgCrdnWellKnownEarthSystems::GetInertial ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_Inertial(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

//
// interface IAgCrdnWellKnownSunSystems wrapper method implementations
//

IAgCrdnSystemPtr IAgCrdnWellKnownSunSystems::GetFixed ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_Fixed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

IAgCrdnSystemPtr IAgCrdnWellKnownSunSystems::GetICRF ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_ICRF(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

IAgCrdnSystemPtr IAgCrdnWellKnownSunSystems::GetInertial ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_Inertial(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

IAgCrdnSystemPtr IAgCrdnWellKnownSunSystems::GetJ2000 ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_J2000(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

IAgCrdnSystemPtr IAgCrdnWellKnownSunSystems::GetBarycenter ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_Barycenter(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

//
// interface IAgCrdnWellKnownSystems wrapper method implementations
//

IAgCrdnWellKnownEarthSystemsPtr IAgCrdnWellKnownSystems::GetEarth ( ) {
    struct IAgCrdnWellKnownEarthSystems * _result = 0;
    HRESULT _hr = get_Earth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnWellKnownEarthSystemsPtr(_result, false);
}

IAgCrdnWellKnownSunSystemsPtr IAgCrdnWellKnownSystems::GetSun ( ) {
    struct IAgCrdnWellKnownSunSystems * _result = 0;
    HRESULT _hr = get_Sun(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnWellKnownSunSystemsPtr(_result, false);
}

//
// interface IAgCrdnMethodCallResult wrapper method implementations
//

VARIANT_BOOL IAgCrdnMethodCallResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnTypeInfo wrapper method implementations
//

_bstr_t _IAgCrdnTypeInfo::GetTypeDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_TypeDescription(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnTypeInfo::GetTypeName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_TypeName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnTypeInfo::GetShortTypeDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ShortTypeDescription(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface _IAgCrdnTemplate wrapper method implementations
//

VARIANT_BOOL _IAgCrdnTemplate::GetIsTemplate ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsTemplate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnTemplate::GetClassName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ClassName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface _IAgCrdnPointRefTo wrapper method implementations
//

_bstr_t _IAgCrdnPointRefTo::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT _IAgCrdnPointRefTo::SetPath ( _bstr_t Path ) {
    HRESULT _hr = raw_SetPath(Path);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnPointRefTo::SetPoint ( struct IAgCrdnPoint * Point ) {
    HRESULT _hr = raw_SetPoint(Point);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnPointPtr _IAgCrdnPointRefTo::GetPoint ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = raw_GetPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnPointRefTo::HasCyclicDependency ( struct IAgCrdnPoint * Point ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_HasCyclicDependency(Point, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnSystemRefTo wrapper method implementations
//

_bstr_t _IAgCrdnSystemRefTo::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT _IAgCrdnSystemRefTo::SetPath ( _bstr_t Path ) {
    HRESULT _hr = raw_SetPath(Path);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnSystemRefTo::SetSystem ( struct IAgCrdnSystem * System ) {
    HRESULT _hr = raw_SetSystem(System);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnSystemPtr _IAgCrdnSystemRefTo::GetSystem ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = raw_GetSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnSystemRefTo::HasCyclicDependency ( struct IAgCrdnSystem * System ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_HasCyclicDependency(System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnAxesLabels wrapper method implementations
//

_bstr_t _IAgCrdnAxesLabels::GetLabelX ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAxesLabels::PutLabelX ( _bstr_t pRetVal ) {
    HRESULT _hr = put_LabelX(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAxesLabels::GetLabelY ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAxesLabels::PutLabelY ( _bstr_t pRetVal ) {
    HRESULT _hr = put_LabelY(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAxesLabels::GetLabelZ ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelZ(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAxesLabels::PutLabelZ ( _bstr_t pRetVal ) {
    HRESULT _hr = put_LabelZ(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnPlaneLabels wrapper method implementations
//

_bstr_t _IAgCrdnPlaneLabels::GetXAxisLabel ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_XAxisLabel(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPlaneLabels::PutXAxisLabel ( _bstr_t pRetVal ) {
    HRESULT _hr = put_XAxisLabel(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnPlaneLabels::GetYAxisLabel ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_YAxisLabel(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPlaneLabels::PutYAxisLabel ( _bstr_t pRetVal ) {
    HRESULT _hr = put_YAxisLabel(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnPointCommonTasks wrapper method implementations
//

IAgCrdnPointFixedInSystemPtr _IAgCrdnPointCommonTasks::CreateFixedInSystemCartographic ( struct IAgCrdnSystem * ReferenceSystem, const _variant_t & Latitude, const _variant_t & Longitude, double Altitude ) {
    struct IAgCrdnPointFixedInSystem * _result = 0;
    HRESULT _hr = raw_CreateFixedInSystemCartographic(ReferenceSystem, Latitude, Longitude, Altitude, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointFixedInSystemPtr(_result, false);
}

IAgCrdnPointFixedInSystemPtr _IAgCrdnPointCommonTasks::CreateFixedInSystemCartesian ( struct IAgCrdnSystem * ReferenceSystem, double X, double Y, double Z ) {
    struct IAgCrdnPointFixedInSystem * _result = 0;
    HRESULT _hr = raw_CreateFixedInSystemCartesian(ReferenceSystem, X, Y, Z, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointFixedInSystemPtr(_result, false);
}

IAgCrdnPointSamplingResultPtr _IAgCrdnPointCommonTasks::Sample ( struct IAgCrdnPoint * Point, struct IAgCrdnSystem * ReferenceSystem, SAFEARRAY * * Intervals, double MinStep, double MaxStep, const _variant_t & TargetRate ) {
    struct IAgCrdnPointSamplingResult * _result = 0;
    HRESULT _hr = raw_Sample(Point, ReferenceSystem, Intervals, MinStep, MaxStep, TargetRate, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointSamplingResultPtr(_result, false);
}

//
// interface _IAgCrdnLLAPosition wrapper method implementations
//

double _IAgCrdnLLAPosition::GetLatitude ( ) {
    double _result = 0;
    HRESULT _hr = get_Latitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnLLAPosition::PutLatitude ( double pRetVal ) {
    HRESULT _hr = put_Latitude(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnLLAPosition::GetLongitude ( ) {
    double _result = 0;
    HRESULT _hr = get_Longitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnLLAPosition::PutLongitude ( double pRetVal ) {
    HRESULT _hr = put_Longitude(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnLLAPosition::GetAltitude ( ) {
    double _result = 0;
    HRESULT _hr = get_Altitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnLLAPosition::PutAltitude ( double pRetVal ) {
    HRESULT _hr = put_Altitude(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnSystemFactory wrapper method implementations
//

IAgCrdnSystemPtr _IAgCrdnSystemFactory::Create ( _bstr_t SystemName, _bstr_t Description, enum AgECrdnSystemType SystemType ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = raw_Create(SystemName, Description, SystemType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnSystemFactory::IsTypeSupported ( enum AgECrdnSystemType Type ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnPointFactory wrapper method implementations
//

IAgCrdnPointPtr _IAgCrdnPointFactory::Create ( _bstr_t PointName, _bstr_t Description, enum AgECrdnPointType PointType ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = raw_Create(PointName, Description, PointType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnPointFactory::IsTypeSupported ( enum AgECrdnPointType Type ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnPointFactory::GetAvailablePointPluginDisplayNames ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_AvailablePointPluginDisplayNames(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointPtr _IAgCrdnPointFactory::CreatePointPluginFromDisplayName ( _bstr_t PointName, _bstr_t Description, _bstr_t DisplayName ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = raw_CreatePointPluginFromDisplayName(PointName, Description, DisplayName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

IAgCrdnPointPtr _IAgCrdnPointFactory::CreatePointFixedOnCentralBody ( _bstr_t PointName, _bstr_t Description, const _variant_t & Longitude, const _variant_t & Latitude, double Altitude, enum AgECrdnReferenceShapeType ReferenceShape ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = raw_CreatePointFixedOnCentralBody(PointName, Description, Longitude, Latitude, Altitude, ReferenceShape, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

//
// interface _IAgCrdnWellKnownEarthSystems wrapper method implementations
//

IAgCrdnSystemPtr _IAgCrdnWellKnownEarthSystems::GetFixed ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_Fixed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

IAgCrdnSystemPtr _IAgCrdnWellKnownEarthSystems::GetICRF ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_ICRF(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

IAgCrdnSystemPtr _IAgCrdnWellKnownEarthSystems::GetInertial ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_Inertial(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

//
// interface _IAgCrdnWellKnownSunSystems wrapper method implementations
//

IAgCrdnSystemPtr _IAgCrdnWellKnownSunSystems::GetFixed ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_Fixed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

IAgCrdnSystemPtr _IAgCrdnWellKnownSunSystems::GetICRF ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_ICRF(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

IAgCrdnSystemPtr _IAgCrdnWellKnownSunSystems::GetInertial ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_Inertial(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

IAgCrdnSystemPtr _IAgCrdnWellKnownSunSystems::GetJ2000 ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_J2000(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

IAgCrdnSystemPtr _IAgCrdnWellKnownSunSystems::GetBarycenter ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_Barycenter(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

//
// interface _IAgCrdnWellKnownSystems wrapper method implementations
//

IAgCrdnWellKnownEarthSystemsPtr _IAgCrdnWellKnownSystems::GetEarth ( ) {
    struct IAgCrdnWellKnownEarthSystems * _result = 0;
    HRESULT _hr = get_Earth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnWellKnownEarthSystemsPtr(_result, false);
}

IAgCrdnWellKnownSunSystemsPtr _IAgCrdnWellKnownSystems::GetSun ( ) {
    struct IAgCrdnWellKnownSunSystems * _result = 0;
    HRESULT _hr = get_Sun(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnWellKnownSunSystemsPtr(_result, false);
}

//
// interface _IAgCrdnMethodCallResult wrapper method implementations
//

_variant_t _IAgCrdnMethodCallResult::GetAngleRate ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_AngleRate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

_variant_t _IAgCrdnMethodCallResult::GetAngle ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Angle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

STKUtil::IAgCartesian3VectorPtr _IAgCrdnMethodCallResult::GetVectorFrom ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_VectorFrom(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr _IAgCrdnMethodCallResult::GetVectorTo ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_VectorTo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr _IAgCrdnMethodCallResult::GetVectorAbout ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_VectorAbout(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr _IAgCrdnMethodCallResult::GetOriginPosition ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_OriginPosition(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr _IAgCrdnMethodCallResult::GetOriginVelocity ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_OriginVelocity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr _IAgCrdnMethodCallResult::GetXAxis ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_XAxis(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr _IAgCrdnMethodCallResult::GetXAxisRate ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_XAxisRate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr _IAgCrdnMethodCallResult::GetYAxis ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_YAxis(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr _IAgCrdnMethodCallResult::GetYAxisRate ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_YAxisRate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr _IAgCrdnMethodCallResult::GetPosition ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr _IAgCrdnMethodCallResult::GetVelocity ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_Velocity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgOrientationPtr _IAgCrdnMethodCallResult::GetOrientation ( ) {
    struct STKUtil::IAgOrientation * _result = 0;
    HRESULT _hr = get_Orientation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgOrientationPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr _IAgCrdnMethodCallResult::GetVector ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_Vector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

STKUtil::IAgCartesian3VectorPtr _IAgCrdnMethodCallResult::GetRate ( ) {
    struct STKUtil::IAgCartesian3Vector * _result = 0;
    HRESULT _hr = get_Rate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgCartesian3VectorPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnMethodCallResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnInterval wrapper method implementations
//

_variant_t _IAgCrdnInterval::GetStart ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Start(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

_variant_t _IAgCrdnInterval::GetStop ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Stop(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface _IAgCrdnCentralBody wrapper method implementations
//

_bstr_t _IAgCrdnCentralBody::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface _IAgCrdnCentralBodyRefTo wrapper method implementations
//

_bstr_t _IAgCrdnCentralBodyRefTo::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT _IAgCrdnCentralBodyRefTo::SetPath ( _bstr_t Path ) {
    HRESULT _hr = raw_SetPath(Path);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnCentralBodyRefTo::SetCentralBody ( struct IAgCrdnCentralBody * CentralBody ) {
    HRESULT _hr = raw_SetCentralBody(CentralBody);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnCentralBodyPtr _IAgCrdnCentralBodyRefTo::GetCentralBody ( ) {
    struct IAgCrdnCentralBody * _result = 0;
    HRESULT _hr = raw_GetCentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyPtr(_result, false);
}

//
// interface _IAgCrdnPointSamplingResult wrapper method implementations
//

VARIANT_BOOL _IAgCrdnPointSamplingResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointSamplingIntervalCollectionPtr _IAgCrdnPointSamplingResult::GetIntervals ( ) {
    struct IAgCrdnPointSamplingIntervalCollection * _result = 0;
    HRESULT _hr = get_Intervals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointSamplingIntervalCollectionPtr(_result, false);
}

//
// interface _IAgCrdnPointSamplingInterval wrapper method implementations
//

SAFEARRAY * _IAgCrdnPointSamplingInterval::GetTimes ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Times(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnPointSamplingInterval::GetPositions ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Positions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnPointSamplingInterval::GetVelocities ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Velocities(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_variant_t _IAgCrdnPointSamplingInterval::GetStart ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Start(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

_variant_t _IAgCrdnPointSamplingInterval::GetStop ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Stop(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface _IAgCrdnPointSamplingIntervalCollection wrapper method implementations
//

long _IAgCrdnPointSamplingIntervalCollection::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointSamplingIntervalPtr _IAgCrdnPointSamplingIntervalCollection::GetItem ( long Index ) {
    struct IAgCrdnPointSamplingInterval * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointSamplingIntervalPtr(_result, false);
}

IUnknownPtr _IAgCrdnPointSamplingIntervalCollection::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface _IAgCrdnAxesSamplingResult wrapper method implementations
//

VARIANT_BOOL _IAgCrdnAxesSamplingResult::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAxesSamplingIntervalCollectionPtr _IAgCrdnAxesSamplingResult::GetIntervals ( ) {
    struct IAgCrdnAxesSamplingIntervalCollection * _result = 0;
    HRESULT _hr = get_Intervals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesSamplingIntervalCollectionPtr(_result, false);
}

//
// interface _IAgCrdnAxesSamplingInterval wrapper method implementations
//

SAFEARRAY * _IAgCrdnAxesSamplingInterval::GetTimes ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Times(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnAxesSamplingInterval::GetQuaternions ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Quaternions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnAxesSamplingInterval::GetVelocities ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Velocities(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_variant_t _IAgCrdnAxesSamplingInterval::GetStart ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Start(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

_variant_t _IAgCrdnAxesSamplingInterval::GetStop ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Stop(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface _IAgCrdnAxesSamplingIntervalCollection wrapper method implementations
//

long _IAgCrdnAxesSamplingIntervalCollection::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAxesSamplingIntervalPtr _IAgCrdnAxesSamplingIntervalCollection::GetItem ( long Index ) {
    struct IAgCrdnAxesSamplingInterval * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesSamplingIntervalPtr(_result, false);
}

IUnknownPtr _IAgCrdnAxesSamplingIntervalCollection::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface IAgCrdnVector wrapper method implementations
//

enum AgECrdnVectorType IAgCrdnVector::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr IAgCrdnVector::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr IAgCrdnVector::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

//
// interface IAgCrdnAxes wrapper method implementations
//

enum AgECrdnAxesType IAgCrdnAxes::GetType ( ) {
    enum AgECrdnAxesType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAxesFindInAxesWithRateResultPtr IAgCrdnAxes::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesResultPtr IAgCrdnAxes::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesResultPtr(_result, false);
}

IAgCrdnAxesLabelsPtr IAgCrdnAxes::GetLabels ( ) {
    struct IAgCrdnAxesLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesLabelsPtr(_result, false);
}

IAgCrdnVectorPtr IAgCrdnAxes::GetX ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_X(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnVectorPtr IAgCrdnAxes::GetY ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_Y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnVectorPtr IAgCrdnAxes::GetZ ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_Z(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnAxesTransformResultPtr IAgCrdnAxes::Transform ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_Transform(Epoch, OutputAxes, VectorInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr IAgCrdnAxes::TransformWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes, struct STKUtil::IAgCartesian3Vector * RateInMyAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformWithRate(Epoch, OutputAxes, VectorInMyAxes, RateInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

//
// interface IAgCrdnAngle wrapper method implementations
//

enum AgECrdnAngleType IAgCrdnAngle::GetType ( ) {
    enum AgECrdnAngleType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAngleFindAngleResultPtr IAgCrdnAngle::FindAngle ( const _variant_t & Epoch ) {
    struct IAgCrdnAngleFindAngleResult * _result = 0;
    HRESULT _hr = raw_FindAngle(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindAngleResultPtr(_result, false);
}

IAgCrdnAngleFindAngleWithRateResultPtr IAgCrdnAngle::FindAngleWithRate ( const _variant_t & Epoch ) {
    struct IAgCrdnAngleFindAngleWithRateResult * _result = 0;
    HRESULT _hr = raw_FindAngleWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindAngleWithRateResultPtr(_result, false);
}

IAgCrdnAngleFindResultPtr IAgCrdnAngle::FindCoordinates ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAngleFindResult * _result = 0;
    HRESULT _hr = raw_FindCoordinates(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindResultPtr(_result, false);
}

IAgCrdnAngleFindWithRateResultPtr IAgCrdnAngle::FindCoordinatesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAngleFindWithRateResult * _result = 0;
    HRESULT _hr = raw_FindCoordinatesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindWithRateResultPtr(_result, false);
}

//
// interface IAgCrdnPlane wrapper method implementations
//

enum AgECrdnPlaneType IAgCrdnPlane::GetType ( ) {
    enum AgECrdnPlaneType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPlaneFindInAxesResultPtr IAgCrdnPlane::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnPlaneFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInAxesResultPtr(_result, false);
}

IAgCrdnPlaneFindInAxesWithRateResultPtr IAgCrdnPlane::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnPlaneFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnPlaneFindInSystemResultPtr IAgCrdnPlane::FindInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPlaneFindInSystemResult * _result = 0;
    HRESULT _hr = raw_FindInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInSystemResultPtr(_result, false);
}

IAgCrdnPlaneFindInSystemWithRateResultPtr IAgCrdnPlane::FindInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPlaneFindInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPlaneLabelsPtr IAgCrdnPlane::GetLabels ( ) {
    struct IAgCrdnPlaneLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneLabelsPtr(_result, false);
}

//
// interface IAgCrdnCalcScalarAngle wrapper method implementations
//

IAgCrdnAnglePtr IAgCrdnCalcScalarAngle::GetInputAngle ( ) {
    struct IAgCrdnAngle * _result = 0;
    HRESULT _hr = get_InputAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAnglePtr(_result, false);
}

void IAgCrdnCalcScalarAngle::PutInputAngle ( struct IAgCrdnAngle * ppRetVal ) {
    HRESULT _hr = put_InputAngle(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnCalcScalarVectorMagnitude wrapper method implementations
//

IAgCrdnVectorPtr IAgCrdnCalcScalarVectorMagnitude::GetInputVector ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_InputVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

void IAgCrdnCalcScalarVectorMagnitude::PutInputVector ( struct IAgCrdnVector * ppRetVal ) {
    HRESULT _hr = put_InputVector(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnParameterSetAttitude wrapper method implementations
//

IAgCrdnAxesPtr IAgCrdnParameterSetAttitude::GetAxes ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_Axes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

void IAgCrdnParameterSetAttitude::PutAxes ( struct IAgCrdnAxes * ppRetVal ) {
    HRESULT _hr = put_Axes(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnAxesPtr IAgCrdnParameterSetAttitude::GetReferenceAxes ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

void IAgCrdnParameterSetAttitude::PutReferenceAxes ( struct IAgCrdnAxes * ppRetVal ) {
    HRESULT _hr = put_ReferenceAxes(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnParameterSetVector wrapper method implementations
//

IAgCrdnVectorPtr IAgCrdnParameterSetVector::GetVector ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_Vector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

void IAgCrdnParameterSetVector::PutVector ( struct IAgCrdnVector * ppRetVal ) {
    HRESULT _hr = put_Vector(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnAxesPtr IAgCrdnParameterSetVector::GetReferenceAxes ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

void IAgCrdnParameterSetVector::PutReferenceAxes ( struct IAgCrdnAxes * ppRetVal ) {
    HRESULT _hr = put_ReferenceAxes(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVectorRefTo wrapper method implementations
//

HRESULT IAgCrdnVectorRefTo::SetPath ( _bstr_t Path ) {
    HRESULT _hr = raw_SetPath(Path);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgCrdnVectorRefTo::SetVector ( struct IAgCrdnVector * Vector ) {
    HRESULT _hr = raw_SetVector(Vector);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnVectorPtr IAgCrdnVectorRefTo::GetVector ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = raw_GetVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

VARIANT_BOOL IAgCrdnVectorRefTo::HasCyclicDependency ( struct IAgCrdnVector * Vector ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_HasCyclicDependency(Vector, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCrdnAxesRefTo wrapper method implementations
//

HRESULT IAgCrdnAxesRefTo::SetPath ( _bstr_t Path ) {
    HRESULT _hr = raw_SetPath(Path);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgCrdnAxesRefTo::SetAxes ( struct IAgCrdnAxes * Axes ) {
    HRESULT _hr = raw_SetAxes(Axes);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnAxesPtr IAgCrdnAxesRefTo::GetAxes ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = raw_GetAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

VARIANT_BOOL IAgCrdnAxesRefTo::HasCyclicDependency ( struct IAgCrdnAxes * Axes ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_HasCyclicDependency(Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCrdnAngleRefTo wrapper method implementations
//

HRESULT IAgCrdnAngleRefTo::SetPath ( _bstr_t Path ) {
    HRESULT _hr = raw_SetPath(Path);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgCrdnAngleRefTo::SetAngle ( struct IAgCrdnAngle * Angle ) {
    HRESULT _hr = raw_SetAngle(Angle);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnAnglePtr IAgCrdnAngleRefTo::GetAngle ( ) {
    struct IAgCrdnAngle * _result = 0;
    HRESULT _hr = raw_GetAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAnglePtr(_result, false);
}

VARIANT_BOOL IAgCrdnAngleRefTo::HasCyclicDependency ( struct IAgCrdnAngle * Angle ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_HasCyclicDependency(Angle, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCrdnPlaneRefTo wrapper method implementations
//

HRESULT IAgCrdnPlaneRefTo::SetPath ( _bstr_t Path ) {
    HRESULT _hr = raw_SetPath(Path);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgCrdnPlaneRefTo::SetPlane ( struct IAgCrdnPlane * Plane ) {
    HRESULT _hr = raw_SetPlane(Plane);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnPlanePtr IAgCrdnPlaneRefTo::GetPlane ( ) {
    struct IAgCrdnPlane * _result = 0;
    HRESULT _hr = raw_GetPlane(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlanePtr(_result, false);
}

VARIANT_BOOL IAgCrdnPlaneRefTo::HasCyclicDependency ( struct IAgCrdnPlane * Plane ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_HasCyclicDependency(Plane, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCrdnAxesAlignedAndConstrained wrapper method implementations
//

IAgCrdnVectorRefToPtr IAgCrdnAxesAlignedAndConstrained::GetAlignmentReferenceVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_AlignmentReferenceVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnVectorRefToPtr IAgCrdnAxesAlignedAndConstrained::GetConstraintReferenceVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_ConstraintReferenceVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

STKUtil::IAgDirectionPtr IAgCrdnAxesAlignedAndConstrained::GetAlignmentDirection ( ) {
    struct STKUtil::IAgDirection * _result = 0;
    HRESULT _hr = get_AlignmentDirection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgDirectionPtr(_result, false);
}

STKUtil::IAgDirectionPtr IAgCrdnAxesAlignedAndConstrained::GetConstraintDirection ( ) {
    struct STKUtil::IAgDirection * _result = 0;
    HRESULT _hr = get_ConstraintDirection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgDirectionPtr(_result, false);
}

//
// interface IAgCrdnAxesAngularOffset wrapper method implementations
//

IAgCrdnVectorRefToPtr IAgCrdnAxesAngularOffset::GetSpinVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_SpinVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnAngleRefToPtr IAgCrdnAxesAngularOffset::GetRotationAngle ( ) {
    struct IAgCrdnAngleRefTo * _result = 0;
    HRESULT _hr = get_RotationAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleRefToPtr(_result, false);
}

IAgCrdnAxesRefToPtr IAgCrdnAxesAngularOffset::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

double IAgCrdnAxesAngularOffset::GetFixedOffsetAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_FixedOffsetAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnAxesAngularOffset::PutFixedOffsetAngle ( double pRetVal ) {
    HRESULT _hr = put_FixedOffsetAngle(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnAxesFixedAtEpoch wrapper method implementations
//

IAgCrdnAxesRefToPtr IAgCrdnAxesFixedAtEpoch::GetSourceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_SourceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

IAgCrdnAxesRefToPtr IAgCrdnAxesFixedAtEpoch::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

_variant_t IAgCrdnAxesFixedAtEpoch::GetEpoch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Epoch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgCrdnAxesFixedAtEpoch::PutEpoch ( const _variant_t & pRetVal ) {
    HRESULT _hr = put_Epoch(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnAxesBPlane wrapper method implementations
//

IAgCrdnPointRefToPtr IAgCrdnAxesBPlane::GetTrajectory ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_Trajectory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnVectorRefToPtr IAgCrdnAxesBPlane::GetReferenceVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_ReferenceVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnCentralBodyRefToPtr IAgCrdnAxesBPlane::GetTargetBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_TargetBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

enum AgECrdnDirectionType IAgCrdnAxesBPlane::GetDirection ( ) {
    enum AgECrdnDirectionType _result;
    HRESULT _hr = get_Direction(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnAxesBPlane::PutDirection ( enum AgECrdnDirectionType pRetVal ) {
    HRESULT _hr = put_Direction(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnAxesCustomScript wrapper method implementations
//

IAgCrdnAxesRefToPtr IAgCrdnAxesCustomScript::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

_bstr_t IAgCrdnAxesCustomScript::GetFilename ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Filename(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnAxesCustomScript::PutFilename ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Filename(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnAxesFixed wrapper method implementations
//

IAgCrdnAxesRefToPtr IAgCrdnAxesFixed::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

STKUtil::IAgOrientationPtr IAgCrdnAxesFixed::GetFixedOrientation ( ) {
    struct STKUtil::IAgOrientation * _result = 0;
    HRESULT _hr = get_FixedOrientation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgOrientationPtr(_result, false);
}

//
// interface IAgCrdnAxesSpinning wrapper method implementations
//

IAgCrdnVectorRefToPtr IAgCrdnAxesSpinning::GetSpinVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_SpinVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnAxesRefToPtr IAgCrdnAxesSpinning::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

_variant_t IAgCrdnAxesSpinning::GetEpoch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Epoch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgCrdnAxesSpinning::PutEpoch ( const _variant_t & pRetVal ) {
    HRESULT _hr = put_Epoch(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnAxesSpinning::GetInitialOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_InitialOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnAxesSpinning::PutInitialOffset ( double pRetVal ) {
    HRESULT _hr = put_InitialOffset(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnAxesSpinning::GetSpinRate ( ) {
    double _result = 0;
    HRESULT _hr = get_SpinRate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnAxesSpinning::PutSpinRate ( double pRetVal ) {
    HRESULT _hr = put_SpinRate(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnAxesCommonTasks wrapper method implementations
//

IAgCrdnAxesFixedPtr IAgCrdnAxesCommonTasks::CreateTopocentricAxesQuaternion ( struct IAgCrdnPoint * OriginPoint, double QX, double QY, double QZ, double QS ) {
    struct IAgCrdnAxesFixed * _result = 0;
    HRESULT _hr = raw_CreateTopocentricAxesQuaternion(OriginPoint, QX, QY, QZ, QS, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFixedPtr(_result, false);
}

IAgCrdnAxesFixedPtr IAgCrdnAxesCommonTasks::CreateTopocentricAxesEulerAngles ( struct IAgCrdnPoint * OriginPoint, enum STKUtil::AgEEulerOrientationSequence Sequence, const _variant_t & A, const _variant_t & B, const _variant_t & C ) {
    struct IAgCrdnAxesFixed * _result = 0;
    HRESULT _hr = raw_CreateTopocentricAxesEulerAngles(OriginPoint, Sequence, A, B, C, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFixedPtr(_result, false);
}

IAgCrdnAxesFixedPtr IAgCrdnAxesCommonTasks::CreateFixed ( struct IAgCrdnAxes * ReferenceAxes ) {
    struct IAgCrdnAxesFixed * _result = 0;
    HRESULT _hr = raw_CreateFixed(ReferenceAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFixedPtr(_result, false);
}

IAgCrdnAxesSamplingResultPtr IAgCrdnAxesCommonTasks::Sample ( struct IAgCrdnAxes * Axes, struct IAgCrdnAxes * ReferenceAxes, SAFEARRAY * * Intervals, double MinStep, double MaxStep, const _variant_t & TargetRate ) {
    struct IAgCrdnAxesSamplingResult * _result = 0;
    HRESULT _hr = raw_Sample(Axes, ReferenceAxes, Intervals, MinStep, MaxStep, TargetRate, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesSamplingResultPtr(_result, false);
}

//
// interface IAgCrdnAxesAtTimeInstant wrapper method implementations
//

IAgCrdnEventPtr IAgCrdnAxesAtTimeInstant::GetReferenceTimeInstant ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_ReferenceTimeInstant(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

void IAgCrdnAxesAtTimeInstant::PutReferenceTimeInstant ( struct IAgCrdnEvent * ppRetVal ) {
    HRESULT _hr = put_ReferenceTimeInstant(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnAxesPtr IAgCrdnAxesAtTimeInstant::GetSourceAxes ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_SourceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

void IAgCrdnAxesAtTimeInstant::PutSourceAxes ( struct IAgCrdnAxes * ppRetVal ) {
    HRESULT _hr = put_SourceAxes(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnAxesPtr IAgCrdnAxesAtTimeInstant::GetReferenceAxes ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

void IAgCrdnAxesAtTimeInstant::PutReferenceAxes ( struct IAgCrdnAxes * ppRetVal ) {
    HRESULT _hr = put_ReferenceAxes(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnAngleBetweenVectors wrapper method implementations
//

IAgCrdnVectorRefToPtr IAgCrdnAngleBetweenVectors::GetFromVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_FromVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnVectorRefToPtr IAgCrdnAngleBetweenVectors::GetToVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_ToVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

//
// interface IAgCrdnAngleBetweenPlanes wrapper method implementations
//

IAgCrdnPlaneRefToPtr IAgCrdnAngleBetweenPlanes::GetFromPlane ( ) {
    struct IAgCrdnPlaneRefTo * _result = 0;
    HRESULT _hr = get_FromPlane(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneRefToPtr(_result, false);
}

IAgCrdnPlaneRefToPtr IAgCrdnAngleBetweenPlanes::GetToPlane ( ) {
    struct IAgCrdnPlaneRefTo * _result = 0;
    HRESULT _hr = get_ToPlane(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneRefToPtr(_result, false);
}

//
// interface IAgCrdnAngleDihedral wrapper method implementations
//

IAgCrdnVectorRefToPtr IAgCrdnAngleDihedral::GetFromVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_FromVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnVectorRefToPtr IAgCrdnAngleDihedral::GetToVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_ToVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnVectorRefToPtr IAgCrdnAngleDihedral::GetPoleAbout ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_PoleAbout(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

VARIANT_BOOL IAgCrdnAngleDihedral::GetCounterClockwiseRotation ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CounterClockwiseRotation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnAngleDihedral::PutCounterClockwiseRotation ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_CounterClockwiseRotation(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnAngleDihedral::GetSignedAngle ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_SignedAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnAngleDihedral::PutSignedAngle ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_SignedAngle(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnAngleRotation wrapper method implementations
//

IAgCrdnAxesRefToPtr IAgCrdnAngleRotation::GetFromAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_FromAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

IAgCrdnAxesRefToPtr IAgCrdnAngleRotation::GetToAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ToAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

enum AgECrdnDisplayAxisSelector IAgCrdnAngleRotation::GetReferenceDirection ( ) {
    enum AgECrdnDisplayAxisSelector _result;
    HRESULT _hr = get_ReferenceDirection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnAngleRotation::PutReferenceDirection ( enum AgECrdnDisplayAxisSelector pRetVal ) {
    HRESULT _hr = put_ReferenceDirection(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnAngleToPlane wrapper method implementations
//

IAgCrdnVectorRefToPtr IAgCrdnAngleToPlane::GetReferenceVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_ReferenceVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnPlaneRefToPtr IAgCrdnAngleToPlane::GetReferencePlane ( ) {
    struct IAgCrdnPlaneRefTo * _result = 0;
    HRESULT _hr = get_ReferencePlane(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneRefToPtr(_result, false);
}

enum AgECrdnSignedAngleType IAgCrdnAngleToPlane::GetSigned ( ) {
    enum AgECrdnSignedAngleType _result;
    HRESULT _hr = get_Signed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnAngleToPlane::PutSigned ( enum AgECrdnSignedAngleType pRetVal ) {
    HRESULT _hr = put_Signed(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnPlaneNormal wrapper method implementations
//

IAgCrdnVectorRefToPtr IAgCrdnPlaneNormal::GetNormalVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_NormalVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnVectorRefToPtr IAgCrdnPlaneNormal::GetReferenceVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_ReferenceVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr IAgCrdnPlaneNormal::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

//
// interface IAgCrdnPointGrazing wrapper method implementations
//

IAgCrdnCentralBodyRefToPtr IAgCrdnPointGrazing::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr IAgCrdnPointGrazing::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnVectorRefToPtr IAgCrdnPointGrazing::GetDirectionVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_DirectionVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

double IAgCrdnPointGrazing::GetAltitude ( ) {
    double _result = 0;
    HRESULT _hr = get_Altitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnPointGrazing::PutAltitude ( double pRetVal ) {
    HRESULT _hr = put_Altitude(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnPointCovarianceGrazing wrapper method implementations
//

IAgCrdnPointRefToPtr IAgCrdnPointCovarianceGrazing::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnVectorRefToPtr IAgCrdnPointCovarianceGrazing::GetDirectionVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_DirectionVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

_bstr_t IAgCrdnPointCovarianceGrazing::GetTargetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_TargetName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnPointCovarianceGrazing::PutTargetName ( _bstr_t pRetVal ) {
    HRESULT _hr = put_TargetName(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnPointCovarianceGrazing::GetDistance ( ) {
    double _result = 0;
    HRESULT _hr = get_Distance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnPointCovarianceGrazing::PutDistance ( double pRetVal ) {
    HRESULT _hr = put_Distance(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnPointCovarianceGrazing::GetProbability ( ) {
    double _result = 0;
    HRESULT _hr = get_Probability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnPointCovarianceGrazing::PutProbability ( double pRetVal ) {
    HRESULT _hr = put_Probability(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnPointCovarianceGrazing::GetScale ( ) {
    double _result = 0;
    HRESULT _hr = get_Scale(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnPointCovarianceGrazing::PutScale ( double pRetVal ) {
    HRESULT _hr = put_Scale(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnPointCovarianceGrazing::GetUseProbability ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseProbability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnPointCovarianceGrazing::PutUseProbability ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseProbability(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnPointPlaneIntersection wrapper method implementations
//

IAgCrdnVectorRefToPtr IAgCrdnPointPlaneIntersection::GetDirectionVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_DirectionVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnPlaneRefToPtr IAgCrdnPointPlaneIntersection::GetReferencePlane ( ) {
    struct IAgCrdnPlaneRefTo * _result = 0;
    HRESULT _hr = get_ReferencePlane(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr IAgCrdnPointPlaneIntersection::GetOriginPoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_OriginPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

//
// interface IAgCrdnPointPlaneProjection wrapper method implementations
//

IAgCrdnPointRefToPtr IAgCrdnPointPlaneProjection::GetSourcePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_SourcePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnPlaneRefToPtr IAgCrdnPointPlaneProjection::GetReferencePlane ( ) {
    struct IAgCrdnPlaneRefTo * _result = 0;
    HRESULT _hr = get_ReferencePlane(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneRefToPtr(_result, false);
}

//
// interface IAgCrdnPointCentBodyIntersect wrapper method implementations
//

_bstr_t IAgCrdnPointCentBodyIntersect::GetCentralBody ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnPointCentBodyIntersect::PutCentralBody ( _bstr_t pRetVal ) {
    HRESULT _hr = put_CentralBody(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPointPtr IAgCrdnPointCentBodyIntersect::GetReferencePoint ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

void IAgCrdnPointCentBodyIntersect::PutReferencePoint ( struct IAgCrdnPoint * ppRetVal ) {
    HRESULT _hr = put_ReferencePoint(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnVectorPtr IAgCrdnPointCentBodyIntersect::GetDirectionVector ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_DirectionVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

void IAgCrdnPointCentBodyIntersect::PutDirectionVector ( struct IAgCrdnVector * ppRetVal ) {
    HRESULT _hr = put_DirectionVector(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnIntersectionSurface IAgCrdnPointCentBodyIntersect::GetIntersectionSurface ( ) {
    enum AgECrdnIntersectionSurface _result;
    HRESULT _hr = get_IntersectionSurface(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnPointCentBodyIntersect::PutIntersectionSurface ( enum AgECrdnIntersectionSurface pRetVal ) {
    HRESULT _hr = put_IntersectionSurface(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnPointCentBodyIntersect::GetAltitude ( ) {
    double _result = 0;
    HRESULT _hr = get_Altitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnPointCentBodyIntersect::PutAltitude ( double pRetVal ) {
    HRESULT _hr = put_Altitude(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnPointCentBodyIntersect::GetUseRangeConstraint ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseRangeConstraint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnPointCentBodyIntersect::PutUseRangeConstraint ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseRangeConstraint(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnPointCentBodyIntersect::GetMinimumRange ( ) {
    double _result = 0;
    HRESULT _hr = get_MinimumRange(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnPointCentBodyIntersect::PutMinimumRange ( double pRetVal ) {
    HRESULT _hr = put_MinimumRange(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnPointCentBodyIntersect::GetMaximumRange ( ) {
    double _result = 0;
    HRESULT _hr = get_MaximumRange(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnPointCentBodyIntersect::PutMaximumRange ( double pRetVal ) {
    HRESULT _hr = put_MaximumRange(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnPointCentBodyIntersect::GetUseMinimumRange ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseMinimumRange(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnPointCentBodyIntersect::PutUseMinimumRange ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseMinimumRange(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnPointCentBodyIntersect::GetUseMaximumRange ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseMaximumRange(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnPointCentBodyIntersect::PutUseMaximumRange ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseMaximumRange(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgCrdnPointCentBodyIntersect::SetRange ( double Minimum, double Maximum ) {
    HRESULT _hr = raw_SetRange(Minimum, Maximum);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IAgCrdnSystemAssembled wrapper method implementations
//

IAgCrdnPointRefToPtr IAgCrdnSystemAssembled::GetOriginPoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_OriginPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnAxesRefToPtr IAgCrdnSystemAssembled::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

//
// interface IAgCrdnSystemCommonTasks wrapper method implementations
//

IAgCrdnSystemAssembledPtr IAgCrdnSystemCommonTasks::CreateEastNorthUpCartographic ( const _variant_t & Latitude, const _variant_t & Longitude, double Altitude ) {
    struct IAgCrdnSystemAssembled * _result = 0;
    HRESULT _hr = raw_CreateEastNorthUpCartographic(Latitude, Longitude, Altitude, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemAssembledPtr(_result, false);
}

IAgCrdnSystemAssembledPtr IAgCrdnSystemCommonTasks::CreateAssembled ( struct IAgCrdnPoint * OriginPoint, struct IAgCrdnAxes * ReferenceAxes ) {
    struct IAgCrdnSystemAssembled * _result = 0;
    HRESULT _hr = raw_CreateAssembled(OriginPoint, ReferenceAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemAssembledPtr(_result, false);
}

//
// interface IAgCrdnVectorAngleRate wrapper method implementations
//

IAgCrdnAngleRefToPtr IAgCrdnVectorAngleRate::GetAngle ( ) {
    struct IAgCrdnAngleRefTo * _result = 0;
    HRESULT _hr = get_Angle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleRefToPtr(_result, false);
}

double IAgCrdnVectorAngleRate::GetDifferencingTimeStep ( ) {
    double _result = 0;
    HRESULT _hr = get_DifferencingTimeStep(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorAngleRate::PutDifferencingTimeStep ( double pRetVal ) {
    HRESULT _hr = put_DifferencingTimeStep(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVectorFixedAtEpoch wrapper method implementations
//

_variant_t IAgCrdnVectorFixedAtEpoch::GetEpoch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Epoch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgCrdnVectorFixedAtEpoch::PutEpoch ( const _variant_t & pRetVal ) {
    HRESULT _hr = put_Epoch(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnVectorRefToPtr IAgCrdnVectorFixedAtEpoch::GetSourceVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_SourceVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnAxesRefToPtr IAgCrdnVectorFixedAtEpoch::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

//
// interface IAgCrdnVectorAngularVelocity wrapper method implementations
//

IAgCrdnAxesRefToPtr IAgCrdnVectorAngularVelocity::GetAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_Axes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

IAgCrdnAxesRefToPtr IAgCrdnVectorAngularVelocity::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

double IAgCrdnVectorAngularVelocity::GetDifferencingTimeStep ( ) {
    double _result = 0;
    HRESULT _hr = get_DifferencingTimeStep(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorAngularVelocity::PutDifferencingTimeStep ( double pRetVal ) {
    HRESULT _hr = put_DifferencingTimeStep(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVectorConing wrapper method implementations
//

IAgCrdnVectorRefToPtr IAgCrdnVectorConing::GetAboutVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_AboutVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnVectorRefToPtr IAgCrdnVectorConing::GetReferenceVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_ReferenceVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

double IAgCrdnVectorConing::GetStartClockAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_StartClockAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorConing::PutStartClockAngle ( double pRetVal ) {
    HRESULT _hr = put_StartClockAngle(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnVectorConing::GetStopClockAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_StopClockAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorConing::PutStopClockAngle ( double pRetVal ) {
    HRESULT _hr = put_StopClockAngle(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t IAgCrdnVectorConing::GetStartEpoch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_StartEpoch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void IAgCrdnVectorConing::PutStartEpoch ( const _variant_t & pRetVal ) {
    HRESULT _hr = put_StartEpoch(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnVectorConing::GetClockAngleRate ( ) {
    double _result = 0;
    HRESULT _hr = get_ClockAngleRate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorConing::PutClockAngleRate ( double pRetVal ) {
    HRESULT _hr = put_ClockAngleRate(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSweepMode IAgCrdnVectorConing::GetMode ( ) {
    enum AgECrdnSweepMode _result;
    HRESULT _hr = get_Mode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorConing::PutMode ( enum AgECrdnSweepMode pRetVal ) {
    HRESULT _hr = put_Mode(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVectorCross wrapper method implementations
//

IAgCrdnVectorRefToPtr IAgCrdnVectorCross::GetFrom ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_From(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnVectorRefToPtr IAgCrdnVectorCross::GetTo ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_To(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

VARIANT_BOOL IAgCrdnVectorCross::GetIsNormalized ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsNormalized(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorCross::PutIsNormalized ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_IsNormalized(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IAgCrdnVectorCross::GetDimension ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Dimension(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnVectorCross::PutDimension ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Dimension(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVectorCustomScript wrapper method implementations
//

IAgCrdnAxesRefToPtr IAgCrdnVectorCustomScript::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

_bstr_t IAgCrdnVectorCustomScript::GetScriptFile ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ScriptFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnVectorCustomScript::PutScriptFile ( _bstr_t pRetVal ) {
    HRESULT _hr = put_ScriptFile(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IAgCrdnVectorCustomScript::GetInitializationScriptFile ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_InitializationScriptFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnVectorCustomScript::PutInitializationScriptFile ( _bstr_t pRetVal ) {
    HRESULT _hr = put_InitializationScriptFile(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVectorDerivative wrapper method implementations
//

IAgCrdnVectorRefToPtr IAgCrdnVectorDerivative::GetVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_Vector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnAxesRefToPtr IAgCrdnVectorDerivative::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

double IAgCrdnVectorDerivative::GetDifferencingTimeStep ( ) {
    double _result = 0;
    HRESULT _hr = get_DifferencingTimeStep(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorDerivative::PutDifferencingTimeStep ( double pRetVal ) {
    HRESULT _hr = put_DifferencingTimeStep(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVectorTwoPlanesIntersection wrapper method implementations
//

IAgCrdnPlaneRefToPtr IAgCrdnVectorTwoPlanesIntersection::GetPlaneA ( ) {
    struct IAgCrdnPlaneRefTo * _result = 0;
    HRESULT _hr = get_PlaneA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneRefToPtr(_result, false);
}

IAgCrdnPlaneRefToPtr IAgCrdnVectorTwoPlanesIntersection::GetPlaneB ( ) {
    struct IAgCrdnPlaneRefTo * _result = 0;
    HRESULT _hr = get_PlaneB(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneRefToPtr(_result, false);
}

//
// interface IAgCrdnVectorProjection wrapper method implementations
//

IAgCrdnVectorRefToPtr IAgCrdnVectorProjection::GetSource ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_Source(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnPlaneRefToPtr IAgCrdnVectorProjection::GetReferencePlane ( ) {
    struct IAgCrdnPlaneRefTo * _result = 0;
    HRESULT _hr = get_ReferencePlane(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneRefToPtr(_result, false);
}

//
// interface IAgCrdnVectorScaled wrapper method implementations
//

IAgCrdnVectorRefToPtr IAgCrdnVectorScaled::GetReferenceVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_ReferenceVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

double IAgCrdnVectorScaled::GetScale ( ) {
    double _result = 0;
    HRESULT _hr = get_Scale(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorScaled::PutScale ( double pRetVal ) {
    HRESULT _hr = put_Scale(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnVectorScaled::GetIsNormalized ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsNormalized(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorScaled::PutIsNormalized ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_IsNormalized(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVectorFixedInAxes wrapper method implementations
//

IAgCrdnAxesRefToPtr IAgCrdnVectorFixedInAxes::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

STKUtil::IAgDirectionPtr IAgCrdnVectorFixedInAxes::GetDirection ( ) {
    struct STKUtil::IAgDirection * _result = 0;
    HRESULT _hr = get_Direction(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgDirectionPtr(_result, false);
}

//
// interface IAgCrdnVectorReflection wrapper method implementations
//

IAgCrdnVectorRefToPtr IAgCrdnVectorReflection::GetIncomingVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_IncomingVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

VARIANT_BOOL IAgCrdnVectorReflection::GetUseOppositeOfSelectedVector ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseOppositeOfSelectedVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorReflection::PutUseOppositeOfSelectedVector ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseOppositeOfSelectedVector(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnVectorRefToPtr IAgCrdnVectorReflection::GetNormalVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_NormalVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

VARIANT_BOOL IAgCrdnVectorReflection::GetAllowReflectionsOnBackside ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AllowReflectionsOnBackside(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorReflection::PutAllowReflectionsOnBackside ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_AllowReflectionsOnBackside(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnVectorReflection::GetScaleFactor ( ) {
    double _result = 0;
    HRESULT _hr = get_ScaleFactor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorReflection::PutScaleFactor ( double pRetVal ) {
    HRESULT _hr = put_ScaleFactor(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVectorFixedAtTimeInstant wrapper method implementations
//

IAgCrdnEventPtr IAgCrdnVectorFixedAtTimeInstant::GetReferenceTimeInstant ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_ReferenceTimeInstant(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

void IAgCrdnVectorFixedAtTimeInstant::PutReferenceTimeInstant ( struct IAgCrdnEvent * ppRetVal ) {
    HRESULT _hr = put_ReferenceTimeInstant(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnVectorPtr IAgCrdnVectorFixedAtTimeInstant::GetSourceVector ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_SourceVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

void IAgCrdnVectorFixedAtTimeInstant::PutSourceVector ( struct IAgCrdnVector * ppRetVal ) {
    HRESULT _hr = put_SourceVector(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnAxesPtr IAgCrdnVectorFixedAtTimeInstant::GetReferenceAxes ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

void IAgCrdnVectorFixedAtTimeInstant::PutReferenceAxes ( struct IAgCrdnAxes * ppRetVal ) {
    HRESULT _hr = put_ReferenceAxes(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVectorLinearCombination wrapper method implementations
//

IAgCrdnVectorPtr IAgCrdnVectorLinearCombination::GetVectorA ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_VectorA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

void IAgCrdnVectorLinearCombination::PutVectorA ( struct IAgCrdnVector * ppRetVal ) {
    HRESULT _hr = put_VectorA(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnVectorLinearCombination::GetScaleFactorA ( ) {
    double _result = 0;
    HRESULT _hr = get_ScaleFactorA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorLinearCombination::PutScaleFactorA ( double pRetVal ) {
    HRESULT _hr = put_ScaleFactorA(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnVectorLinearCombination::GetNormalizeVectorA ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_NormalizeVectorA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorLinearCombination::PutNormalizeVectorA ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_NormalizeVectorA(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnVectorPtr IAgCrdnVectorLinearCombination::GetVectorB ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_VectorB(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

void IAgCrdnVectorLinearCombination::PutVectorB ( struct IAgCrdnVector * ppRetVal ) {
    HRESULT _hr = put_VectorB(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnVectorLinearCombination::GetScaleFactorB ( ) {
    double _result = 0;
    HRESULT _hr = get_ScaleFactorB(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorLinearCombination::PutScaleFactorB ( double pRetVal ) {
    HRESULT _hr = put_ScaleFactorB(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnVectorLinearCombination::GetNormalizeVectorB ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_NormalizeVectorB(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorLinearCombination::PutNormalizeVectorB ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_NormalizeVectorB(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnDimensionInheritance IAgCrdnVectorLinearCombination::GetOutputDimensionInheritance ( ) {
    enum AgECrdnDimensionInheritance _result;
    HRESULT _hr = get_OutputDimensionInheritance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorLinearCombination::PutOutputDimensionInheritance ( enum AgECrdnDimensionInheritance pRetVal ) {
    HRESULT _hr = put_OutputDimensionInheritance(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IAgCrdnVectorLinearCombination::GetOutputDimension ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_OutputDimension(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnVectorLinearCombination::PutOutputDimension ( _bstr_t pRetVal ) {
    HRESULT _hr = put_OutputDimension(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVectorProjectAlongVector wrapper method implementations
//

IAgCrdnVectorPtr IAgCrdnVectorProjectAlongVector::GetSourceVector ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_SourceVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

void IAgCrdnVectorProjectAlongVector::PutSourceVector ( struct IAgCrdnVector * ppRetVal ) {
    HRESULT _hr = put_SourceVector(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnVectorPtr IAgCrdnVectorProjectAlongVector::GetAlongVector ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_AlongVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

void IAgCrdnVectorProjectAlongVector::PutAlongVector ( struct IAgCrdnVector * ppRetVal ) {
    HRESULT _hr = put_AlongVector(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVectorScalarLinearCombination wrapper method implementations
//

IAgCrdnVectorPtr IAgCrdnVectorScalarLinearCombination::GetVectorA ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_VectorA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

void IAgCrdnVectorScalarLinearCombination::PutVectorA ( struct IAgCrdnVector * ppRetVal ) {
    HRESULT _hr = put_VectorA(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnVectorScalarLinearCombination::GetScaleFactorA ( ) {
    double _result = 0;
    HRESULT _hr = get_ScaleFactorA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorScalarLinearCombination::PutScaleFactorA ( double pRetVal ) {
    HRESULT _hr = put_ScaleFactorA(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnVectorScalarLinearCombination::GetNormalizeVectorA ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_NormalizeVectorA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorScalarLinearCombination::PutNormalizeVectorA ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_NormalizeVectorA(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnVectorScalarLinearCombination::GetUseScaleFromScalarA ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseScaleFromScalarA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorScalarLinearCombination::PutUseScaleFromScalarA ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseScaleFromScalarA(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnVectorScalarLinearCombination::GetUseScaleFromScalarB ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseScaleFromScalarB(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorScalarLinearCombination::PutUseScaleFromScalarB ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseScaleFromScalarB(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnCalcScalarPtr IAgCrdnVectorScalarLinearCombination::GetScalarA ( ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = get_ScalarA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

void IAgCrdnVectorScalarLinearCombination::PutScalarA ( struct IAgCrdnCalcScalar * ppRetVal ) {
    HRESULT _hr = put_ScalarA(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnCalcScalarPtr IAgCrdnVectorScalarLinearCombination::GetScalarB ( ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = get_ScalarB(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

void IAgCrdnVectorScalarLinearCombination::PutScalarB ( struct IAgCrdnCalcScalar * ppRetVal ) {
    HRESULT _hr = put_ScalarB(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnVectorPtr IAgCrdnVectorScalarLinearCombination::GetVectorB ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_VectorB(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

void IAgCrdnVectorScalarLinearCombination::PutVectorB ( struct IAgCrdnVector * ppRetVal ) {
    HRESULT _hr = put_VectorB(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnVectorScalarLinearCombination::GetScaleFactorB ( ) {
    double _result = 0;
    HRESULT _hr = get_ScaleFactorB(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorScalarLinearCombination::PutScaleFactorB ( double pRetVal ) {
    HRESULT _hr = put_ScaleFactorB(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnVectorScalarLinearCombination::GetNormalizeVectorB ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_NormalizeVectorB(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorScalarLinearCombination::PutNormalizeVectorB ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_NormalizeVectorB(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnDimensionInheritance IAgCrdnVectorScalarLinearCombination::GetOutputDimensionInheritance ( ) {
    enum AgECrdnDimensionInheritance _result;
    HRESULT _hr = get_OutputDimensionInheritance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorScalarLinearCombination::PutOutputDimensionInheritance ( enum AgECrdnDimensionInheritance pRetVal ) {
    HRESULT _hr = put_OutputDimensionInheritance(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IAgCrdnVectorScalarLinearCombination::GetOutputDimension ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_OutputDimension(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnVectorScalarLinearCombination::PutOutputDimension ( _bstr_t pRetVal ) {
    HRESULT _hr = put_OutputDimension(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVectorScalarScaled wrapper method implementations
//

IAgCrdnVectorPtr IAgCrdnVectorScalarScaled::GetInputVector ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_InputVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

void IAgCrdnVectorScalarScaled::PutInputVector ( struct IAgCrdnVector * ppRetVal ) {
    HRESULT _hr = put_InputVector(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnCalcScalarPtr IAgCrdnVectorScalarScaled::GetInputScalar ( ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = get_InputScalar(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

void IAgCrdnVectorScalarScaled::PutInputScalar ( struct IAgCrdnCalcScalar * ppRetVal ) {
    HRESULT _hr = put_InputScalar(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double IAgCrdnVectorScalarScaled::GetScaleFactor ( ) {
    double _result = 0;
    HRESULT _hr = get_ScaleFactor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorScalarScaled::PutScaleFactor ( double pRetVal ) {
    HRESULT _hr = put_ScaleFactor(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL IAgCrdnVectorScalarScaled::GetNormalize ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Normalize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorScalarScaled::PutNormalize ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_Normalize(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnVectorScaledDimensionInheritance IAgCrdnVectorScalarScaled::GetDimensionInheritance ( ) {
    enum AgECrdnVectorScaledDimensionInheritance _result;
    HRESULT _hr = get_DimensionInheritance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnVectorScalarScaled::PutDimensionInheritance ( enum AgECrdnVectorScaledDimensionInheritance pRetVal ) {
    HRESULT _hr = put_DimensionInheritance(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IAgCrdnVectorScalarScaled::GetDimension ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Dimension(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdnVectorScalarScaled::PutDimension ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Dimension(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IAgCrdnVectorFactory wrapper method implementations
//

IAgCrdnVectorPtr IAgCrdnVectorFactory::Create ( _bstr_t VectorName, _bstr_t Description, enum AgECrdnVectorType VectorType ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = raw_Create(VectorName, Description, VectorType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

VARIANT_BOOL IAgCrdnVectorFactory::IsTypeSupported ( enum AgECrdnVectorType Type ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorDisplacementPtr IAgCrdnVectorFactory::CreateDisplacementVector ( _bstr_t VectorName, struct IAgCrdnPoint * OriginPoint, struct IAgCrdnPoint * DestPoint ) {
    struct IAgCrdnVectorDisplacement * _result = 0;
    HRESULT _hr = raw_CreateDisplacementVector(VectorName, OriginPoint, DestPoint, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorDisplacementPtr(_result, false);
}

SAFEARRAY * IAgCrdnVectorFactory::GetAvailableVectorPluginDisplayNames ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_AvailableVectorPluginDisplayNames(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorPtr IAgCrdnVectorFactory::CreateVectorPluginFromDisplayName ( _bstr_t VectorName, _bstr_t Description, _bstr_t DisplayName ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = raw_CreateVectorPluginFromDisplayName(VectorName, Description, DisplayName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnVectorCrossPtr IAgCrdnVectorFactory::CreateCrossProductVector ( _bstr_t VectorName, struct IAgCrdnVector * VectorA, struct IAgCrdnVector * VectorB ) {
    struct IAgCrdnVectorCross * _result = 0;
    HRESULT _hr = raw_CreateCrossProductVector(VectorName, VectorA, VectorB, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorCrossPtr(_result, false);
}

//
// interface IAgCrdnAxesFactory wrapper method implementations
//

IAgCrdnAxesPtr IAgCrdnAxesFactory::Create ( _bstr_t AxesName, _bstr_t Description, enum AgECrdnAxesType AxesType ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = raw_Create(AxesName, Description, AxesType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

VARIANT_BOOL IAgCrdnAxesFactory::IsTypeSupported ( enum AgECrdnAxesType Type ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * IAgCrdnAxesFactory::GetAvailableAxesPluginDisplayNames ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_AvailableAxesPluginDisplayNames(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAxesPtr IAgCrdnAxesFactory::CreateAxesPluginFromDisplayName ( _bstr_t AxesName, _bstr_t Description, _bstr_t DisplayName ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = raw_CreateAxesPluginFromDisplayName(AxesName, Description, DisplayName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

//
// interface IAgCrdnPlaneFactory wrapper method implementations
//

IAgCrdnPlanePtr IAgCrdnPlaneFactory::Create ( _bstr_t PlaneName, _bstr_t Description, enum AgECrdnPlaneType PlaneType ) {
    struct IAgCrdnPlane * _result = 0;
    HRESULT _hr = raw_Create(PlaneName, Description, PlaneType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlanePtr(_result, false);
}

VARIANT_BOOL IAgCrdnPlaneFactory::IsTypeSupported ( enum AgECrdnPlaneType Type ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCrdnAngleFactory wrapper method implementations
//

IAgCrdnAnglePtr IAgCrdnAngleFactory::Create ( _bstr_t AngleName, _bstr_t Description, enum AgECrdnAngleType AngleType ) {
    struct IAgCrdnAngle * _result = 0;
    HRESULT _hr = raw_Create(AngleName, Description, AngleType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAnglePtr(_result, false);
}

VARIANT_BOOL IAgCrdnAngleFactory::IsTypeSupported ( enum AgECrdnAngleType Type ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCrdnVectorGroup wrapper method implementations
//

HRESULT IAgCrdnVectorGroup::Remove ( _bstr_t VectorName ) {
    HRESULT _hr = raw_Remove(VectorName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnContextPtr IAgCrdnVectorGroup::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

VARIANT_BOOL IAgCrdnVectorGroup::Contains ( _bstr_t Name ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Contains(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IAgCrdnVectorGroup::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFactoryPtr IAgCrdnVectorGroup::GetFactory ( ) {
    struct IAgCrdnVectorFactory * _result = 0;
    HRESULT _hr = get_Factory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFactoryPtr(_result, false);
}

IAgCrdnVectorPtr IAgCrdnVectorGroup::GetItem ( const _variant_t & IndexOrName ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IUnknownPtr IAgCrdnVectorGroup::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface IAgCrdnAngleGroup wrapper method implementations
//

HRESULT IAgCrdnAngleGroup::Remove ( _bstr_t AngleName ) {
    HRESULT _hr = raw_Remove(AngleName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnContextPtr IAgCrdnAngleGroup::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

VARIANT_BOOL IAgCrdnAngleGroup::Contains ( _bstr_t Name ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Contains(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IAgCrdnAngleGroup::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAngleFactoryPtr IAgCrdnAngleGroup::GetFactory ( ) {
    struct IAgCrdnAngleFactory * _result = 0;
    HRESULT _hr = get_Factory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFactoryPtr(_result, false);
}

IAgCrdnAnglePtr IAgCrdnAngleGroup::GetItem ( const _variant_t & IndexOrName ) {
    struct IAgCrdnAngle * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAnglePtr(_result, false);
}

IUnknownPtr IAgCrdnAngleGroup::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface IAgCrdnAxesGroup wrapper method implementations
//

HRESULT IAgCrdnAxesGroup::Remove ( _bstr_t AxesName ) {
    HRESULT _hr = raw_Remove(AxesName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnContextPtr IAgCrdnAxesGroup::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

VARIANT_BOOL IAgCrdnAxesGroup::Contains ( _bstr_t Name ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Contains(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IAgCrdnAxesGroup::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAxesFactoryPtr IAgCrdnAxesGroup::GetFactory ( ) {
    struct IAgCrdnAxesFactory * _result = 0;
    HRESULT _hr = get_Factory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFactoryPtr(_result, false);
}

IAgCrdnAxesPtr IAgCrdnAxesGroup::GetItem ( const _variant_t & IndexOrName ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

IUnknownPtr IAgCrdnAxesGroup::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

IAgCrdnAxesCommonTasksPtr IAgCrdnAxesGroup::GetCommonTasks ( ) {
    struct IAgCrdnAxesCommonTasks * _result = 0;
    HRESULT _hr = get_CommonTasks(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesCommonTasksPtr(_result, false);
}

//
// interface IAgCrdnPlaneGroup wrapper method implementations
//

HRESULT IAgCrdnPlaneGroup::Remove ( _bstr_t PlaneName ) {
    HRESULT _hr = raw_Remove(PlaneName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnContextPtr IAgCrdnPlaneGroup::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

VARIANT_BOOL IAgCrdnPlaneGroup::Contains ( _bstr_t Name ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Contains(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IAgCrdnPlaneGroup::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPlaneFactoryPtr IAgCrdnPlaneGroup::GetFactory ( ) {
    struct IAgCrdnPlaneFactory * _result = 0;
    HRESULT _hr = get_Factory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFactoryPtr(_result, false);
}

IAgCrdnPlanePtr IAgCrdnPlaneGroup::GetItem ( const _variant_t & IndexOrName ) {
    struct IAgCrdnPlane * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlanePtr(_result, false);
}

IUnknownPtr IAgCrdnPlaneGroup::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface IAgCrdnSystemGroup wrapper method implementations
//

HRESULT IAgCrdnSystemGroup::Remove ( _bstr_t SystemName ) {
    HRESULT _hr = raw_Remove(SystemName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnContextPtr IAgCrdnSystemGroup::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

VARIANT_BOOL IAgCrdnSystemGroup::Contains ( _bstr_t Name ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Contains(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IAgCrdnSystemGroup::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnSystemFactoryPtr IAgCrdnSystemGroup::GetFactory ( ) {
    struct IAgCrdnSystemFactory * _result = 0;
    HRESULT _hr = get_Factory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemFactoryPtr(_result, false);
}

IAgCrdnSystemPtr IAgCrdnSystemGroup::GetItem ( const _variant_t & IndexOrName ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

IUnknownPtr IAgCrdnSystemGroup::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

IAgCrdnSystemCommonTasksPtr IAgCrdnSystemGroup::GetCommonTasks ( ) {
    struct IAgCrdnSystemCommonTasks * _result = 0;
    HRESULT _hr = get_CommonTasks(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemCommonTasksPtr(_result, false);
}

//
// interface IAgCrdnWellKnownEarthAxes wrapper method implementations
//

IAgCrdnAxesPtr IAgCrdnWellKnownEarthAxes::GetFixed ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_Fixed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

IAgCrdnAxesPtr IAgCrdnWellKnownEarthAxes::GetICRF ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_ICRF(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

IAgCrdnAxesPtr IAgCrdnWellKnownEarthAxes::GetInertial ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_Inertial(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

IAgCrdnAxesPtr IAgCrdnWellKnownEarthAxes::GetJ2000 ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_J2000(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

//
// interface IAgCrdnWellKnownSunAxes wrapper method implementations
//

IAgCrdnAxesPtr IAgCrdnWellKnownSunAxes::GetFixed ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_Fixed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

IAgCrdnAxesPtr IAgCrdnWellKnownSunAxes::GetICRF ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_ICRF(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

IAgCrdnAxesPtr IAgCrdnWellKnownSunAxes::GetInertial ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_Inertial(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

IAgCrdnAxesPtr IAgCrdnWellKnownSunAxes::GetJ2000 ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_J2000(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

//
// interface IAgCrdnWellKnownAxes wrapper method implementations
//

IAgCrdnWellKnownEarthAxesPtr IAgCrdnWellKnownAxes::GetEarth ( ) {
    struct IAgCrdnWellKnownEarthAxes * _result = 0;
    HRESULT _hr = get_Earth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnWellKnownEarthAxesPtr(_result, false);
}

IAgCrdnWellKnownSunAxesPtr IAgCrdnWellKnownAxes::GetSun ( ) {
    struct IAgCrdnWellKnownSunAxes * _result = 0;
    HRESULT _hr = get_Sun(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnWellKnownSunAxesPtr(_result, false);
}

//
// interface _IAgCrdnVectorRefTo wrapper method implementations
//

_bstr_t _IAgCrdnVectorRefTo::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT _IAgCrdnVectorRefTo::SetPath ( _bstr_t Path ) {
    HRESULT _hr = raw_SetPath(Path);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVectorRefTo::SetVector ( struct IAgCrdnVector * Vector ) {
    HRESULT _hr = raw_SetVector(Vector);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnVectorPtr _IAgCrdnVectorRefTo::GetVector ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = raw_GetVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorRefTo::HasCyclicDependency ( struct IAgCrdnVector * Vector ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_HasCyclicDependency(Vector, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnAxesRefTo wrapper method implementations
//

_bstr_t _IAgCrdnAxesRefTo::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT _IAgCrdnAxesRefTo::SetPath ( _bstr_t Path ) {
    HRESULT _hr = raw_SetPath(Path);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnAxesRefTo::SetAxes ( struct IAgCrdnAxes * Axes ) {
    HRESULT _hr = raw_SetAxes(Axes);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnAxesPtr _IAgCrdnAxesRefTo::GetAxes ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = raw_GetAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesRefTo::HasCyclicDependency ( struct IAgCrdnAxes * Axes ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_HasCyclicDependency(Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnAngleRefTo wrapper method implementations
//

_bstr_t _IAgCrdnAngleRefTo::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT _IAgCrdnAngleRefTo::SetPath ( _bstr_t Path ) {
    HRESULT _hr = raw_SetPath(Path);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnAngleRefTo::SetAngle ( struct IAgCrdnAngle * Angle ) {
    HRESULT _hr = raw_SetAngle(Angle);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnAnglePtr _IAgCrdnAngleRefTo::GetAngle ( ) {
    struct IAgCrdnAngle * _result = 0;
    HRESULT _hr = raw_GetAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAnglePtr(_result, false);
}

VARIANT_BOOL _IAgCrdnAngleRefTo::HasCyclicDependency ( struct IAgCrdnAngle * Angle ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_HasCyclicDependency(Angle, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnPlaneRefTo wrapper method implementations
//

_bstr_t _IAgCrdnPlaneRefTo::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT _IAgCrdnPlaneRefTo::SetPath ( _bstr_t Path ) {
    HRESULT _hr = raw_SetPath(Path);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnPlaneRefTo::SetPlane ( struct IAgCrdnPlane * Plane ) {
    HRESULT _hr = raw_SetPlane(Plane);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnPlanePtr _IAgCrdnPlaneRefTo::GetPlane ( ) {
    struct IAgCrdnPlane * _result = 0;
    HRESULT _hr = raw_GetPlane(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlanePtr(_result, false);
}

VARIANT_BOOL _IAgCrdnPlaneRefTo::HasCyclicDependency ( struct IAgCrdnPlane * Plane ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_HasCyclicDependency(Plane, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnAxesCommonTasks wrapper method implementations
//

IAgCrdnAxesFixedPtr _IAgCrdnAxesCommonTasks::CreateTopocentricAxesQuaternion ( struct IAgCrdnPoint * OriginPoint, double QX, double QY, double QZ, double QS ) {
    struct IAgCrdnAxesFixed * _result = 0;
    HRESULT _hr = raw_CreateTopocentricAxesQuaternion(OriginPoint, QX, QY, QZ, QS, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFixedPtr(_result, false);
}

IAgCrdnAxesFixedPtr _IAgCrdnAxesCommonTasks::CreateTopocentricAxesEulerAngles ( struct IAgCrdnPoint * OriginPoint, enum STKUtil::AgEEulerOrientationSequence Sequence, const _variant_t & A, const _variant_t & B, const _variant_t & C ) {
    struct IAgCrdnAxesFixed * _result = 0;
    HRESULT _hr = raw_CreateTopocentricAxesEulerAngles(OriginPoint, Sequence, A, B, C, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFixedPtr(_result, false);
}

IAgCrdnAxesFixedPtr _IAgCrdnAxesCommonTasks::CreateFixed ( struct IAgCrdnAxes * ReferenceAxes ) {
    struct IAgCrdnAxesFixed * _result = 0;
    HRESULT _hr = raw_CreateFixed(ReferenceAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFixedPtr(_result, false);
}

IAgCrdnAxesSamplingResultPtr _IAgCrdnAxesCommonTasks::Sample ( struct IAgCrdnAxes * Axes, struct IAgCrdnAxes * ReferenceAxes, SAFEARRAY * * Intervals, double MinStep, double MaxStep, const _variant_t & TargetRate ) {
    struct IAgCrdnAxesSamplingResult * _result = 0;
    HRESULT _hr = raw_Sample(Axes, ReferenceAxes, Intervals, MinStep, MaxStep, TargetRate, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesSamplingResultPtr(_result, false);
}

//
// interface _IAgCrdnSystemCommonTasks wrapper method implementations
//

IAgCrdnSystemAssembledPtr _IAgCrdnSystemCommonTasks::CreateEastNorthUpCartographic ( const _variant_t & Latitude, const _variant_t & Longitude, double Altitude ) {
    struct IAgCrdnSystemAssembled * _result = 0;
    HRESULT _hr = raw_CreateEastNorthUpCartographic(Latitude, Longitude, Altitude, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemAssembledPtr(_result, false);
}

IAgCrdnSystemAssembledPtr _IAgCrdnSystemCommonTasks::CreateAssembled ( struct IAgCrdnPoint * OriginPoint, struct IAgCrdnAxes * ReferenceAxes ) {
    struct IAgCrdnSystemAssembled * _result = 0;
    HRESULT _hr = raw_CreateAssembled(OriginPoint, ReferenceAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemAssembledPtr(_result, false);
}

//
// interface _IAgCrdnVectorFactory wrapper method implementations
//

IAgCrdnVectorPtr _IAgCrdnVectorFactory::Create ( _bstr_t VectorName, _bstr_t Description, enum AgECrdnVectorType VectorType ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = raw_Create(VectorName, Description, VectorType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorFactory::IsTypeSupported ( enum AgECrdnVectorType Type ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorDisplacementPtr _IAgCrdnVectorFactory::CreateDisplacementVector ( _bstr_t VectorName, struct IAgCrdnPoint * OriginPoint, struct IAgCrdnPoint * DestPoint ) {
    struct IAgCrdnVectorDisplacement * _result = 0;
    HRESULT _hr = raw_CreateDisplacementVector(VectorName, OriginPoint, DestPoint, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorDisplacementPtr(_result, false);
}

SAFEARRAY * _IAgCrdnVectorFactory::GetAvailableVectorPluginDisplayNames ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_AvailableVectorPluginDisplayNames(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorPtr _IAgCrdnVectorFactory::CreateVectorPluginFromDisplayName ( _bstr_t VectorName, _bstr_t Description, _bstr_t DisplayName ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = raw_CreateVectorPluginFromDisplayName(VectorName, Description, DisplayName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnVectorCrossPtr _IAgCrdnVectorFactory::CreateCrossProductVector ( _bstr_t VectorName, struct IAgCrdnVector * VectorA, struct IAgCrdnVector * VectorB ) {
    struct IAgCrdnVectorCross * _result = 0;
    HRESULT _hr = raw_CreateCrossProductVector(VectorName, VectorA, VectorB, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorCrossPtr(_result, false);
}

//
// interface _IAgCrdnAxesFactory wrapper method implementations
//

IAgCrdnAxesPtr _IAgCrdnAxesFactory::Create ( _bstr_t AxesName, _bstr_t Description, enum AgECrdnAxesType AxesType ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = raw_Create(AxesName, Description, AxesType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesFactory::IsTypeSupported ( enum AgECrdnAxesType Type ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnAxesFactory::GetAvailableAxesPluginDisplayNames ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_AvailableAxesPluginDisplayNames(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAxesPtr _IAgCrdnAxesFactory::CreateAxesPluginFromDisplayName ( _bstr_t AxesName, _bstr_t Description, _bstr_t DisplayName ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = raw_CreateAxesPluginFromDisplayName(AxesName, Description, DisplayName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

//
// interface _IAgCrdnPlaneFactory wrapper method implementations
//

IAgCrdnPlanePtr _IAgCrdnPlaneFactory::Create ( _bstr_t PlaneName, _bstr_t Description, enum AgECrdnPlaneType PlaneType ) {
    struct IAgCrdnPlane * _result = 0;
    HRESULT _hr = raw_Create(PlaneName, Description, PlaneType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlanePtr(_result, false);
}

VARIANT_BOOL _IAgCrdnPlaneFactory::IsTypeSupported ( enum AgECrdnPlaneType Type ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnAngleFactory wrapper method implementations
//

IAgCrdnAnglePtr _IAgCrdnAngleFactory::Create ( _bstr_t AngleName, _bstr_t Description, enum AgECrdnAngleType AngleType ) {
    struct IAgCrdnAngle * _result = 0;
    HRESULT _hr = raw_Create(AngleName, Description, AngleType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAnglePtr(_result, false);
}

VARIANT_BOOL _IAgCrdnAngleFactory::IsTypeSupported ( enum AgECrdnAngleType Type ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeSupported(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnWellKnownEarthAxes wrapper method implementations
//

IAgCrdnAxesPtr _IAgCrdnWellKnownEarthAxes::GetFixed ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_Fixed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

IAgCrdnAxesPtr _IAgCrdnWellKnownEarthAxes::GetICRF ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_ICRF(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

IAgCrdnAxesPtr _IAgCrdnWellKnownEarthAxes::GetInertial ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_Inertial(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

IAgCrdnAxesPtr _IAgCrdnWellKnownEarthAxes::GetJ2000 ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_J2000(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

//
// interface _IAgCrdnWellKnownSunAxes wrapper method implementations
//

IAgCrdnAxesPtr _IAgCrdnWellKnownSunAxes::GetFixed ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_Fixed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

IAgCrdnAxesPtr _IAgCrdnWellKnownSunAxes::GetICRF ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_ICRF(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

IAgCrdnAxesPtr _IAgCrdnWellKnownSunAxes::GetInertial ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_Inertial(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

IAgCrdnAxesPtr _IAgCrdnWellKnownSunAxes::GetJ2000 ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_J2000(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

//
// interface _IAgCrdnWellKnownAxes wrapper method implementations
//

IAgCrdnWellKnownEarthAxesPtr _IAgCrdnWellKnownAxes::GetEarth ( ) {
    struct IAgCrdnWellKnownEarthAxes * _result = 0;
    HRESULT _hr = get_Earth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnWellKnownEarthAxesPtr(_result, false);
}

IAgCrdnWellKnownSunAxesPtr _IAgCrdnWellKnownAxes::GetSun ( ) {
    struct IAgCrdnWellKnownSunAxes * _result = 0;
    HRESULT _hr = get_Sun(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnWellKnownSunAxesPtr(_result, false);
}

//
// interface _IAgCrdnCalcScalar wrapper method implementations
//

enum AgECrdnCalcScalarType _IAgCrdnCalcScalar::GetType ( ) {
    enum AgECrdnCalcScalarType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEvaluateResultPtr _IAgCrdnCalcScalar::Evaluate ( const _variant_t & Epoch ) {
    struct IAgCrdnEvaluateResult * _result = 0;
    HRESULT _hr = raw_Evaluate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEvaluateResultPtr(_result, false);
}

SAFEARRAY * _IAgCrdnCalcScalar::QuickEvaluate ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEvaluateWithRateResultPtr _IAgCrdnCalcScalar::EvaluateWithRate ( const _variant_t & Epoch ) {
    struct IAgCrdnEvaluateWithRateResult * _result = 0;
    HRESULT _hr = raw_EvaluateWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEvaluateWithRateResultPtr(_result, false);
}

SAFEARRAY * _IAgCrdnCalcScalar::QuickEvaluateWithRate ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

enum AgECrdnKind _IAgCrdnCalcScalar::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnCalcScalar::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnCalcScalar::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnCalcScalar::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnCalcScalar::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnCalcScalar::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalar::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnCalcScalar::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnCalcScalar::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnCalcScalar::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalar::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnCalcScalar::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnCalcScalar::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnCalcScalar::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnCalcScalar::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalar::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnCalcScalar::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnCalcScalar::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnCalcScalar::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

_bstr_t _IAgCrdnCalcScalar::GetUnitOfMeasure ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_UnitOfMeasure(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT _IAgCrdnCalcScalar::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgCrdnCalcScalar::QuickEvaluateArray ( SAFEARRAY * * Times ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateArray(Times, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalar::QuickEvaluateWithRateArray ( SAFEARRAY * * Times ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRateArray(Times, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalar::QuickEvaluateEventArray ( struct IAgCrdnEventArray * RefArray ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateEventArray(RefArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalar::QuickEvaluateWithRateEventArray ( struct IAgCrdnEventArray * RefArray ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRateEventArray(RefArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IAgCrdn wrapper method implementations
//

enum AgECrdnKind IAgCrdn::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t IAgCrdn::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void IAgCrdn::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t IAgCrdn::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t IAgCrdn::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t IAgCrdn::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL IAgCrdn::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr IAgCrdn::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr IAgCrdn::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t IAgCrdn::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL IAgCrdn::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IAgCrdn::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL IAgCrdn::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr IAgCrdn::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr IAgCrdn::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL IAgCrdn::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr IAgCrdn::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT IAgCrdn::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgCrdn::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IAgCrdnCollection wrapper method implementations
//

VARIANT_BOOL IAgCrdnCollection::Contains ( _bstr_t Name ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Contains(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

long IAgCrdnCollection::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr IAgCrdnCollection::GetItem ( const _variant_t & IndexOrName ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IUnknownPtr IAgCrdnCollection::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface _IAgCrdnCalcScalarAngle wrapper method implementations
//

enum AgECrdnCalcScalarType _IAgCrdnCalcScalarAngle::GetType ( ) {
    enum AgECrdnCalcScalarType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEvaluateResultPtr _IAgCrdnCalcScalarAngle::Evaluate ( const _variant_t & Epoch ) {
    struct IAgCrdnEvaluateResult * _result = 0;
    HRESULT _hr = raw_Evaluate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEvaluateResultPtr(_result, false);
}

SAFEARRAY * _IAgCrdnCalcScalarAngle::QuickEvaluate ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEvaluateWithRateResultPtr _IAgCrdnCalcScalarAngle::EvaluateWithRate ( const _variant_t & Epoch ) {
    struct IAgCrdnEvaluateWithRateResult * _result = 0;
    HRESULT _hr = raw_EvaluateWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEvaluateWithRateResultPtr(_result, false);
}

SAFEARRAY * _IAgCrdnCalcScalarAngle::QuickEvaluateWithRate ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAnglePtr _IAgCrdnCalcScalarAngle::GetInputAngle ( ) {
    struct IAgCrdnAngle * _result = 0;
    HRESULT _hr = get_InputAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAnglePtr(_result, false);
}

void _IAgCrdnCalcScalarAngle::PutInputAngle ( struct IAgCrdnAngle * ppRetVal ) {
    HRESULT _hr = put_InputAngle(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnCalcScalarAngle::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnCalcScalarAngle::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnCalcScalarAngle::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnCalcScalarAngle::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnCalcScalarAngle::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnCalcScalarAngle::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarAngle::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnCalcScalarAngle::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnCalcScalarAngle::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnCalcScalarAngle::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarAngle::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnCalcScalarAngle::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnCalcScalarAngle::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnCalcScalarAngle::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnCalcScalarAngle::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarAngle::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnCalcScalarAngle::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnCalcScalarAngle::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnCalcScalarAngle::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

_bstr_t _IAgCrdnCalcScalarAngle::GetUnitOfMeasure ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_UnitOfMeasure(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT _IAgCrdnCalcScalarAngle::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgCrdnCalcScalarAngle::QuickEvaluateArray ( SAFEARRAY * * Times ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateArray(Times, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarAngle::QuickEvaluateWithRateArray ( SAFEARRAY * * Times ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRateArray(Times, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarAngle::QuickEvaluateEventArray ( struct IAgCrdnEventArray * RefArray ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateEventArray(RefArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarAngle::QuickEvaluateWithRateEventArray ( struct IAgCrdnEventArray * RefArray ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRateEventArray(RefArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnCalcScalarConstant wrapper method implementations
//

enum AgECrdnCalcScalarType _IAgCrdnCalcScalarConstant::GetType ( ) {
    enum AgECrdnCalcScalarType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEvaluateResultPtr _IAgCrdnCalcScalarConstant::Evaluate ( const _variant_t & Epoch ) {
    struct IAgCrdnEvaluateResult * _result = 0;
    HRESULT _hr = raw_Evaluate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEvaluateResultPtr(_result, false);
}

SAFEARRAY * _IAgCrdnCalcScalarConstant::QuickEvaluate ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEvaluateWithRateResultPtr _IAgCrdnCalcScalarConstant::EvaluateWithRate ( const _variant_t & Epoch ) {
    struct IAgCrdnEvaluateWithRateResult * _result = 0;
    HRESULT _hr = raw_EvaluateWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEvaluateWithRateResultPtr(_result, false);
}

SAFEARRAY * _IAgCrdnCalcScalarConstant::QuickEvaluateWithRate ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

double _IAgCrdnCalcScalarConstant::GetValue ( ) {
    double _result = 0;
    HRESULT _hr = get_Value(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnCalcScalarConstant::PutValue ( double pRetVal ) {
    HRESULT _hr = put_Value(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnCalcScalarConstant::GetDimension ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Dimension(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnCalcScalarConstant::PutDimension ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Dimension(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnCalcScalarConstant::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnCalcScalarConstant::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnCalcScalarConstant::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnCalcScalarConstant::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnCalcScalarConstant::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnCalcScalarConstant::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarConstant::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnCalcScalarConstant::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnCalcScalarConstant::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnCalcScalarConstant::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarConstant::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnCalcScalarConstant::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnCalcScalarConstant::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnCalcScalarConstant::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnCalcScalarConstant::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarConstant::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnCalcScalarConstant::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnCalcScalarConstant::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnCalcScalarConstant::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

_bstr_t _IAgCrdnCalcScalarConstant::GetUnitOfMeasure ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_UnitOfMeasure(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT _IAgCrdnCalcScalarConstant::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgCrdnCalcScalarConstant::QuickEvaluateArray ( SAFEARRAY * * Times ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateArray(Times, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarConstant::QuickEvaluateWithRateArray ( SAFEARRAY * * Times ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRateArray(Times, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarConstant::QuickEvaluateEventArray ( struct IAgCrdnEventArray * RefArray ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateEventArray(RefArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarConstant::QuickEvaluateWithRateEventArray ( struct IAgCrdnEventArray * RefArray ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRateEventArray(RefArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnCalcScalarCustom wrapper method implementations
//

enum AgECrdnCalcScalarType _IAgCrdnCalcScalarCustom::GetType ( ) {
    enum AgECrdnCalcScalarType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEvaluateResultPtr _IAgCrdnCalcScalarCustom::Evaluate ( const _variant_t & Epoch ) {
    struct IAgCrdnEvaluateResult * _result = 0;
    HRESULT _hr = raw_Evaluate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEvaluateResultPtr(_result, false);
}

SAFEARRAY * _IAgCrdnCalcScalarCustom::QuickEvaluate ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEvaluateWithRateResultPtr _IAgCrdnCalcScalarCustom::EvaluateWithRate ( const _variant_t & Epoch ) {
    struct IAgCrdnEvaluateWithRateResult * _result = 0;
    HRESULT _hr = raw_EvaluateWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEvaluateWithRateResultPtr(_result, false);
}

SAFEARRAY * _IAgCrdnCalcScalarCustom::QuickEvaluateWithRate ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnCalcScalarCustom::GetFilename ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Filename(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnCalcScalarCustom::PutFilename ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Filename(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgCrdnCalcScalarCustom::Reload ( ) {
    HRESULT _hr = raw_Reload();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

enum AgECrdnKind _IAgCrdnCalcScalarCustom::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnCalcScalarCustom::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnCalcScalarCustom::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnCalcScalarCustom::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnCalcScalarCustom::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnCalcScalarCustom::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarCustom::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnCalcScalarCustom::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnCalcScalarCustom::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnCalcScalarCustom::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarCustom::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnCalcScalarCustom::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnCalcScalarCustom::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnCalcScalarCustom::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnCalcScalarCustom::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarCustom::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnCalcScalarCustom::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnCalcScalarCustom::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnCalcScalarCustom::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

_bstr_t _IAgCrdnCalcScalarCustom::GetUnitOfMeasure ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_UnitOfMeasure(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT _IAgCrdnCalcScalarCustom::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgCrdnCalcScalarCustom::QuickEvaluateArray ( SAFEARRAY * * Times ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateArray(Times, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarCustom::QuickEvaluateWithRateArray ( SAFEARRAY * * Times ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRateArray(Times, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarCustom::QuickEvaluateEventArray ( struct IAgCrdnEventArray * RefArray ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateEventArray(RefArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarCustom::QuickEvaluateWithRateEventArray ( struct IAgCrdnEventArray * RefArray ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRateEventArray(RefArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnCalcScalarDataElement wrapper method implementations
//

enum AgECrdnCalcScalarType _IAgCrdnCalcScalarDataElement::GetType ( ) {
    enum AgECrdnCalcScalarType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEvaluateResultPtr _IAgCrdnCalcScalarDataElement::Evaluate ( const _variant_t & Epoch ) {
    struct IAgCrdnEvaluateResult * _result = 0;
    HRESULT _hr = raw_Evaluate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEvaluateResultPtr(_result, false);
}

SAFEARRAY * _IAgCrdnCalcScalarDataElement::QuickEvaluate ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEvaluateWithRateResultPtr _IAgCrdnCalcScalarDataElement::EvaluateWithRate ( const _variant_t & Epoch ) {
    struct IAgCrdnEvaluateWithRateResult * _result = 0;
    HRESULT _hr = raw_EvaluateWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEvaluateWithRateResultPtr(_result, false);
}

SAFEARRAY * _IAgCrdnCalcScalarDataElement::QuickEvaluateWithRate ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnCalcScalarDataElement::GetDataProvider ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DataProvider(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnCalcScalarDataElement::GetElementName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ElementName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnCalcScalarDataElement::GetGroup ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Group(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

IAgCrdnInterpPtr _IAgCrdnCalcScalarDataElement::GetInterpolation ( ) {
    struct IAgCrdnInterp * _result = 0;
    HRESULT _hr = get_Interpolation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnInterpPtr(_result, false);
}

void _IAgCrdnCalcScalarDataElement::PutInterpolation ( struct IAgCrdnInterp * ppRetVal ) {
    HRESULT _hr = put_Interpolation(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSamplingPtr _IAgCrdnCalcScalarDataElement::GetSampling ( ) {
    struct IAgCrdnSampling * _result = 0;
    HRESULT _hr = get_Sampling(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSamplingPtr(_result, false);
}

void _IAgCrdnCalcScalarDataElement::PutSampling ( struct IAgCrdnSampling * ppRetVal ) {
    HRESULT _hr = put_Sampling(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnCalcScalarDataElement::GetUseSamples ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseSamples(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnCalcScalarDataElement::PutUseSamples ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseSamples(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSaveDataOption _IAgCrdnCalcScalarDataElement::GetSaveDataOption ( ) {
    enum AgECrdnSaveDataOption _result;
    HRESULT _hr = get_SaveDataOption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnCalcScalarDataElement::PutSaveDataOption ( enum AgECrdnSaveDataOption pRetVal ) {
    HRESULT _hr = put_SaveDataOption(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgCrdnCalcScalarDataElement::Set ( _bstr_t DataProvider, _bstr_t ElementName ) {
    HRESULT _hr = raw_Set(DataProvider, ElementName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnCalcScalarDataElement::SetWithGroup ( _bstr_t DataProvider, _bstr_t TypeName, _bstr_t ElementName ) {
    HRESULT _hr = raw_SetWithGroup(DataProvider, TypeName, ElementName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

enum AgECrdnKind _IAgCrdnCalcScalarDataElement::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnCalcScalarDataElement::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnCalcScalarDataElement::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnCalcScalarDataElement::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnCalcScalarDataElement::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnCalcScalarDataElement::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarDataElement::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnCalcScalarDataElement::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnCalcScalarDataElement::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnCalcScalarDataElement::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarDataElement::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnCalcScalarDataElement::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnCalcScalarDataElement::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnCalcScalarDataElement::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnCalcScalarDataElement::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarDataElement::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnCalcScalarDataElement::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

double _IAgCrdnCalcScalarDataElement::GetInvalidDataIndicator ( ) {
    double _result = 0;
    HRESULT _hr = get_InvalidDataIndicator(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnCalcScalarDataElement::PutInvalidDataIndicator ( double pRetVal ) {
    HRESULT _hr = put_InvalidDataIndicator(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgCrdnCalcScalarDataElement::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnCalcScalarDataElement::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

_bstr_t _IAgCrdnCalcScalarDataElement::GetUnitOfMeasure ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_UnitOfMeasure(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT _IAgCrdnCalcScalarDataElement::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgCrdnCalcScalarDataElement::QuickEvaluateArray ( SAFEARRAY * * Times ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateArray(Times, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarDataElement::QuickEvaluateWithRateArray ( SAFEARRAY * * Times ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRateArray(Times, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarDataElement::QuickEvaluateEventArray ( struct IAgCrdnEventArray * RefArray ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateEventArray(RefArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarDataElement::QuickEvaluateWithRateEventArray ( struct IAgCrdnEventArray * RefArray ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRateEventArray(RefArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnCalcScalarDerivative wrapper method implementations
//

enum AgECrdnCalcScalarType _IAgCrdnCalcScalarDerivative::GetType ( ) {
    enum AgECrdnCalcScalarType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEvaluateResultPtr _IAgCrdnCalcScalarDerivative::Evaluate ( const _variant_t & Epoch ) {
    struct IAgCrdnEvaluateResult * _result = 0;
    HRESULT _hr = raw_Evaluate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEvaluateResultPtr(_result, false);
}

SAFEARRAY * _IAgCrdnCalcScalarDerivative::QuickEvaluate ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEvaluateWithRateResultPtr _IAgCrdnCalcScalarDerivative::EvaluateWithRate ( const _variant_t & Epoch ) {
    struct IAgCrdnEvaluateWithRateResult * _result = 0;
    HRESULT _hr = raw_EvaluateWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEvaluateWithRateResultPtr(_result, false);
}

SAFEARRAY * _IAgCrdnCalcScalarDerivative::QuickEvaluateWithRate ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCalcScalarPtr _IAgCrdnCalcScalarDerivative::GetScalar ( ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = get_Scalar(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

void _IAgCrdnCalcScalarDerivative::PutScalar ( struct IAgCrdnCalcScalar * ppRetVal ) {
    HRESULT _hr = put_Scalar(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnCalcScalarDerivative::GetDifferencingTimeStep ( ) {
    double _result = 0;
    HRESULT _hr = get_DifferencingTimeStep(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnCalcScalarDerivative::PutDifferencingTimeStep ( double pRetVal ) {
    HRESULT _hr = put_DifferencingTimeStep(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnCalcScalarDerivative::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnCalcScalarDerivative::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnCalcScalarDerivative::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnCalcScalarDerivative::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnCalcScalarDerivative::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnCalcScalarDerivative::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarDerivative::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnCalcScalarDerivative::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnCalcScalarDerivative::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnCalcScalarDerivative::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarDerivative::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnCalcScalarDerivative::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnCalcScalarDerivative::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnCalcScalarDerivative::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnCalcScalarDerivative::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarDerivative::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnCalcScalarDerivative::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnCalcScalarDerivative::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnCalcScalarDerivative::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

_bstr_t _IAgCrdnCalcScalarDerivative::GetUnitOfMeasure ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_UnitOfMeasure(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT _IAgCrdnCalcScalarDerivative::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgCrdnCalcScalarDerivative::QuickEvaluateArray ( SAFEARRAY * * Times ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateArray(Times, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarDerivative::QuickEvaluateWithRateArray ( SAFEARRAY * * Times ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRateArray(Times, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarDerivative::QuickEvaluateEventArray ( struct IAgCrdnEventArray * RefArray ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateEventArray(RefArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarDerivative::QuickEvaluateWithRateEventArray ( struct IAgCrdnEventArray * RefArray ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRateEventArray(RefArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnCalcScalarElapsedTime wrapper method implementations
//

enum AgECrdnCalcScalarType _IAgCrdnCalcScalarElapsedTime::GetType ( ) {
    enum AgECrdnCalcScalarType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEvaluateResultPtr _IAgCrdnCalcScalarElapsedTime::Evaluate ( const _variant_t & Epoch ) {
    struct IAgCrdnEvaluateResult * _result = 0;
    HRESULT _hr = raw_Evaluate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEvaluateResultPtr(_result, false);
}

SAFEARRAY * _IAgCrdnCalcScalarElapsedTime::QuickEvaluate ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEvaluateWithRateResultPtr _IAgCrdnCalcScalarElapsedTime::EvaluateWithRate ( const _variant_t & Epoch ) {
    struct IAgCrdnEvaluateWithRateResult * _result = 0;
    HRESULT _hr = raw_EvaluateWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEvaluateWithRateResultPtr(_result, false);
}

SAFEARRAY * _IAgCrdnCalcScalarElapsedTime::QuickEvaluateWithRate ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEventPtr _IAgCrdnCalcScalarElapsedTime::GetReferenceTimeInstant ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_ReferenceTimeInstant(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

void _IAgCrdnCalcScalarElapsedTime::PutReferenceTimeInstant ( struct IAgCrdnEvent * ppRetVal ) {
    HRESULT _hr = put_ReferenceTimeInstant(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnCalcScalarElapsedTime::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnCalcScalarElapsedTime::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnCalcScalarElapsedTime::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnCalcScalarElapsedTime::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnCalcScalarElapsedTime::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnCalcScalarElapsedTime::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarElapsedTime::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnCalcScalarElapsedTime::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnCalcScalarElapsedTime::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnCalcScalarElapsedTime::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarElapsedTime::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnCalcScalarElapsedTime::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnCalcScalarElapsedTime::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnCalcScalarElapsedTime::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnCalcScalarElapsedTime::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarElapsedTime::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnCalcScalarElapsedTime::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnCalcScalarElapsedTime::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnCalcScalarElapsedTime::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

_bstr_t _IAgCrdnCalcScalarElapsedTime::GetUnitOfMeasure ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_UnitOfMeasure(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT _IAgCrdnCalcScalarElapsedTime::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgCrdnCalcScalarElapsedTime::QuickEvaluateArray ( SAFEARRAY * * Times ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateArray(Times, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarElapsedTime::QuickEvaluateWithRateArray ( SAFEARRAY * * Times ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRateArray(Times, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarElapsedTime::QuickEvaluateEventArray ( struct IAgCrdnEventArray * RefArray ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateEventArray(RefArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarElapsedTime::QuickEvaluateWithRateEventArray ( struct IAgCrdnEventArray * RefArray ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRateEventArray(RefArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnCalcScalarFile wrapper method implementations
//

enum AgECrdnCalcScalarType _IAgCrdnCalcScalarFile::GetType ( ) {
    enum AgECrdnCalcScalarType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEvaluateResultPtr _IAgCrdnCalcScalarFile::Evaluate ( const _variant_t & Epoch ) {
    struct IAgCrdnEvaluateResult * _result = 0;
    HRESULT _hr = raw_Evaluate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEvaluateResultPtr(_result, false);
}

SAFEARRAY * _IAgCrdnCalcScalarFile::QuickEvaluate ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEvaluateWithRateResultPtr _IAgCrdnCalcScalarFile::EvaluateWithRate ( const _variant_t & Epoch ) {
    struct IAgCrdnEvaluateWithRateResult * _result = 0;
    HRESULT _hr = raw_EvaluateWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEvaluateWithRateResultPtr(_result, false);
}

SAFEARRAY * _IAgCrdnCalcScalarFile::QuickEvaluateWithRate ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnCalcScalarFile::GetFilename ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Filename(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnCalcScalarFile::PutFilename ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Filename(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgCrdnCalcScalarFile::Reload ( ) {
    HRESULT _hr = raw_Reload();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnEventIntervalResultPtr _IAgCrdnCalcScalarFile::GetFileSpan ( ) {
    struct IAgCrdnEventIntervalResult * _result = 0;
    HRESULT _hr = raw_GetFileSpan(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalResultPtr(_result, false);
}

enum AgECrdnKind _IAgCrdnCalcScalarFile::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnCalcScalarFile::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnCalcScalarFile::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnCalcScalarFile::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnCalcScalarFile::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnCalcScalarFile::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarFile::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnCalcScalarFile::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnCalcScalarFile::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnCalcScalarFile::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarFile::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnCalcScalarFile::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnCalcScalarFile::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnCalcScalarFile::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnCalcScalarFile::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarFile::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnCalcScalarFile::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnCalcScalarFile::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnCalcScalarFile::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

_bstr_t _IAgCrdnCalcScalarFile::GetUnitOfMeasure ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_UnitOfMeasure(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT _IAgCrdnCalcScalarFile::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgCrdnCalcScalarFile::QuickEvaluateArray ( SAFEARRAY * * Times ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateArray(Times, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarFile::QuickEvaluateWithRateArray ( SAFEARRAY * * Times ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRateArray(Times, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarFile::QuickEvaluateEventArray ( struct IAgCrdnEventArray * RefArray ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateEventArray(RefArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarFile::QuickEvaluateWithRateEventArray ( struct IAgCrdnEventArray * RefArray ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRateEventArray(RefArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

enum AgECrdnFileInterpolatorType _IAgCrdnCalcScalarFile::GetFileInterpolationType ( ) {
    enum AgECrdnFileInterpolatorType _result;
    HRESULT _hr = get_FileInterpolationType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnCalcScalarFile::PutFileInterpolationType ( enum AgECrdnFileInterpolatorType pRetVal ) {
    HRESULT _hr = put_FileInterpolationType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

int _IAgCrdnCalcScalarFile::GetFileInterpolationOrder ( ) {
    int _result = 0;
    HRESULT _hr = get_FileInterpolationOrder(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnCalcScalarFile::PutFileInterpolationOrder ( int pRetVal ) {
    HRESULT _hr = put_FileInterpolationOrder(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnCalcScalarFile::GetUseNativeFileInterpolationSettings ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseNativeFileInterpolationSettings(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnCalcScalarFile::PutUseNativeFileInterpolationSettings ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseNativeFileInterpolationSettings(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnCalcScalarFixedAtTimeInstant wrapper method implementations
//

enum AgECrdnCalcScalarType _IAgCrdnCalcScalarFixedAtTimeInstant::GetType ( ) {
    enum AgECrdnCalcScalarType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEvaluateResultPtr _IAgCrdnCalcScalarFixedAtTimeInstant::Evaluate ( const _variant_t & Epoch ) {
    struct IAgCrdnEvaluateResult * _result = 0;
    HRESULT _hr = raw_Evaluate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEvaluateResultPtr(_result, false);
}

SAFEARRAY * _IAgCrdnCalcScalarFixedAtTimeInstant::QuickEvaluate ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEvaluateWithRateResultPtr _IAgCrdnCalcScalarFixedAtTimeInstant::EvaluateWithRate ( const _variant_t & Epoch ) {
    struct IAgCrdnEvaluateWithRateResult * _result = 0;
    HRESULT _hr = raw_EvaluateWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEvaluateWithRateResultPtr(_result, false);
}

SAFEARRAY * _IAgCrdnCalcScalarFixedAtTimeInstant::QuickEvaluateWithRate ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCalcScalarPtr _IAgCrdnCalcScalarFixedAtTimeInstant::GetInputScalar ( ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = get_InputScalar(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

void _IAgCrdnCalcScalarFixedAtTimeInstant::PutInputScalar ( struct IAgCrdnCalcScalar * ppRetVal ) {
    HRESULT _hr = put_InputScalar(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnEventPtr _IAgCrdnCalcScalarFixedAtTimeInstant::GetReferenceTimeInstant ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_ReferenceTimeInstant(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

void _IAgCrdnCalcScalarFixedAtTimeInstant::PutReferenceTimeInstant ( struct IAgCrdnEvent * ppRetVal ) {
    HRESULT _hr = put_ReferenceTimeInstant(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnCalcScalarFixedAtTimeInstant::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnCalcScalarFixedAtTimeInstant::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnCalcScalarFixedAtTimeInstant::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnCalcScalarFixedAtTimeInstant::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnCalcScalarFixedAtTimeInstant::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnCalcScalarFixedAtTimeInstant::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarFixedAtTimeInstant::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnCalcScalarFixedAtTimeInstant::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnCalcScalarFixedAtTimeInstant::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnCalcScalarFixedAtTimeInstant::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarFixedAtTimeInstant::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnCalcScalarFixedAtTimeInstant::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnCalcScalarFixedAtTimeInstant::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnCalcScalarFixedAtTimeInstant::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnCalcScalarFixedAtTimeInstant::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarFixedAtTimeInstant::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnCalcScalarFixedAtTimeInstant::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnCalcScalarFixedAtTimeInstant::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnCalcScalarFixedAtTimeInstant::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

_bstr_t _IAgCrdnCalcScalarFixedAtTimeInstant::GetUnitOfMeasure ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_UnitOfMeasure(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT _IAgCrdnCalcScalarFixedAtTimeInstant::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgCrdnCalcScalarFixedAtTimeInstant::QuickEvaluateArray ( SAFEARRAY * * Times ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateArray(Times, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarFixedAtTimeInstant::QuickEvaluateWithRateArray ( SAFEARRAY * * Times ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRateArray(Times, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarFixedAtTimeInstant::QuickEvaluateEventArray ( struct IAgCrdnEventArray * RefArray ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateEventArray(RefArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarFixedAtTimeInstant::QuickEvaluateWithRateEventArray ( struct IAgCrdnEventArray * RefArray ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRateEventArray(RefArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnCalcScalarFunction wrapper method implementations
//

enum AgECrdnCalcScalarType _IAgCrdnCalcScalarFunction::GetType ( ) {
    enum AgECrdnCalcScalarType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEvaluateResultPtr _IAgCrdnCalcScalarFunction::Evaluate ( const _variant_t & Epoch ) {
    struct IAgCrdnEvaluateResult * _result = 0;
    HRESULT _hr = raw_Evaluate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEvaluateResultPtr(_result, false);
}

SAFEARRAY * _IAgCrdnCalcScalarFunction::QuickEvaluate ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEvaluateWithRateResultPtr _IAgCrdnCalcScalarFunction::EvaluateWithRate ( const _variant_t & Epoch ) {
    struct IAgCrdnEvaluateWithRateResult * _result = 0;
    HRESULT _hr = raw_EvaluateWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEvaluateWithRateResultPtr(_result, false);
}

SAFEARRAY * _IAgCrdnCalcScalarFunction::QuickEvaluateWithRate ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnCalcScalarFunction::GetUseScalar ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseScalar(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnCalcScalarFunction::PutUseScalar ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseScalar(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnCalcScalarPtr _IAgCrdnCalcScalarFunction::GetInputScalar ( ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = get_InputScalar(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

void _IAgCrdnCalcScalarFunction::PutInputScalar ( struct IAgCrdnCalcScalar * ppRetVal ) {
    HRESULT _hr = put_InputScalar(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnEventPtr _IAgCrdnCalcScalarFunction::GetInputTime ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_InputTime(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

void _IAgCrdnCalcScalarFunction::PutInputTime ( struct IAgCrdnEvent * ppRetVal ) {
    HRESULT _hr = put_InputTime(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnCalcScalarFunction::GetA ( ) {
    double _result = 0;
    HRESULT _hr = get_A(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnCalcScalarFunction::PutA ( double pRetVal ) {
    HRESULT _hr = put_A(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnCalcScalarFunction::GetB ( ) {
    double _result = 0;
    HRESULT _hr = get_B(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnCalcScalarFunction::PutB ( double pRetVal ) {
    HRESULT _hr = put_B(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnCalcScalarFunction::GetC ( ) {
    double _result = 0;
    HRESULT _hr = get_C(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnCalcScalarFunction::PutC ( double pRetVal ) {
    HRESULT _hr = put_C(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnCalcScalarFunction::GetD ( ) {
    double _result = 0;
    HRESULT _hr = get_D(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnCalcScalarFunction::PutD ( double pRetVal ) {
    HRESULT _hr = put_D(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

SAFEARRAY * _IAgCrdnCalcScalarFunction::GetCoefficients ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Coefficients(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnCalcScalarFunction::PutCoefficients ( SAFEARRAY * ppRetVal ) {
    HRESULT _hr = put_Coefficients(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnCalcScalarFunction::GetSelectedFunction ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_SelectedFunction(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnCalcScalarFunction::PutSelectedFunction ( _bstr_t pRetVal ) {
    HRESULT _hr = put_SelectedFunction(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

SAFEARRAY * _IAgCrdnCalcScalarFunction::GetAvailableFunctions ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_AvailableFunctions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnCalcScalarFunction::GetInheritDimensionFromInput ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_InheritDimensionFromInput(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnCalcScalarFunction::PutInheritDimensionFromInput ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_InheritDimensionFromInput(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnCalcScalarFunction::GetOutputDimension ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_OutputDimension(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnCalcScalarFunction::PutOutputDimension ( _bstr_t pRetVal ) {
    HRESULT _hr = put_OutputDimension(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnCalcScalarFunction::GetOutputUnit ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_OutputUnit(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnCalcScalarFunction::PutOutputUnit ( _bstr_t pRetVal ) {
    HRESULT _hr = put_OutputUnit(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnCalcScalarFunction::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnCalcScalarFunction::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnCalcScalarFunction::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnCalcScalarFunction::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnCalcScalarFunction::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnCalcScalarFunction::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarFunction::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnCalcScalarFunction::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnCalcScalarFunction::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnCalcScalarFunction::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarFunction::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnCalcScalarFunction::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnCalcScalarFunction::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnCalcScalarFunction::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnCalcScalarFunction::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarFunction::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnCalcScalarFunction::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

IAgCrdnSamplingPtr _IAgCrdnCalcScalarFunction::GetSampling ( ) {
    struct IAgCrdnSampling * _result = 0;
    HRESULT _hr = get_Sampling(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSamplingPtr(_result, false);
}

void _IAgCrdnCalcScalarFunction::PutSampling ( struct IAgCrdnSampling * ppRetVal ) {
    HRESULT _hr = put_Sampling(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnConvergePtr _IAgCrdnCalcScalarFunction::GetConvergence ( ) {
    struct IAgCrdnConverge * _result = 0;
    HRESULT _hr = get_Convergence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConvergePtr(_result, false);
}

void _IAgCrdnCalcScalarFunction::PutConvergence ( struct IAgCrdnConverge * ppRetVal ) {
    HRESULT _hr = put_Convergence(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgCrdnCalcScalarFunction::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnCalcScalarFunction::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

_bstr_t _IAgCrdnCalcScalarFunction::GetUnitOfMeasure ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_UnitOfMeasure(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT _IAgCrdnCalcScalarFunction::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgCrdnCalcScalarFunction::QuickEvaluateArray ( SAFEARRAY * * Times ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateArray(Times, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarFunction::QuickEvaluateWithRateArray ( SAFEARRAY * * Times ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRateArray(Times, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarFunction::QuickEvaluateEventArray ( struct IAgCrdnEventArray * RefArray ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateEventArray(RefArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarFunction::QuickEvaluateWithRateEventArray ( struct IAgCrdnEventArray * RefArray ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRateEventArray(RefArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnCalcScalarFunction2Var wrapper method implementations
//

enum AgECrdnCalcScalarType _IAgCrdnCalcScalarFunction2Var::GetType ( ) {
    enum AgECrdnCalcScalarType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEvaluateResultPtr _IAgCrdnCalcScalarFunction2Var::Evaluate ( const _variant_t & Epoch ) {
    struct IAgCrdnEvaluateResult * _result = 0;
    HRESULT _hr = raw_Evaluate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEvaluateResultPtr(_result, false);
}

SAFEARRAY * _IAgCrdnCalcScalarFunction2Var::QuickEvaluate ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEvaluateWithRateResultPtr _IAgCrdnCalcScalarFunction2Var::EvaluateWithRate ( const _variant_t & Epoch ) {
    struct IAgCrdnEvaluateWithRateResult * _result = 0;
    HRESULT _hr = raw_EvaluateWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEvaluateWithRateResultPtr(_result, false);
}

SAFEARRAY * _IAgCrdnCalcScalarFunction2Var::QuickEvaluateWithRate ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCalcScalarPtr _IAgCrdnCalcScalarFunction2Var::GetX ( ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = get_X(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

void _IAgCrdnCalcScalarFunction2Var::PutX ( struct IAgCrdnCalcScalar * ppRetVal ) {
    HRESULT _hr = put_X(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnCalcScalarFunction2Var::GetUnitX ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_UnitX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnCalcScalarFunction2Var::PutUnitX ( _bstr_t pRetVal ) {
    HRESULT _hr = put_UnitX(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnCalcScalarFunction2Var::GetA ( ) {
    double _result = 0;
    HRESULT _hr = get_A(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnCalcScalarFunction2Var::PutA ( double pRetVal ) {
    HRESULT _hr = put_A(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnCalcScalarPtr _IAgCrdnCalcScalarFunction2Var::GetY ( ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = get_Y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

void _IAgCrdnCalcScalarFunction2Var::PutY ( struct IAgCrdnCalcScalar * ppRetVal ) {
    HRESULT _hr = put_Y(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnCalcScalarFunction2Var::GetUnitY ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_UnitY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnCalcScalarFunction2Var::PutUnitY ( _bstr_t pRetVal ) {
    HRESULT _hr = put_UnitY(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnCalcScalarFunction2Var::GetB ( ) {
    double _result = 0;
    HRESULT _hr = get_B(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnCalcScalarFunction2Var::PutB ( double pRetVal ) {
    HRESULT _hr = put_B(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnCalcScalarFunction2Var::GetC ( ) {
    double _result = 0;
    HRESULT _hr = get_C(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnCalcScalarFunction2Var::PutC ( double pRetVal ) {
    HRESULT _hr = put_C(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnDimensionInheritance _IAgCrdnCalcScalarFunction2Var::GetOutputDimensionInheritance ( ) {
    enum AgECrdnDimensionInheritance _result;
    HRESULT _hr = get_OutputDimensionInheritance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnCalcScalarFunction2Var::PutOutputDimensionInheritance ( enum AgECrdnDimensionInheritance pRetVal ) {
    HRESULT _hr = put_OutputDimensionInheritance(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnCalcScalarFunction2Var::GetOutputDimension ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_OutputDimension(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnCalcScalarFunction2Var::PutOutputDimension ( _bstr_t pRetVal ) {
    HRESULT _hr = put_OutputDimension(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

SAFEARRAY * _IAgCrdnCalcScalarFunction2Var::GetAvailableFunctions ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_AvailableFunctions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnCalcScalarFunction2Var::GetSelectedFunction ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_SelectedFunction(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnCalcScalarFunction2Var::PutSelectedFunction ( _bstr_t pRetVal ) {
    HRESULT _hr = put_SelectedFunction(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnCalcScalarFunction2Var::GetOutputUnit ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_OutputUnit(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnCalcScalarFunction2Var::PutOutputUnit ( _bstr_t pRetVal ) {
    HRESULT _hr = put_OutputUnit(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnCalcScalarFunction2Var::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnCalcScalarFunction2Var::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnCalcScalarFunction2Var::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnCalcScalarFunction2Var::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnCalcScalarFunction2Var::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnCalcScalarFunction2Var::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarFunction2Var::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnCalcScalarFunction2Var::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnCalcScalarFunction2Var::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnCalcScalarFunction2Var::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarFunction2Var::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnCalcScalarFunction2Var::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnCalcScalarFunction2Var::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnCalcScalarFunction2Var::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnCalcScalarFunction2Var::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarFunction2Var::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnCalcScalarFunction2Var::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnCalcScalarFunction2Var::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnCalcScalarFunction2Var::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

_bstr_t _IAgCrdnCalcScalarFunction2Var::GetUnitOfMeasure ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_UnitOfMeasure(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT _IAgCrdnCalcScalarFunction2Var::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgCrdnCalcScalarFunction2Var::QuickEvaluateArray ( SAFEARRAY * * Times ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateArray(Times, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarFunction2Var::QuickEvaluateWithRateArray ( SAFEARRAY * * Times ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRateArray(Times, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarFunction2Var::QuickEvaluateEventArray ( struct IAgCrdnEventArray * RefArray ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateEventArray(RefArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarFunction2Var::QuickEvaluateWithRateEventArray ( struct IAgCrdnEventArray * RefArray ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRateEventArray(RefArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnCalcScalarIntegral wrapper method implementations
//

enum AgECrdnCalcScalarType _IAgCrdnCalcScalarIntegral::GetType ( ) {
    enum AgECrdnCalcScalarType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEvaluateResultPtr _IAgCrdnCalcScalarIntegral::Evaluate ( const _variant_t & Epoch ) {
    struct IAgCrdnEvaluateResult * _result = 0;
    HRESULT _hr = raw_Evaluate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEvaluateResultPtr(_result, false);
}

SAFEARRAY * _IAgCrdnCalcScalarIntegral::QuickEvaluate ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEvaluateWithRateResultPtr _IAgCrdnCalcScalarIntegral::EvaluateWithRate ( const _variant_t & Epoch ) {
    struct IAgCrdnEvaluateWithRateResult * _result = 0;
    HRESULT _hr = raw_EvaluateWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEvaluateWithRateResultPtr(_result, false);
}

SAFEARRAY * _IAgCrdnCalcScalarIntegral::QuickEvaluateWithRate ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCalcScalarPtr _IAgCrdnCalcScalarIntegral::GetInputScalar ( ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = get_InputScalar(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

void _IAgCrdnCalcScalarIntegral::PutInputScalar ( struct IAgCrdnCalcScalar * ppRetVal ) {
    HRESULT _hr = put_InputScalar(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnCalcScalarIntegral::GetComputeAsAverage ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ComputeAsAverage(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnCalcScalarIntegral::PutComputeAsAverage ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_ComputeAsAverage(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnIntegrationWindowType _IAgCrdnCalcScalarIntegral::GetIntegrationWindowType ( ) {
    enum AgECrdnIntegrationWindowType _result;
    HRESULT _hr = get_IntegrationWindowType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnCalcScalarIntegral::PutIntegrationWindowType ( enum AgECrdnIntegrationWindowType pRetVal ) {
    HRESULT _hr = put_IntegrationWindowType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnCalcScalarIntegral::GetStartOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_StartOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnCalcScalarIntegral::PutStartOffset ( double pRetVal ) {
    HRESULT _hr = put_StartOffset(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnCalcScalarIntegral::GetStopOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_StopOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnCalcScalarIntegral::PutStopOffset ( double pRetVal ) {
    HRESULT _hr = put_StopOffset(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnCalcScalarIntegral::GetUseCustomTimeLimits ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseCustomTimeLimits(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnCalcScalarIntegral::PutUseCustomTimeLimits ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseCustomTimeLimits(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnEventIntervalListPtr _IAgCrdnCalcScalarIntegral::GetCustomTimeLimits ( ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = get_CustomTimeLimits(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

void _IAgCrdnCalcScalarIntegral::PutCustomTimeLimits ( struct IAgCrdnEventIntervalList * ppRetVal ) {
    HRESULT _hr = put_CustomTimeLimits(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSaveDataOption _IAgCrdnCalcScalarIntegral::GetSaveDataOption ( ) {
    enum AgECrdnSaveDataOption _result;
    HRESULT _hr = get_SaveDataOption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnCalcScalarIntegral::PutSaveDataOption ( enum AgECrdnSaveDataOption pRetVal ) {
    HRESULT _hr = put_SaveDataOption(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnInterpPtr _IAgCrdnCalcScalarIntegral::GetInterpolation ( ) {
    struct IAgCrdnInterp * _result = 0;
    HRESULT _hr = get_Interpolation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnInterpPtr(_result, false);
}

void _IAgCrdnCalcScalarIntegral::PutInterpolation ( struct IAgCrdnInterp * ppRetVal ) {
    HRESULT _hr = put_Interpolation(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSamplingPtr _IAgCrdnCalcScalarIntegral::GetSampling ( ) {
    struct IAgCrdnSampling * _result = 0;
    HRESULT _hr = get_Sampling(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSamplingPtr(_result, false);
}

void _IAgCrdnCalcScalarIntegral::PutSampling ( struct IAgCrdnSampling * ppRetVal ) {
    HRESULT _hr = put_Sampling(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnIntegralPtr _IAgCrdnCalcScalarIntegral::GetIntegral ( ) {
    struct IAgCrdnIntegral * _result = 0;
    HRESULT _hr = get_Integral(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntegralPtr(_result, false);
}

void _IAgCrdnCalcScalarIntegral::PutIntegral ( struct IAgCrdnIntegral * ppRetVal ) {
    HRESULT _hr = put_Integral(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnCalcScalarIntegral::GetKeepConstantOutsideTimeLimits ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_KeepConstantOutsideTimeLimits(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnCalcScalarIntegral::PutKeepConstantOutsideTimeLimits ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_KeepConstantOutsideTimeLimits(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnCalcScalarIntegral::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnCalcScalarIntegral::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnCalcScalarIntegral::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnCalcScalarIntegral::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnCalcScalarIntegral::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnCalcScalarIntegral::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarIntegral::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnCalcScalarIntegral::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnCalcScalarIntegral::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnCalcScalarIntegral::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarIntegral::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnCalcScalarIntegral::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnCalcScalarIntegral::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnCalcScalarIntegral::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnCalcScalarIntegral::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarIntegral::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnCalcScalarIntegral::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnCalcScalarIntegral::SetOffsets ( double StartOffset, double StopOffset ) {
    HRESULT _hr = raw_SetOffsets(StartOffset, StopOffset);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnCalcScalarIntegral::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnCalcScalarIntegral::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

_bstr_t _IAgCrdnCalcScalarIntegral::GetUnitOfMeasure ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_UnitOfMeasure(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT _IAgCrdnCalcScalarIntegral::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgCrdnCalcScalarIntegral::QuickEvaluateArray ( SAFEARRAY * * Times ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateArray(Times, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarIntegral::QuickEvaluateWithRateArray ( SAFEARRAY * * Times ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRateArray(Times, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarIntegral::QuickEvaluateEventArray ( struct IAgCrdnEventArray * RefArray ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateEventArray(RefArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarIntegral::QuickEvaluateWithRateEventArray ( struct IAgCrdnEventArray * RefArray ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRateEventArray(RefArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnCalcScalarPlugin wrapper method implementations
//

enum AgECrdnCalcScalarType _IAgCrdnCalcScalarPlugin::GetType ( ) {
    enum AgECrdnCalcScalarType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEvaluateResultPtr _IAgCrdnCalcScalarPlugin::Evaluate ( const _variant_t & Epoch ) {
    struct IAgCrdnEvaluateResult * _result = 0;
    HRESULT _hr = raw_Evaluate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEvaluateResultPtr(_result, false);
}

SAFEARRAY * _IAgCrdnCalcScalarPlugin::QuickEvaluate ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEvaluateWithRateResultPtr _IAgCrdnCalcScalarPlugin::EvaluateWithRate ( const _variant_t & Epoch ) {
    struct IAgCrdnEvaluateWithRateResult * _result = 0;
    HRESULT _hr = raw_EvaluateWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEvaluateWithRateResultPtr(_result, false);
}

SAFEARRAY * _IAgCrdnCalcScalarPlugin::QuickEvaluateWithRate ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnCalcScalarPlugin::GetProgID ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ProgID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnCalcScalarPlugin::GetDisplayName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DisplayName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

SAFEARRAY * _IAgCrdnCalcScalarPlugin::GetAvailableProperties ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_AvailableProperties(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgCrdnCalcScalarPlugin::Reset ( ) {
    HRESULT _hr = raw_Reset();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnCalcScalarPlugin::SetProperty ( _bstr_t Name, _bstr_t Value ) {
    HRESULT _hr = raw_SetProperty(Name, Value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t _IAgCrdnCalcScalarPlugin::GetProperty ( _bstr_t Name ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetProperty(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

enum AgECrdnKind _IAgCrdnCalcScalarPlugin::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnCalcScalarPlugin::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnCalcScalarPlugin::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnCalcScalarPlugin::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnCalcScalarPlugin::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnCalcScalarPlugin::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarPlugin::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnCalcScalarPlugin::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnCalcScalarPlugin::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnCalcScalarPlugin::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarPlugin::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnCalcScalarPlugin::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnCalcScalarPlugin::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnCalcScalarPlugin::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnCalcScalarPlugin::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarPlugin::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnCalcScalarPlugin::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnCalcScalarPlugin::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnCalcScalarPlugin::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

_bstr_t _IAgCrdnCalcScalarPlugin::GetUnitOfMeasure ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_UnitOfMeasure(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT _IAgCrdnCalcScalarPlugin::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgCrdnCalcScalarPlugin::QuickEvaluateArray ( SAFEARRAY * * Times ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateArray(Times, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarPlugin::QuickEvaluateWithRateArray ( SAFEARRAY * * Times ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRateArray(Times, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarPlugin::QuickEvaluateEventArray ( struct IAgCrdnEventArray * RefArray ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateEventArray(RefArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarPlugin::QuickEvaluateWithRateEventArray ( struct IAgCrdnEventArray * RefArray ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRateEventArray(RefArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnCalcScalarSurfaceDistanceBetweenPoints wrapper method implementations
//

enum AgECrdnCalcScalarType _IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::GetType ( ) {
    enum AgECrdnCalcScalarType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEvaluateResultPtr _IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::Evaluate ( const _variant_t & Epoch ) {
    struct IAgCrdnEvaluateResult * _result = 0;
    HRESULT _hr = raw_Evaluate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEvaluateResultPtr(_result, false);
}

SAFEARRAY * _IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::QuickEvaluate ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEvaluateWithRateResultPtr _IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::EvaluateWithRate ( const _variant_t & Epoch ) {
    struct IAgCrdnEvaluateWithRateResult * _result = 0;
    HRESULT _hr = raw_EvaluateWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEvaluateWithRateResultPtr(_result, false);
}

SAFEARRAY * _IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::QuickEvaluateWithRate ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointPtr _IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::GetPoint1 ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = get_Point1(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

void _IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::PutPoint1 ( struct IAgCrdnPoint * ppRetVal ) {
    HRESULT _hr = put_Point1(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPointPtr _IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::GetPoint2 ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = get_Point2(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

void _IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::PutPoint2 ( struct IAgCrdnPoint * ppRetVal ) {
    HRESULT _hr = put_Point2(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::GetSurfaceCentralBody ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_SurfaceCentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::PutSurfaceCentralBody ( _bstr_t pRetVal ) {
    HRESULT _hr = put_SurfaceCentralBody(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::GetDifferencingTimeStep ( ) {
    double _result = 0;
    HRESULT _hr = get_DifferencingTimeStep(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::PutDifferencingTimeStep ( double pRetVal ) {
    HRESULT _hr = put_DifferencingTimeStep(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

_bstr_t _IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::GetUnitOfMeasure ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_UnitOfMeasure(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT _IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::QuickEvaluateArray ( SAFEARRAY * * Times ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateArray(Times, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::QuickEvaluateWithRateArray ( SAFEARRAY * * Times ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRateArray(Times, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::QuickEvaluateEventArray ( struct IAgCrdnEventArray * RefArray ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateEventArray(RefArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarSurfaceDistanceBetweenPoints::QuickEvaluateWithRateEventArray ( struct IAgCrdnEventArray * RefArray ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRateEventArray(RefArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnCalcScalarVectorMagnitude wrapper method implementations
//

enum AgECrdnCalcScalarType _IAgCrdnCalcScalarVectorMagnitude::GetType ( ) {
    enum AgECrdnCalcScalarType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEvaluateResultPtr _IAgCrdnCalcScalarVectorMagnitude::Evaluate ( const _variant_t & Epoch ) {
    struct IAgCrdnEvaluateResult * _result = 0;
    HRESULT _hr = raw_Evaluate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEvaluateResultPtr(_result, false);
}

SAFEARRAY * _IAgCrdnCalcScalarVectorMagnitude::QuickEvaluate ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEvaluateWithRateResultPtr _IAgCrdnCalcScalarVectorMagnitude::EvaluateWithRate ( const _variant_t & Epoch ) {
    struct IAgCrdnEvaluateWithRateResult * _result = 0;
    HRESULT _hr = raw_EvaluateWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEvaluateWithRateResultPtr(_result, false);
}

SAFEARRAY * _IAgCrdnCalcScalarVectorMagnitude::QuickEvaluateWithRate ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorPtr _IAgCrdnCalcScalarVectorMagnitude::GetInputVector ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_InputVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

void _IAgCrdnCalcScalarVectorMagnitude::PutInputVector ( struct IAgCrdnVector * ppRetVal ) {
    HRESULT _hr = put_InputVector(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnCalcScalarVectorMagnitude::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnCalcScalarVectorMagnitude::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnCalcScalarVectorMagnitude::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnCalcScalarVectorMagnitude::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnCalcScalarVectorMagnitude::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnCalcScalarVectorMagnitude::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarVectorMagnitude::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnCalcScalarVectorMagnitude::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnCalcScalarVectorMagnitude::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnCalcScalarVectorMagnitude::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarVectorMagnitude::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnCalcScalarVectorMagnitude::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnCalcScalarVectorMagnitude::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnCalcScalarVectorMagnitude::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnCalcScalarVectorMagnitude::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnCalcScalarVectorMagnitude::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnCalcScalarVectorMagnitude::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnCalcScalarVectorMagnitude::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnCalcScalarVectorMagnitude::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

_bstr_t _IAgCrdnCalcScalarVectorMagnitude::GetUnitOfMeasure ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_UnitOfMeasure(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

HRESULT _IAgCrdnCalcScalarVectorMagnitude::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

SAFEARRAY * _IAgCrdnCalcScalarVectorMagnitude::QuickEvaluateArray ( SAFEARRAY * * Times ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateArray(Times, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarVectorMagnitude::QuickEvaluateWithRateArray ( SAFEARRAY * * Times ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRateArray(Times, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarVectorMagnitude::QuickEvaluateEventArray ( struct IAgCrdnEventArray * RefArray ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateEventArray(RefArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnCalcScalarVectorMagnitude::QuickEvaluateWithRateEventArray ( struct IAgCrdnEventArray * RefArray ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_QuickEvaluateWithRateEventArray(RefArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _IAgCrdnCondition wrapper method implementations
//

enum AgECrdnConditionType _IAgCrdnCondition::GetType ( ) {
    enum AgECrdnConditionType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEvaluateResultPtr _IAgCrdnCondition::Evaluate ( const _variant_t & Epoch ) {
    struct IAgCrdnEvaluateResult * _result = 0;
    HRESULT _hr = raw_Evaluate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEvaluateResultPtr(_result, false);
}

IAgCrdnEvaluateWithRateResultPtr _IAgCrdnCondition::EvaluateWithRate ( const _variant_t & Epoch ) {
    struct IAgCrdnEvaluateWithRateResult * _result = 0;
    HRESULT _hr = raw_EvaluateWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEvaluateWithRateResultPtr(_result, false);
}

enum AgECrdnKind _IAgCrdnCondition::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnCondition::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnCondition::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnCondition::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnCondition::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnCondition::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnCondition::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnCondition::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnCondition::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnCondition::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnCondition::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnCondition::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnCondition::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnCondition::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnCondition::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnCondition::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnCondition::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnCondition::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnCondition::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnConditionCombined wrapper method implementations
//

enum AgECrdnConditionType _IAgCrdnConditionCombined::GetType ( ) {
    enum AgECrdnConditionType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEvaluateResultPtr _IAgCrdnConditionCombined::Evaluate ( const _variant_t & Epoch ) {
    struct IAgCrdnEvaluateResult * _result = 0;
    HRESULT _hr = raw_Evaluate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEvaluateResultPtr(_result, false);
}

IAgCrdnEvaluateWithRateResultPtr _IAgCrdnConditionCombined::EvaluateWithRate ( const _variant_t & Epoch ) {
    struct IAgCrdnEvaluateWithRateResult * _result = 0;
    HRESULT _hr = raw_EvaluateWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEvaluateWithRateResultPtr(_result, false);
}

enum AgECrdnConditionCombinedOperationType _IAgCrdnConditionCombined::GetCombineOperation ( ) {
    enum AgECrdnConditionCombinedOperationType _result;
    HRESULT _hr = get_CombineOperation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnConditionCombined::PutCombineOperation ( enum AgECrdnConditionCombinedOperationType pRetVal ) {
    HRESULT _hr = put_CombineOperation(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

int _IAgCrdnConditionCombined::GetConditionCount ( ) {
    int _result = 0;
    HRESULT _hr = get_ConditionCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnConditionCombined::GetAllConditions ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetAllConditions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgCrdnConditionCombined::SetAllConditions ( SAFEARRAY * * Conditions ) {
    HRESULT _hr = raw_SetAllConditions(Conditions);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnConditionPtr _IAgCrdnConditionCombined::GetCondition ( int Pos ) {
    struct IAgCrdnCondition * _result = 0;
    HRESULT _hr = raw_GetCondition(Pos, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConditionPtr(_result, false);
}

HRESULT _IAgCrdnConditionCombined::SetCondition ( struct IAgCrdnCondition * Ref, int Pos ) {
    HRESULT _hr = raw_SetCondition(Ref, Pos);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnConditionCombined::RemoveCondition ( int Pos ) {
    HRESULT _hr = raw_RemoveCondition(Pos);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

enum AgECrdnKind _IAgCrdnConditionCombined::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnConditionCombined::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnConditionCombined::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnConditionCombined::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnConditionCombined::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnConditionCombined::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnConditionCombined::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnConditionCombined::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnConditionCombined::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnConditionCombined::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnConditionCombined::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnConditionCombined::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnConditionCombined::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnConditionCombined::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnConditionCombined::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnConditionCombined::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnConditionCombined::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnConditionCombined::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnConditionCombined::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnConditionCombined::AddCondition ( struct IAgCrdnCondition * Ref ) {
    HRESULT _hr = raw_AddCondition(Ref);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnConditionScalarBounds wrapper method implementations
//

enum AgECrdnConditionType _IAgCrdnConditionScalarBounds::GetType ( ) {
    enum AgECrdnConditionType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEvaluateResultPtr _IAgCrdnConditionScalarBounds::Evaluate ( const _variant_t & Epoch ) {
    struct IAgCrdnEvaluateResult * _result = 0;
    HRESULT _hr = raw_Evaluate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEvaluateResultPtr(_result, false);
}

IAgCrdnEvaluateWithRateResultPtr _IAgCrdnConditionScalarBounds::EvaluateWithRate ( const _variant_t & Epoch ) {
    struct IAgCrdnEvaluateWithRateResult * _result = 0;
    HRESULT _hr = raw_EvaluateWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEvaluateWithRateResultPtr(_result, false);
}

IAgCrdnCalcScalarPtr _IAgCrdnConditionScalarBounds::GetScalar ( ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = get_Scalar(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

void _IAgCrdnConditionScalarBounds::PutScalar ( struct IAgCrdnCalcScalar * ppRetVal ) {
    HRESULT _hr = put_Scalar(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnConditionThresholdOption _IAgCrdnConditionScalarBounds::GetOperation ( ) {
    enum AgECrdnConditionThresholdOption _result;
    HRESULT _hr = get_Operation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnConditionScalarBounds::PutOperation ( enum AgECrdnConditionThresholdOption pRetVal ) {
    HRESULT _hr = put_Operation(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

STKUtil::IAgQuantityPtr _IAgCrdnConditionScalarBounds::GetMinimum ( ) {
    struct STKUtil::IAgQuantity * _result = 0;
    HRESULT _hr = raw_GetMinimum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgQuantityPtr(_result, false);
}

HRESULT _IAgCrdnConditionScalarBounds::SetMinimum ( struct STKUtil::IAgQuantity * Value ) {
    HRESULT _hr = raw_SetMinimum(Value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

STKUtil::IAgQuantityPtr _IAgCrdnConditionScalarBounds::GetMaximum ( ) {
    struct STKUtil::IAgQuantity * _result = 0;
    HRESULT _hr = raw_GetMaximum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgQuantityPtr(_result, false);
}

HRESULT _IAgCrdnConditionScalarBounds::SetMaximum ( struct STKUtil::IAgQuantity * Value ) {
    HRESULT _hr = raw_SetMaximum(Value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnConditionScalarBounds::Set ( struct STKUtil::IAgQuantity * Min, struct STKUtil::IAgQuantity * Max ) {
    HRESULT _hr = raw_Set(Min, Max);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

enum AgECrdnKind _IAgCrdnConditionScalarBounds::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnConditionScalarBounds::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnConditionScalarBounds::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnConditionScalarBounds::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnConditionScalarBounds::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnConditionScalarBounds::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnConditionScalarBounds::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnConditionScalarBounds::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnConditionScalarBounds::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnConditionScalarBounds::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnConditionScalarBounds::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnConditionScalarBounds::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnConditionScalarBounds::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnConditionScalarBounds::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnConditionScalarBounds::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnConditionScalarBounds::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnConditionScalarBounds::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnConditionScalarBounds::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnConditionScalarBounds::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnConditionSet wrapper method implementations
//

enum AgECrdnConditionSetType _IAgCrdnConditionSet::GetType ( ) {
    enum AgECrdnConditionSetType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnConditionSetEvaluateResultPtr _IAgCrdnConditionSet::Evaluate ( const _variant_t & Epoch ) {
    struct IAgCrdnConditionSetEvaluateResult * _result = 0;
    HRESULT _hr = raw_Evaluate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConditionSetEvaluateResultPtr(_result, false);
}

IAgCrdnConditionSetEvaluateWithRateResultPtr _IAgCrdnConditionSet::EvaluateWithRate ( const _variant_t & Epoch ) {
    struct IAgCrdnConditionSetEvaluateWithRateResult * _result = 0;
    HRESULT _hr = raw_EvaluateWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConditionSetEvaluateWithRateResultPtr(_result, false);
}

enum AgECrdnKind _IAgCrdnConditionSet::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnConditionSet::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnConditionSet::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnConditionSet::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnConditionSet::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnConditionSet::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnConditionSet::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnConditionSet::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnConditionSet::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnConditionSet::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnConditionSet::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnConditionSet::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnConditionSet::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnConditionSet::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnConditionSet::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnConditionSet::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnConditionSet::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnConditionSet::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnConditionSet::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnConditionSetScalarThresholds wrapper method implementations
//

enum AgECrdnConditionSetType _IAgCrdnConditionSetScalarThresholds::GetType ( ) {
    enum AgECrdnConditionSetType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnConditionSetEvaluateResultPtr _IAgCrdnConditionSetScalarThresholds::Evaluate ( const _variant_t & Epoch ) {
    struct IAgCrdnConditionSetEvaluateResult * _result = 0;
    HRESULT _hr = raw_Evaluate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConditionSetEvaluateResultPtr(_result, false);
}

IAgCrdnConditionSetEvaluateWithRateResultPtr _IAgCrdnConditionSetScalarThresholds::EvaluateWithRate ( const _variant_t & Epoch ) {
    struct IAgCrdnConditionSetEvaluateWithRateResult * _result = 0;
    HRESULT _hr = raw_EvaluateWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConditionSetEvaluateWithRateResultPtr(_result, false);
}

IAgCrdnCalcScalarPtr _IAgCrdnConditionSetScalarThresholds::GetScalar ( ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = get_Scalar(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

void _IAgCrdnConditionSetScalarThresholds::PutScalar ( struct IAgCrdnCalcScalar * ppRetVal ) {
    HRESULT _hr = put_Scalar(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

SAFEARRAY * _IAgCrdnConditionSetScalarThresholds::GetThresholds ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Thresholds(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnConditionSetScalarThresholds::GetThresholdLabels ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_ThresholdLabels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnConditionSetScalarThresholds::GetIncludeAboveHighestThreshold ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IncludeAboveHighestThreshold(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnConditionSetScalarThresholds::PutIncludeAboveHighestThreshold ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_IncludeAboveHighestThreshold(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnConditionSetScalarThresholds::GetIncludeBelowLowestThreshold ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IncludeBelowLowestThreshold(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnConditionSetScalarThresholds::PutIncludeBelowLowestThreshold ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_IncludeBelowLowestThreshold(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgCrdnConditionSetScalarThresholds::SetThresholdsAndLabels ( SAFEARRAY * * Thresholds, SAFEARRAY * * ThresholdLabels ) {
    HRESULT _hr = raw_SetThresholdsAndLabels(Thresholds, ThresholdLabels);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

enum AgECrdnKind _IAgCrdnConditionSetScalarThresholds::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnConditionSetScalarThresholds::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnConditionSetScalarThresholds::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnConditionSetScalarThresholds::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnConditionSetScalarThresholds::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnConditionSetScalarThresholds::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnConditionSetScalarThresholds::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnConditionSetScalarThresholds::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnConditionSetScalarThresholds::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnConditionSetScalarThresholds::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnConditionSetScalarThresholds::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnConditionSetScalarThresholds::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnConditionSetScalarThresholds::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnConditionSetScalarThresholds::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnConditionSetScalarThresholds::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnConditionSetScalarThresholds::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnConditionSetScalarThresholds::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnConditionSetScalarThresholds::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnConditionSetScalarThresholds::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnConverge wrapper method implementations
//

enum AgECrdnKind _IAgCrdnConverge::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnConverge::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnConverge::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnConverge::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnConverge::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnConverge::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnConverge::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnConverge::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnConverge::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnConverge::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnConverge::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnConverge::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnConverge::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnConverge::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnConverge::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnConverge::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnConverge::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnConverge::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnConverge::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnConvergeBasic wrapper method implementations
//

enum AgECrdnThreshConvergeSense _IAgCrdnConvergeBasic::GetSense ( ) {
    enum AgECrdnThreshConvergeSense _result;
    HRESULT _hr = get_Sense(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnConvergeBasic::PutSense ( enum AgECrdnThreshConvergeSense pRetVal ) {
    HRESULT _hr = put_Sense(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnConvergeBasic::GetTimeTolerance ( ) {
    double _result = 0;
    HRESULT _hr = get_TimeTolerance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnConvergeBasic::PutTimeTolerance ( double pRetVal ) {
    HRESULT _hr = put_TimeTolerance(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnConvergeBasic::GetAbsoluteTolerance ( ) {
    double _result = 0;
    HRESULT _hr = get_AbsoluteTolerance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnConvergeBasic::PutAbsoluteTolerance ( double pRetVal ) {
    HRESULT _hr = put_AbsoluteTolerance(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnConvergeBasic::GetRelativeTolerance ( ) {
    double _result = 0;
    HRESULT _hr = get_RelativeTolerance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnConvergeBasic::PutRelativeTolerance ( double pRetVal ) {
    HRESULT _hr = put_RelativeTolerance(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnConvergeBasic::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnConvergeBasic::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnConvergeBasic::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnConvergeBasic::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnConvergeBasic::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnConvergeBasic::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnConvergeBasic::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnConvergeBasic::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnConvergeBasic::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnConvergeBasic::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnConvergeBasic::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnConvergeBasic::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnConvergeBasic::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnConvergeBasic::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnConvergeBasic::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnConvergeBasic::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnConvergeBasic::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnConvergeBasic::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnConvergeBasic::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnDerivative wrapper method implementations
//

enum AgECrdnKind _IAgCrdnDerivative::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnDerivative::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnDerivative::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnDerivative::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnDerivative::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnDerivative::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnDerivative::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnDerivative::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnDerivative::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnDerivative::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnDerivative::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnDerivative::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnDerivative::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnDerivative::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnDerivative::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnDerivative::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnDerivative::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnDerivative::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnDerivative::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnDerivativeBasic wrapper method implementations
//

double _IAgCrdnDerivativeBasic::GetTimeStep ( ) {
    double _result = 0;
    HRESULT _hr = get_TimeStep(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnDerivativeBasic::PutTimeStep ( double pRetVal ) {
    HRESULT _hr = put_TimeStep(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnDerivativeBasic::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnDerivativeBasic::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnDerivativeBasic::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnDerivativeBasic::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnDerivativeBasic::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnDerivativeBasic::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnDerivativeBasic::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnDerivativeBasic::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnDerivativeBasic::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnDerivativeBasic::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnDerivativeBasic::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnDerivativeBasic::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnDerivativeBasic::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnDerivativeBasic::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnDerivativeBasic::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnDerivativeBasic::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnDerivativeBasic::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnDerivativeBasic::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnDerivativeBasic::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnEvent wrapper method implementations
//

enum AgECrdnEventType _IAgCrdnEvent::GetType ( ) {
    enum AgECrdnEventType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEventPtr _IAgCrdnEvent::GetToday ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_Today(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventPtr _IAgCrdnEvent::GetTomorrow ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_Tomorrow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventPtr _IAgCrdnEvent::GetNoonToday ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_NoonToday(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventPtr _IAgCrdnEvent::GetNoonTomorrow ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_NoonTomorrow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventFindOccurrenceResultPtr _IAgCrdnEvent::FindOccurrence ( ) {
    struct IAgCrdnEventFindOccurrenceResult * _result = 0;
    HRESULT _hr = raw_FindOccurrence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventFindOccurrenceResultPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEvent::OccursBefore ( const _variant_t & Epoch ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_OccursBefore(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

enum AgECrdnKind _IAgCrdnEvent::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEvent::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnEvent::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnEvent::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEvent::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEvent::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEvent::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnEvent::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnEvent::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnEvent::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEvent::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEvent::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEvent::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnEvent::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnEvent::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEvent::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnEvent::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnEvent::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEvent::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnEventArray wrapper method implementations
//

enum AgECrdnEventArrayType _IAgCrdnEventArray::GetType ( ) {
    enum AgECrdnEventArrayType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnFindTimesResultPtr _IAgCrdnEventArray::FindTimes ( ) {
    struct IAgCrdnFindTimesResult * _result = 0;
    HRESULT _hr = raw_FindTimes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnFindTimesResultPtr(_result, false);
}

enum AgECrdnKind _IAgCrdnEventArray::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventArray::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnEventArray::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnEventArray::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventArray::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventArray::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventArray::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnEventArray::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnEventArray::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnEventArray::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventArray::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventArray::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventArray::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnEventArray::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnEventArray::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventArray::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnEventArray::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnEventArray::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventArray::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnEventArrayConditionCrossings wrapper method implementations
//

enum AgECrdnEventArrayType _IAgCrdnEventArrayConditionCrossings::GetType ( ) {
    enum AgECrdnEventArrayType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnFindTimesResultPtr _IAgCrdnEventArrayConditionCrossings::FindTimes ( ) {
    struct IAgCrdnFindTimesResult * _result = 0;
    HRESULT _hr = raw_FindTimes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnFindTimesResultPtr(_result, false);
}

enum AgECrdnSatisfactionCrossing _IAgCrdnEventArrayConditionCrossings::GetSatisfactionCrossing ( ) {
    enum AgECrdnSatisfactionCrossing _result;
    HRESULT _hr = get_SatisfactionCrossing(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventArrayConditionCrossings::PutSatisfactionCrossing ( enum AgECrdnSatisfactionCrossing pRetVal ) {
    HRESULT _hr = put_SatisfactionCrossing(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnConditionPtr _IAgCrdnEventArrayConditionCrossings::GetCondition ( ) {
    struct IAgCrdnCondition * _result = 0;
    HRESULT _hr = get_Condition(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConditionPtr(_result, false);
}

void _IAgCrdnEventArrayConditionCrossings::PutCondition ( struct IAgCrdnCondition * ppRetVal ) {
    HRESULT _hr = put_Condition(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnEventIntervalListPtr _IAgCrdnEventArrayConditionCrossings::GetCustomTimeLimits ( ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = get_CustomTimeLimits(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

void _IAgCrdnEventArrayConditionCrossings::PutCustomTimeLimits ( struct IAgCrdnEventIntervalList * ppRetVal ) {
    HRESULT _hr = put_CustomTimeLimits(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnEventArrayConditionCrossings::GetUseCustomTimeLimits ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseCustomTimeLimits(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventArrayConditionCrossings::PutUseCustomTimeLimits ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseCustomTimeLimits(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSaveDataOption _IAgCrdnEventArrayConditionCrossings::GetSaveDataOption ( ) {
    enum AgECrdnSaveDataOption _result;
    HRESULT _hr = get_SaveDataOption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventArrayConditionCrossings::PutSaveDataOption ( enum AgECrdnSaveDataOption pRetVal ) {
    HRESULT _hr = put_SaveDataOption(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSamplingPtr _IAgCrdnEventArrayConditionCrossings::GetSampling ( ) {
    struct IAgCrdnSampling * _result = 0;
    HRESULT _hr = get_Sampling(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSamplingPtr(_result, false);
}

void _IAgCrdnEventArrayConditionCrossings::PutSampling ( struct IAgCrdnSampling * ppRetVal ) {
    HRESULT _hr = put_Sampling(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnConvergePtr _IAgCrdnEventArrayConditionCrossings::GetConvergence ( ) {
    struct IAgCrdnConverge * _result = 0;
    HRESULT _hr = get_Convergence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConvergePtr(_result, false);
}

void _IAgCrdnEventArrayConditionCrossings::PutConvergence ( struct IAgCrdnConverge * ppRetVal ) {
    HRESULT _hr = put_Convergence(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnEventArrayConditionCrossings::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventArrayConditionCrossings::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnEventArrayConditionCrossings::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnEventArrayConditionCrossings::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventArrayConditionCrossings::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventArrayConditionCrossings::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventArrayConditionCrossings::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnEventArrayConditionCrossings::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnEventArrayConditionCrossings::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnEventArrayConditionCrossings::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventArrayConditionCrossings::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventArrayConditionCrossings::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventArrayConditionCrossings::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnEventArrayConditionCrossings::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnEventArrayConditionCrossings::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventArrayConditionCrossings::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnEventArrayConditionCrossings::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnEventArrayConditionCrossings::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventArrayConditionCrossings::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnEventArrayExtrema wrapper method implementations
//

enum AgECrdnEventArrayType _IAgCrdnEventArrayExtrema::GetType ( ) {
    enum AgECrdnEventArrayType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnFindTimesResultPtr _IAgCrdnEventArrayExtrema::FindTimes ( ) {
    struct IAgCrdnFindTimesResult * _result = 0;
    HRESULT _hr = raw_FindTimes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnFindTimesResultPtr(_result, false);
}

enum AgECrdnExtremumConstants _IAgCrdnEventArrayExtrema::GetExtremumType ( ) {
    enum AgECrdnExtremumConstants _result;
    HRESULT _hr = get_ExtremumType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventArrayExtrema::PutExtremumType ( enum AgECrdnExtremumConstants pRetVal ) {
    HRESULT _hr = put_ExtremumType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnEventArrayExtrema::GetIsGlobal ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsGlobal(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventArrayExtrema::PutIsGlobal ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_IsGlobal(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnCalcScalarPtr _IAgCrdnEventArrayExtrema::GetCalculation ( ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = get_Calculation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

void _IAgCrdnEventArrayExtrema::PutCalculation ( struct IAgCrdnCalcScalar * ppRetVal ) {
    HRESULT _hr = put_Calculation(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnEventIntervalListPtr _IAgCrdnEventArrayExtrema::GetCustomTimeLimits ( ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = get_CustomTimeLimits(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

void _IAgCrdnEventArrayExtrema::PutCustomTimeLimits ( struct IAgCrdnEventIntervalList * ppRetVal ) {
    HRESULT _hr = put_CustomTimeLimits(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnEventArrayExtrema::GetUseCustomTimeLimits ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseCustomTimeLimits(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventArrayExtrema::PutUseCustomTimeLimits ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseCustomTimeLimits(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSaveDataOption _IAgCrdnEventArrayExtrema::GetSaveDataOption ( ) {
    enum AgECrdnSaveDataOption _result;
    HRESULT _hr = get_SaveDataOption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventArrayExtrema::PutSaveDataOption ( enum AgECrdnSaveDataOption pRetVal ) {
    HRESULT _hr = put_SaveDataOption(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSamplingPtr _IAgCrdnEventArrayExtrema::GetSampling ( ) {
    struct IAgCrdnSampling * _result = 0;
    HRESULT _hr = get_Sampling(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSamplingPtr(_result, false);
}

void _IAgCrdnEventArrayExtrema::PutSampling ( struct IAgCrdnSampling * ppRetVal ) {
    HRESULT _hr = put_Sampling(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnConvergePtr _IAgCrdnEventArrayExtrema::GetConvergence ( ) {
    struct IAgCrdnConverge * _result = 0;
    HRESULT _hr = get_Convergence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConvergePtr(_result, false);
}

void _IAgCrdnEventArrayExtrema::PutConvergence ( struct IAgCrdnConverge * ppRetVal ) {
    HRESULT _hr = put_Convergence(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnEventArrayExtrema::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventArrayExtrema::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnEventArrayExtrema::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnEventArrayExtrema::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventArrayExtrema::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventArrayExtrema::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventArrayExtrema::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnEventArrayExtrema::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnEventArrayExtrema::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnEventArrayExtrema::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventArrayExtrema::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventArrayExtrema::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventArrayExtrema::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnEventArrayExtrema::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnEventArrayExtrema::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventArrayExtrema::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnEventArrayExtrema::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnEventArrayExtrema::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventArrayExtrema::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnEventArrayFiltered wrapper method implementations
//

enum AgECrdnEventArrayType _IAgCrdnEventArrayFiltered::GetType ( ) {
    enum AgECrdnEventArrayType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnFindTimesResultPtr _IAgCrdnEventArrayFiltered::FindTimes ( ) {
    struct IAgCrdnFindTimesResult * _result = 0;
    HRESULT _hr = raw_FindTimes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnFindTimesResultPtr(_result, false);
}

IAgCrdnEventArrayPtr _IAgCrdnEventArrayFiltered::GetOriginalTimeArray ( ) {
    struct IAgCrdnEventArray * _result = 0;
    HRESULT _hr = get_OriginalTimeArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventArrayPtr(_result, false);
}

void _IAgCrdnEventArrayFiltered::PutOriginalTimeArray ( struct IAgCrdnEventArray * ppRetVal ) {
    HRESULT _hr = put_OriginalTimeArray(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnEventArrayFilterType _IAgCrdnEventArrayFiltered::GetFilterType ( ) {
    enum AgECrdnEventArrayFilterType _result;
    HRESULT _hr = get_FilterType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventArrayFiltered::PutFilterType ( enum AgECrdnEventArrayFilterType pRetVal ) {
    HRESULT _hr = put_FilterType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

int _IAgCrdnEventArrayFiltered::GetCount ( ) {
    int _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventArrayFiltered::PutCount ( int pRetVal ) {
    HRESULT _hr = put_Count(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnEventArrayFiltered::GetStep ( ) {
    double _result = 0;
    HRESULT _hr = get_Step(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventArrayFiltered::PutStep ( double pRetVal ) {
    HRESULT _hr = put_Step(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnEventArrayFiltered::GetIncludeIntervalStopTimes ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IncludeIntervalStopTimes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventArrayFiltered::PutIncludeIntervalStopTimes ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_IncludeIntervalStopTimes(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnEventArrayFiltered::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventArrayFiltered::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnEventArrayFiltered::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnEventArrayFiltered::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventArrayFiltered::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventArrayFiltered::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventArrayFiltered::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnEventArrayFiltered::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnEventArrayFiltered::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnEventArrayFiltered::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventArrayFiltered::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventArrayFiltered::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventArrayFiltered::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnEventArrayFiltered::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnEventArrayFiltered::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventArrayFiltered::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnEventArrayFiltered::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnEventArrayFiltered::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventArrayFiltered::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnEventArrayFixedStep wrapper method implementations
//

enum AgECrdnEventArrayType _IAgCrdnEventArrayFixedStep::GetType ( ) {
    enum AgECrdnEventArrayType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnFindTimesResultPtr _IAgCrdnEventArrayFixedStep::FindTimes ( ) {
    struct IAgCrdnFindTimesResult * _result = 0;
    HRESULT _hr = raw_FindTimes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnFindTimesResultPtr(_result, false);
}

IAgCrdnEventIntervalListPtr _IAgCrdnEventArrayFixedStep::GetBoundingIntervalList ( ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = get_BoundingIntervalList(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

void _IAgCrdnEventArrayFixedStep::PutBoundingIntervalList ( struct IAgCrdnEventIntervalList * ppRetVal ) {
    HRESULT _hr = put_BoundingIntervalList(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnEventArrayFixedStep::GetSamplingTimeStep ( ) {
    double _result = 0;
    HRESULT _hr = get_SamplingTimeStep(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventArrayFixedStep::PutSamplingTimeStep ( double pRetVal ) {
    HRESULT _hr = put_SamplingTimeStep(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnEventArrayFixedStep::GetIncludeIntervalEdges ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IncludeIntervalEdges(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventArrayFixedStep::PutIncludeIntervalEdges ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_IncludeIntervalEdges(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSampledReferenceTime _IAgCrdnEventArrayFixedStep::GetReferenceType ( ) {
    enum AgECrdnSampledReferenceTime _result;
    HRESULT _hr = get_ReferenceType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventArrayFixedStep::PutReferenceType ( enum AgECrdnSampledReferenceTime pRetVal ) {
    HRESULT _hr = put_ReferenceType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnEventPtr _IAgCrdnEventArrayFixedStep::GetReferenceTimeInstant ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_ReferenceTimeInstant(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

void _IAgCrdnEventArrayFixedStep::PutReferenceTimeInstant ( struct IAgCrdnEvent * ppRetVal ) {
    HRESULT _hr = put_ReferenceTimeInstant(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnEventArrayFixedStep::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventArrayFixedStep::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnEventArrayFixedStep::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnEventArrayFixedStep::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventArrayFixedStep::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventArrayFixedStep::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventArrayFixedStep::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnEventArrayFixedStep::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnEventArrayFixedStep::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnEventArrayFixedStep::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventArrayFixedStep::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventArrayFixedStep::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventArrayFixedStep::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnEventArrayFixedStep::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnEventArrayFixedStep::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventArrayFixedStep::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnEventArrayFixedStep::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnEventArrayFixedStep::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventArrayFixedStep::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnEventArrayFixedTimes wrapper method implementations
//

enum AgECrdnEventArrayType _IAgCrdnEventArrayFixedTimes::GetType ( ) {
    enum AgECrdnEventArrayType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnFindTimesResultPtr _IAgCrdnEventArrayFixedTimes::FindTimes ( ) {
    struct IAgCrdnFindTimesResult * _result = 0;
    HRESULT _hr = raw_FindTimes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnFindTimesResultPtr(_result, false);
}

SAFEARRAY * _IAgCrdnEventArrayFixedTimes::GetArrayTimes ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_ArrayTimes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgCrdnEventArrayFixedTimes::SetArrayTimes ( SAFEARRAY * * Times ) {
    HRESULT _hr = raw_SetArrayTimes(Times);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

enum AgECrdnKind _IAgCrdnEventArrayFixedTimes::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventArrayFixedTimes::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnEventArrayFixedTimes::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnEventArrayFixedTimes::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventArrayFixedTimes::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventArrayFixedTimes::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventArrayFixedTimes::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnEventArrayFixedTimes::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnEventArrayFixedTimes::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnEventArrayFixedTimes::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventArrayFixedTimes::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventArrayFixedTimes::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventArrayFixedTimes::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnEventArrayFixedTimes::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnEventArrayFixedTimes::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventArrayFixedTimes::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnEventArrayFixedTimes::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnEventArrayFixedTimes::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventArrayFixedTimes::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnEventArrayMerged wrapper method implementations
//

enum AgECrdnEventArrayType _IAgCrdnEventArrayMerged::GetType ( ) {
    enum AgECrdnEventArrayType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnFindTimesResultPtr _IAgCrdnEventArrayMerged::FindTimes ( ) {
    struct IAgCrdnFindTimesResult * _result = 0;
    HRESULT _hr = raw_FindTimes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnFindTimesResultPtr(_result, false);
}

IAgCrdnEventArrayPtr _IAgCrdnEventArrayMerged::GetTimeArrayA ( ) {
    struct IAgCrdnEventArray * _result = 0;
    HRESULT _hr = get_TimeArrayA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventArrayPtr(_result, false);
}

void _IAgCrdnEventArrayMerged::PutTimeArrayA ( struct IAgCrdnEventArray * ppRetVal ) {
    HRESULT _hr = put_TimeArrayA(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnEventArrayPtr _IAgCrdnEventArrayMerged::GetTimeArrayB ( ) {
    struct IAgCrdnEventArray * _result = 0;
    HRESULT _hr = get_TimeArrayB(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventArrayPtr(_result, false);
}

void _IAgCrdnEventArrayMerged::PutTimeArrayB ( struct IAgCrdnEventArray * ppRetVal ) {
    HRESULT _hr = put_TimeArrayB(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnEventArrayMerged::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventArrayMerged::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnEventArrayMerged::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnEventArrayMerged::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventArrayMerged::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventArrayMerged::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventArrayMerged::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnEventArrayMerged::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnEventArrayMerged::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnEventArrayMerged::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventArrayMerged::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventArrayMerged::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventArrayMerged::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnEventArrayMerged::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnEventArrayMerged::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventArrayMerged::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnEventArrayMerged::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnEventArrayMerged::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventArrayMerged::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnEventArraySignaled wrapper method implementations
//

enum AgECrdnEventArrayType _IAgCrdnEventArraySignaled::GetType ( ) {
    enum AgECrdnEventArrayType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnFindTimesResultPtr _IAgCrdnEventArraySignaled::FindTimes ( ) {
    struct IAgCrdnFindTimesResult * _result = 0;
    HRESULT _hr = raw_FindTimes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnFindTimesResultPtr(_result, false);
}

IAgCrdnEventArrayPtr _IAgCrdnEventArraySignaled::GetOriginalTimeArray ( ) {
    struct IAgCrdnEventArray * _result = 0;
    HRESULT _hr = get_OriginalTimeArray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventArrayPtr(_result, false);
}

void _IAgCrdnEventArraySignaled::PutOriginalTimeArray ( struct IAgCrdnEventArray * ppRetVal ) {
    HRESULT _hr = put_OriginalTimeArray(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSignalSense _IAgCrdnEventArraySignaled::GetSignalSense ( ) {
    enum AgECrdnSignalSense _result;
    HRESULT _hr = get_SignalSense(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventArraySignaled::PutSignalSense ( enum AgECrdnSignalSense pRetVal ) {
    HRESULT _hr = put_SignalSense(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPointPtr _IAgCrdnEventArraySignaled::GetBaseClockLocation ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = get_BaseClockLocation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

void _IAgCrdnEventArraySignaled::PutBaseClockLocation ( struct IAgCrdnPoint * ppRetVal ) {
    HRESULT _hr = put_BaseClockLocation(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPointPtr _IAgCrdnEventArraySignaled::GetTargetClockLocation ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = get_TargetClockLocation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

void _IAgCrdnEventArraySignaled::PutTargetClockLocation ( struct IAgCrdnPoint * ppRetVal ) {
    HRESULT _hr = put_TargetClockLocation(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSignalDelayPtr _IAgCrdnEventArraySignaled::GetSignalDelay ( ) {
    struct IAgCrdnSignalDelay * _result = 0;
    HRESULT _hr = get_SignalDelay(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSignalDelayPtr(_result, false);
}

void _IAgCrdnEventArraySignaled::PutSignalDelay ( struct IAgCrdnSignalDelay * ppRetVal ) {
    HRESULT _hr = put_SignalDelay(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnEventArraySignaled::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventArraySignaled::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnEventArraySignaled::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnEventArraySignaled::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventArraySignaled::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventArraySignaled::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventArraySignaled::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnEventArraySignaled::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnEventArraySignaled::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnEventArraySignaled::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventArraySignaled::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventArraySignaled::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventArraySignaled::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnEventArraySignaled::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnEventArraySignaled::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventArraySignaled::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnEventArraySignaled::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnEventArraySignaled::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventArraySignaled::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnEventArrayStartStopTimes wrapper method implementations
//

enum AgECrdnEventArrayType _IAgCrdnEventArrayStartStopTimes::GetType ( ) {
    enum AgECrdnEventArrayType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnFindTimesResultPtr _IAgCrdnEventArrayStartStopTimes::FindTimes ( ) {
    struct IAgCrdnFindTimesResult * _result = 0;
    HRESULT _hr = raw_FindTimes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnFindTimesResultPtr(_result, false);
}

enum AgECrdnStartStopOption _IAgCrdnEventArrayStartStopTimes::GetStartStopOption ( ) {
    enum AgECrdnStartStopOption _result;
    HRESULT _hr = get_StartStopOption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventArrayStartStopTimes::PutStartStopOption ( enum AgECrdnStartStopOption pRetVal ) {
    HRESULT _hr = put_StartStopOption(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnEventIntervalListPtr _IAgCrdnEventArrayStartStopTimes::GetReferenceIntervals ( ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = get_ReferenceIntervals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

void _IAgCrdnEventArrayStartStopTimes::PutReferenceIntervals ( struct IAgCrdnEventIntervalList * ppRetVal ) {
    HRESULT _hr = put_ReferenceIntervals(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnEventArrayStartStopTimes::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventArrayStartStopTimes::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnEventArrayStartStopTimes::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnEventArrayStartStopTimes::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventArrayStartStopTimes::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventArrayStartStopTimes::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventArrayStartStopTimes::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnEventArrayStartStopTimes::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnEventArrayStartStopTimes::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnEventArrayStartStopTimes::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventArrayStartStopTimes::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventArrayStartStopTimes::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventArrayStartStopTimes::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnEventArrayStartStopTimes::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnEventArrayStartStopTimes::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventArrayStartStopTimes::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnEventArrayStartStopTimes::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnEventArrayStartStopTimes::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventArrayStartStopTimes::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnEventEpoch wrapper method implementations
//

enum AgECrdnEventType _IAgCrdnEventEpoch::GetType ( ) {
    enum AgECrdnEventType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEventPtr _IAgCrdnEventEpoch::GetToday ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_Today(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventPtr _IAgCrdnEventEpoch::GetTomorrow ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_Tomorrow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventPtr _IAgCrdnEventEpoch::GetNoonToday ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_NoonToday(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventPtr _IAgCrdnEventEpoch::GetNoonTomorrow ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_NoonTomorrow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventFindOccurrenceResultPtr _IAgCrdnEventEpoch::FindOccurrence ( ) {
    struct IAgCrdnEventFindOccurrenceResult * _result = 0;
    HRESULT _hr = raw_FindOccurrence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventFindOccurrenceResultPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventEpoch::OccursBefore ( const _variant_t & Epoch ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_OccursBefore(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_variant_t _IAgCrdnEventEpoch::GetEpoch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Epoch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgCrdnEventEpoch::PutEpoch ( const _variant_t & pRetVal ) {
    HRESULT _hr = put_Epoch(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnEventEpoch::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventEpoch::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnEventEpoch::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnEventEpoch::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventEpoch::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventEpoch::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventEpoch::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnEventEpoch::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnEventEpoch::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnEventEpoch::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventEpoch::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventEpoch::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventEpoch::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnEventEpoch::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnEventEpoch::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventEpoch::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnEventEpoch::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnEventEpoch::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventEpoch::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnEventExtremum wrapper method implementations
//

enum AgECrdnEventType _IAgCrdnEventExtremum::GetType ( ) {
    enum AgECrdnEventType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEventPtr _IAgCrdnEventExtremum::GetToday ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_Today(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventPtr _IAgCrdnEventExtremum::GetTomorrow ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_Tomorrow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventPtr _IAgCrdnEventExtremum::GetNoonToday ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_NoonToday(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventPtr _IAgCrdnEventExtremum::GetNoonTomorrow ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_NoonTomorrow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventFindOccurrenceResultPtr _IAgCrdnEventExtremum::FindOccurrence ( ) {
    struct IAgCrdnEventFindOccurrenceResult * _result = 0;
    HRESULT _hr = raw_FindOccurrence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventFindOccurrenceResultPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventExtremum::OccursBefore ( const _variant_t & Epoch ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_OccursBefore(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

enum AgECrdnExtremumConstants _IAgCrdnEventExtremum::GetExtremumType ( ) {
    enum AgECrdnExtremumConstants _result;
    HRESULT _hr = get_ExtremumType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventExtremum::PutExtremumType ( enum AgECrdnExtremumConstants pRetVal ) {
    HRESULT _hr = put_ExtremumType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnCalcScalarPtr _IAgCrdnEventExtremum::GetCalculation ( ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = get_Calculation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

void _IAgCrdnEventExtremum::PutCalculation ( struct IAgCrdnCalcScalar * ppRetVal ) {
    HRESULT _hr = put_Calculation(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnEventIntervalListPtr _IAgCrdnEventExtremum::GetCustomTimeLimits ( ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = get_CustomTimeLimits(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

void _IAgCrdnEventExtremum::PutCustomTimeLimits ( struct IAgCrdnEventIntervalList * ppRetVal ) {
    HRESULT _hr = put_CustomTimeLimits(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnEventExtremum::GetUseCustomTimeLimits ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseCustomTimeLimits(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventExtremum::PutUseCustomTimeLimits ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseCustomTimeLimits(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSaveDataOption _IAgCrdnEventExtremum::GetSaveDataOption ( ) {
    enum AgECrdnSaveDataOption _result;
    HRESULT _hr = get_SaveDataOption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventExtremum::PutSaveDataOption ( enum AgECrdnSaveDataOption pRetVal ) {
    HRESULT _hr = put_SaveDataOption(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSamplingPtr _IAgCrdnEventExtremum::GetSampling ( ) {
    struct IAgCrdnSampling * _result = 0;
    HRESULT _hr = get_Sampling(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSamplingPtr(_result, false);
}

void _IAgCrdnEventExtremum::PutSampling ( struct IAgCrdnSampling * ppRetVal ) {
    HRESULT _hr = put_Sampling(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnConvergePtr _IAgCrdnEventExtremum::GetConvergence ( ) {
    struct IAgCrdnConverge * _result = 0;
    HRESULT _hr = get_Convergence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConvergePtr(_result, false);
}

void _IAgCrdnEventExtremum::PutConvergence ( struct IAgCrdnConverge * ppRetVal ) {
    HRESULT _hr = put_Convergence(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnEventExtremum::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventExtremum::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnEventExtremum::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnEventExtremum::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventExtremum::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventExtremum::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventExtremum::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnEventExtremum::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnEventExtremum::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnEventExtremum::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventExtremum::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventExtremum::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventExtremum::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnEventExtremum::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnEventExtremum::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventExtremum::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnEventExtremum::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnEventExtremum::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventExtremum::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnEventInterval wrapper method implementations
//

enum AgECrdnEventIntervalType _IAgCrdnEventInterval::GetType ( ) {
    enum AgECrdnEventIntervalType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventInterval::GetLabelStartDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelStartDescription(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventInterval::GetLabelStopDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelStopDescription(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventInterval::GetLabelStart ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelStart(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventInterval::GetLabelStop ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelStop(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

IAgCrdnEventIntervalResultPtr _IAgCrdnEventInterval::FindInterval ( ) {
    struct IAgCrdnEventIntervalResult * _result = 0;
    HRESULT _hr = raw_FindInterval(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalResultPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventInterval::Occurred ( const _variant_t & Epoch ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Occurred(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

enum AgECrdnKind _IAgCrdnEventInterval::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventInterval::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnEventInterval::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnEventInterval::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventInterval::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventInterval::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventInterval::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnEventInterval::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnEventInterval::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnEventInterval::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventInterval::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventInterval::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventInterval::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnEventInterval::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnEventInterval::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventInterval::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnEventInterval::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnEventInterval::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventInterval::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnEventIntervalBetweenTimeInstants wrapper method implementations
//

enum AgECrdnEventIntervalType _IAgCrdnEventIntervalBetweenTimeInstants::GetType ( ) {
    enum AgECrdnEventIntervalType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventIntervalBetweenTimeInstants::GetLabelStartDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelStartDescription(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalBetweenTimeInstants::GetLabelStopDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelStopDescription(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalBetweenTimeInstants::GetLabelStart ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelStart(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalBetweenTimeInstants::GetLabelStop ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelStop(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

IAgCrdnEventIntervalResultPtr _IAgCrdnEventIntervalBetweenTimeInstants::FindInterval ( ) {
    struct IAgCrdnEventIntervalResult * _result = 0;
    HRESULT _hr = raw_FindInterval(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalResultPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalBetweenTimeInstants::Occurred ( const _variant_t & Epoch ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Occurred(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEventPtr _IAgCrdnEventIntervalBetweenTimeInstants::GetStartTimeInstant ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_StartTimeInstant(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

void _IAgCrdnEventIntervalBetweenTimeInstants::PutStartTimeInstant ( struct IAgCrdnEvent * ppRetVal ) {
    HRESULT _hr = put_StartTimeInstant(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnEventPtr _IAgCrdnEventIntervalBetweenTimeInstants::GetStopTimeInstant ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_StopTimeInstant(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

void _IAgCrdnEventIntervalBetweenTimeInstants::PutStopTimeInstant ( struct IAgCrdnEvent * ppRetVal ) {
    HRESULT _hr = put_StopTimeInstant(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnEventIntervalBetweenTimeInstants::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventIntervalBetweenTimeInstants::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnEventIntervalBetweenTimeInstants::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnEventIntervalBetweenTimeInstants::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalBetweenTimeInstants::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalBetweenTimeInstants::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalBetweenTimeInstants::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnEventIntervalBetweenTimeInstants::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnEventIntervalBetweenTimeInstants::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnEventIntervalBetweenTimeInstants::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalBetweenTimeInstants::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalBetweenTimeInstants::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalBetweenTimeInstants::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnEventIntervalBetweenTimeInstants::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnEventIntervalBetweenTimeInstants::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalBetweenTimeInstants::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnEventIntervalBetweenTimeInstants::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnEventIntervalBetweenTimeInstants::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventIntervalBetweenTimeInstants::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnEventIntervalCollection wrapper method implementations
//

enum AgECrdnEventIntervalCollectionType _IAgCrdnEventIntervalCollection::GetType ( ) {
    enum AgECrdnEventIntervalCollectionType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnEventIntervalCollection::GetLabels ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalsVectorResultPtr _IAgCrdnEventIntervalCollection::FindIntervalCollection ( ) {
    struct IAgCrdnIntervalsVectorResult * _result = 0;
    HRESULT _hr = raw_FindIntervalCollection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalsVectorResultPtr(_result, false);
}

IAgCrdnEventIntervalCollectionOccurredResultPtr _IAgCrdnEventIntervalCollection::Occurred ( const _variant_t & Epoch ) {
    struct IAgCrdnEventIntervalCollectionOccurredResult * _result = 0;
    HRESULT _hr = raw_Occurred(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalCollectionOccurredResultPtr(_result, false);
}

enum AgECrdnKind _IAgCrdnEventIntervalCollection::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventIntervalCollection::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnEventIntervalCollection::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnEventIntervalCollection::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalCollection::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalCollection::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalCollection::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnEventIntervalCollection::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnEventIntervalCollection::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnEventIntervalCollection::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalCollection::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalCollection::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalCollection::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnEventIntervalCollection::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnEventIntervalCollection::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalCollection::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnEventIntervalCollection::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnEventIntervalCollection::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventIntervalCollection::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnEventIntervalCollectionCondition wrapper method implementations
//

enum AgECrdnEventIntervalCollectionType _IAgCrdnEventIntervalCollectionCondition::GetType ( ) {
    enum AgECrdnEventIntervalCollectionType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnEventIntervalCollectionCondition::GetLabels ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalsVectorResultPtr _IAgCrdnEventIntervalCollectionCondition::FindIntervalCollection ( ) {
    struct IAgCrdnIntervalsVectorResult * _result = 0;
    HRESULT _hr = raw_FindIntervalCollection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalsVectorResultPtr(_result, false);
}

IAgCrdnEventIntervalCollectionOccurredResultPtr _IAgCrdnEventIntervalCollectionCondition::Occurred ( const _variant_t & Epoch ) {
    struct IAgCrdnEventIntervalCollectionOccurredResult * _result = 0;
    HRESULT _hr = raw_Occurred(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalCollectionOccurredResultPtr(_result, false);
}

IAgCrdnConditionSetPtr _IAgCrdnEventIntervalCollectionCondition::GetConditionSet ( ) {
    struct IAgCrdnConditionSet * _result = 0;
    HRESULT _hr = get_ConditionSet(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConditionSetPtr(_result, false);
}

void _IAgCrdnEventIntervalCollectionCondition::PutConditionSet ( struct IAgCrdnConditionSet * ppRetVal ) {
    HRESULT _hr = put_ConditionSet(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnEventIntervalListPtr _IAgCrdnEventIntervalCollectionCondition::GetCustomTimeLimits ( ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = get_CustomTimeLimits(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

void _IAgCrdnEventIntervalCollectionCondition::PutCustomTimeLimits ( struct IAgCrdnEventIntervalList * ppRetVal ) {
    HRESULT _hr = put_CustomTimeLimits(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnEventIntervalCollectionCondition::GetUseCustomTimeLimits ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseCustomTimeLimits(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventIntervalCollectionCondition::PutUseCustomTimeLimits ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseCustomTimeLimits(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSaveDataOption _IAgCrdnEventIntervalCollectionCondition::GetSaveDataOption ( ) {
    enum AgECrdnSaveDataOption _result;
    HRESULT _hr = get_SaveDataOption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventIntervalCollectionCondition::PutSaveDataOption ( enum AgECrdnSaveDataOption pRetVal ) {
    HRESULT _hr = put_SaveDataOption(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSamplingPtr _IAgCrdnEventIntervalCollectionCondition::GetSampling ( ) {
    struct IAgCrdnSampling * _result = 0;
    HRESULT _hr = get_Sampling(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSamplingPtr(_result, false);
}

void _IAgCrdnEventIntervalCollectionCondition::PutSampling ( struct IAgCrdnSampling * ppRetVal ) {
    HRESULT _hr = put_Sampling(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnConvergePtr _IAgCrdnEventIntervalCollectionCondition::GetConvergence ( ) {
    struct IAgCrdnConverge * _result = 0;
    HRESULT _hr = get_Convergence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConvergePtr(_result, false);
}

void _IAgCrdnEventIntervalCollectionCondition::PutConvergence ( struct IAgCrdnConverge * ppRetVal ) {
    HRESULT _hr = put_Convergence(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnEventIntervalCollectionCondition::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventIntervalCollectionCondition::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnEventIntervalCollectionCondition::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnEventIntervalCollectionCondition::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalCollectionCondition::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalCollectionCondition::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalCollectionCondition::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnEventIntervalCollectionCondition::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnEventIntervalCollectionCondition::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnEventIntervalCollectionCondition::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalCollectionCondition::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalCollectionCondition::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalCollectionCondition::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnEventIntervalCollectionCondition::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnEventIntervalCollectionCondition::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalCollectionCondition::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnEventIntervalCollectionCondition::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnEventIntervalCollectionCondition::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventIntervalCollectionCondition::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnEventIntervalCollectionLighting wrapper method implementations
//

enum AgECrdnEventIntervalCollectionType _IAgCrdnEventIntervalCollectionLighting::GetType ( ) {
    enum AgECrdnEventIntervalCollectionType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnEventIntervalCollectionLighting::GetLabels ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalsVectorResultPtr _IAgCrdnEventIntervalCollectionLighting::FindIntervalCollection ( ) {
    struct IAgCrdnIntervalsVectorResult * _result = 0;
    HRESULT _hr = raw_FindIntervalCollection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalsVectorResultPtr(_result, false);
}

IAgCrdnEventIntervalCollectionOccurredResultPtr _IAgCrdnEventIntervalCollectionLighting::Occurred ( const _variant_t & Epoch ) {
    struct IAgCrdnEventIntervalCollectionOccurredResult * _result = 0;
    HRESULT _hr = raw_Occurred(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalCollectionOccurredResultPtr(_result, false);
}

IAgCrdnPointPtr _IAgCrdnEventIntervalCollectionLighting::GetLocation ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = get_Location(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

void _IAgCrdnEventIntervalCollectionLighting::PutLocation ( struct IAgCrdnPoint * ppRetVal ) {
    HRESULT _hr = put_Location(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

SAFEARRAY * _IAgCrdnEventIntervalCollectionLighting::GetEclipsingBodies ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_EclipsingBodies(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventIntervalCollectionLighting::PutEclipsingBodies ( SAFEARRAY * ppRetVal ) {
    HRESULT _hr = put_EclipsingBodies(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnEventIntervalCollectionLighting::GetUseObjectEclipsingBodies ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseObjectEclipsingBodies(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventIntervalCollectionLighting::PutUseObjectEclipsingBodies ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseObjectEclipsingBodies(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnEventIntervalCollectionLighting::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventIntervalCollectionLighting::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnEventIntervalCollectionLighting::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnEventIntervalCollectionLighting::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalCollectionLighting::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalCollectionLighting::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalCollectionLighting::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnEventIntervalCollectionLighting::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnEventIntervalCollectionLighting::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnEventIntervalCollectionLighting::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalCollectionLighting::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalCollectionLighting::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalCollectionLighting::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnEventIntervalCollectionLighting::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnEventIntervalCollectionLighting::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalCollectionLighting::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnEventIntervalCollectionLighting::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnEventIntervalCollectionLighting::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventIntervalCollectionLighting::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnEventIntervalCollectionSignaled wrapper method implementations
//

enum AgECrdnEventIntervalCollectionType _IAgCrdnEventIntervalCollectionSignaled::GetType ( ) {
    enum AgECrdnEventIntervalCollectionType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnEventIntervalCollectionSignaled::GetLabels ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalsVectorResultPtr _IAgCrdnEventIntervalCollectionSignaled::FindIntervalCollection ( ) {
    struct IAgCrdnIntervalsVectorResult * _result = 0;
    HRESULT _hr = raw_FindIntervalCollection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalsVectorResultPtr(_result, false);
}

IAgCrdnEventIntervalCollectionOccurredResultPtr _IAgCrdnEventIntervalCollectionSignaled::Occurred ( const _variant_t & Epoch ) {
    struct IAgCrdnEventIntervalCollectionOccurredResult * _result = 0;
    HRESULT _hr = raw_Occurred(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalCollectionOccurredResultPtr(_result, false);
}

IAgCrdnEventIntervalCollectionPtr _IAgCrdnEventIntervalCollectionSignaled::GetOriginalCollection ( ) {
    struct IAgCrdnEventIntervalCollection * _result = 0;
    HRESULT _hr = get_OriginalCollection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalCollectionPtr(_result, false);
}

void _IAgCrdnEventIntervalCollectionSignaled::PutOriginalCollection ( struct IAgCrdnEventIntervalCollection * ppRetVal ) {
    HRESULT _hr = put_OriginalCollection(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSignalSense _IAgCrdnEventIntervalCollectionSignaled::GetSignalSense ( ) {
    enum AgECrdnSignalSense _result;
    HRESULT _hr = get_SignalSense(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventIntervalCollectionSignaled::PutSignalSense ( enum AgECrdnSignalSense pRetVal ) {
    HRESULT _hr = put_SignalSense(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPointPtr _IAgCrdnEventIntervalCollectionSignaled::GetBaseClockLocation ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = get_BaseClockLocation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

void _IAgCrdnEventIntervalCollectionSignaled::PutBaseClockLocation ( struct IAgCrdnPoint * ppRetVal ) {
    HRESULT _hr = put_BaseClockLocation(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPointPtr _IAgCrdnEventIntervalCollectionSignaled::GetTargetClockLocation ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = get_TargetClockLocation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

void _IAgCrdnEventIntervalCollectionSignaled::PutTargetClockLocation ( struct IAgCrdnPoint * ppRetVal ) {
    HRESULT _hr = put_TargetClockLocation(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSignalDelayPtr _IAgCrdnEventIntervalCollectionSignaled::GetSignalDelay ( ) {
    struct IAgCrdnSignalDelay * _result = 0;
    HRESULT _hr = get_SignalDelay(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSignalDelayPtr(_result, false);
}

void _IAgCrdnEventIntervalCollectionSignaled::PutSignalDelay ( struct IAgCrdnSignalDelay * ppRetVal ) {
    HRESULT _hr = put_SignalDelay(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnEventIntervalCollectionSignaled::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventIntervalCollectionSignaled::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnEventIntervalCollectionSignaled::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnEventIntervalCollectionSignaled::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalCollectionSignaled::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalCollectionSignaled::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalCollectionSignaled::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnEventIntervalCollectionSignaled::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnEventIntervalCollectionSignaled::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnEventIntervalCollectionSignaled::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalCollectionSignaled::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalCollectionSignaled::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalCollectionSignaled::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnEventIntervalCollectionSignaled::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnEventIntervalCollectionSignaled::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalCollectionSignaled::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnEventIntervalCollectionSignaled::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnEventIntervalCollectionSignaled::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventIntervalCollectionSignaled::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnEventIntervalFixed wrapper method implementations
//

enum AgECrdnEventIntervalType _IAgCrdnEventIntervalFixed::GetType ( ) {
    enum AgECrdnEventIntervalType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventIntervalFixed::GetLabelStartDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelStartDescription(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalFixed::GetLabelStopDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelStopDescription(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalFixed::GetLabelStart ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelStart(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalFixed::GetLabelStop ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelStop(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

IAgCrdnEventIntervalResultPtr _IAgCrdnEventIntervalFixed::FindInterval ( ) {
    struct IAgCrdnEventIntervalResult * _result = 0;
    HRESULT _hr = raw_FindInterval(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalResultPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalFixed::Occurred ( const _variant_t & Epoch ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Occurred(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_variant_t _IAgCrdnEventIntervalFixed::GetStartTime ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_StartTime(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

_variant_t _IAgCrdnEventIntervalFixed::GetStopTime ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_StopTime(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

HRESULT _IAgCrdnEventIntervalFixed::SetInterval ( const _variant_t & StartEpoch, const _variant_t & StopEpoch ) {
    HRESULT _hr = raw_SetInterval(StartEpoch, StopEpoch);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

enum AgECrdnKind _IAgCrdnEventIntervalFixed::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventIntervalFixed::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnEventIntervalFixed::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnEventIntervalFixed::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalFixed::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalFixed::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalFixed::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnEventIntervalFixed::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnEventIntervalFixed::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnEventIntervalFixed::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalFixed::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalFixed::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalFixed::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnEventIntervalFixed::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnEventIntervalFixed::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalFixed::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnEventIntervalFixed::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnEventIntervalFixed::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventIntervalFixed::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnEventIntervalFixedDuration wrapper method implementations
//

enum AgECrdnEventIntervalType _IAgCrdnEventIntervalFixedDuration::GetType ( ) {
    enum AgECrdnEventIntervalType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventIntervalFixedDuration::GetLabelStartDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelStartDescription(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalFixedDuration::GetLabelStopDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelStopDescription(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalFixedDuration::GetLabelStart ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelStart(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalFixedDuration::GetLabelStop ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelStop(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

IAgCrdnEventIntervalResultPtr _IAgCrdnEventIntervalFixedDuration::FindInterval ( ) {
    struct IAgCrdnEventIntervalResult * _result = 0;
    HRESULT _hr = raw_FindInterval(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalResultPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalFixedDuration::Occurred ( const _variant_t & Epoch ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Occurred(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEventPtr _IAgCrdnEventIntervalFixedDuration::GetReferenceTimeInstant ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_ReferenceTimeInstant(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

void _IAgCrdnEventIntervalFixedDuration::PutReferenceTimeInstant ( struct IAgCrdnEvent * ppRetVal ) {
    HRESULT _hr = put_ReferenceTimeInstant(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnEventIntervalFixedDuration::GetStartOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_StartOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventIntervalFixedDuration::PutStartOffset ( double pRetVal ) {
    HRESULT _hr = put_StartOffset(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnEventIntervalFixedDuration::GetStopOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_StopOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventIntervalFixedDuration::PutStopOffset ( double pRetVal ) {
    HRESULT _hr = put_StopOffset(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnEventIntervalFixedDuration::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventIntervalFixedDuration::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnEventIntervalFixedDuration::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnEventIntervalFixedDuration::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalFixedDuration::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalFixedDuration::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalFixedDuration::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnEventIntervalFixedDuration::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnEventIntervalFixedDuration::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnEventIntervalFixedDuration::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalFixedDuration::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalFixedDuration::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalFixedDuration::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnEventIntervalFixedDuration::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnEventIntervalFixedDuration::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalFixedDuration::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnEventIntervalFixedDuration::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnEventIntervalFixedDuration::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventIntervalFixedDuration::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnEventIntervalFromIntervalList wrapper method implementations
//

enum AgECrdnEventIntervalType _IAgCrdnEventIntervalFromIntervalList::GetType ( ) {
    enum AgECrdnEventIntervalType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventIntervalFromIntervalList::GetLabelStartDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelStartDescription(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalFromIntervalList::GetLabelStopDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelStopDescription(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalFromIntervalList::GetLabelStart ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelStart(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalFromIntervalList::GetLabelStop ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelStop(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

IAgCrdnEventIntervalResultPtr _IAgCrdnEventIntervalFromIntervalList::FindInterval ( ) {
    struct IAgCrdnEventIntervalResult * _result = 0;
    HRESULT _hr = raw_FindInterval(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalResultPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalFromIntervalList::Occurred ( const _variant_t & Epoch ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Occurred(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEventIntervalListPtr _IAgCrdnEventIntervalFromIntervalList::GetReferenceIntervals ( ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = get_ReferenceIntervals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

void _IAgCrdnEventIntervalFromIntervalList::PutReferenceIntervals ( struct IAgCrdnEventIntervalList * ppRetVal ) {
    HRESULT _hr = put_ReferenceIntervals(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnIntervalSelection _IAgCrdnEventIntervalFromIntervalList::GetIntervalSelection ( ) {
    enum AgECrdnIntervalSelection _result;
    HRESULT _hr = get_IntervalSelection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventIntervalFromIntervalList::PutIntervalSelection ( enum AgECrdnIntervalSelection pRetVal ) {
    HRESULT _hr = put_IntervalSelection(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

int _IAgCrdnEventIntervalFromIntervalList::GetIntervalNumber ( ) {
    int _result = 0;
    HRESULT _hr = get_IntervalNumber(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventIntervalFromIntervalList::PutIntervalNumber ( int pRetVal ) {
    HRESULT _hr = put_IntervalNumber(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnEventIntervalFromIntervalList::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventIntervalFromIntervalList::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnEventIntervalFromIntervalList::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnEventIntervalFromIntervalList::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalFromIntervalList::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalFromIntervalList::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalFromIntervalList::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnEventIntervalFromIntervalList::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnEventIntervalFromIntervalList::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnEventIntervalFromIntervalList::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalFromIntervalList::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalFromIntervalList::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalFromIntervalList::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnEventIntervalFromIntervalList::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnEventIntervalFromIntervalList::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalFromIntervalList::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnEventIntervalFromIntervalList::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnEventIntervalFromIntervalList::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventIntervalFromIntervalList::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnEventIntervalList wrapper method implementations
//

enum AgECrdnEventIntervalListType _IAgCrdnEventIntervalList::GetType ( ) {
    enum AgECrdnEventIntervalListType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnEventIntervalList::GetLabels ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnEventIntervalList::GetDescriptions ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Descriptions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalListResultPtr _IAgCrdnEventIntervalList::FindIntervals ( ) {
    struct IAgCrdnIntervalListResult * _result = 0;
    HRESULT _hr = raw_FindIntervals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalListResultPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalList::Occurred ( const _variant_t & Epoch ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Occurred(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

enum AgECrdnKind _IAgCrdnEventIntervalList::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventIntervalList::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnEventIntervalList::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnEventIntervalList::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalList::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalList::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalList::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnEventIntervalList::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnEventIntervalList::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnEventIntervalList::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalList::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalList::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalList::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnEventIntervalList::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnEventIntervalList::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalList::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnEventIntervalList::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnEventIntervalList::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventIntervalList::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnEventIntervalListCondition wrapper method implementations
//

enum AgECrdnEventIntervalListType _IAgCrdnEventIntervalListCondition::GetType ( ) {
    enum AgECrdnEventIntervalListType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnEventIntervalListCondition::GetLabels ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnEventIntervalListCondition::GetDescriptions ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Descriptions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalListResultPtr _IAgCrdnEventIntervalListCondition::FindIntervals ( ) {
    struct IAgCrdnIntervalListResult * _result = 0;
    HRESULT _hr = raw_FindIntervals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalListResultPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalListCondition::Occurred ( const _variant_t & Epoch ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Occurred(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnConditionPtr _IAgCrdnEventIntervalListCondition::GetCondition ( ) {
    struct IAgCrdnCondition * _result = 0;
    HRESULT _hr = get_Condition(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConditionPtr(_result, false);
}

void _IAgCrdnEventIntervalListCondition::PutCondition ( struct IAgCrdnCondition * ppRetVal ) {
    HRESULT _hr = put_Condition(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnEventIntervalListPtr _IAgCrdnEventIntervalListCondition::GetCustomTimeLimits ( ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = get_CustomTimeLimits(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

void _IAgCrdnEventIntervalListCondition::PutCustomTimeLimits ( struct IAgCrdnEventIntervalList * ppRetVal ) {
    HRESULT _hr = put_CustomTimeLimits(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnEventIntervalListCondition::GetUseCustomTimeLimits ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseCustomTimeLimits(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventIntervalListCondition::PutUseCustomTimeLimits ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseCustomTimeLimits(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSaveDataOption _IAgCrdnEventIntervalListCondition::GetSaveDataOption ( ) {
    enum AgECrdnSaveDataOption _result;
    HRESULT _hr = get_SaveDataOption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventIntervalListCondition::PutSaveDataOption ( enum AgECrdnSaveDataOption pRetVal ) {
    HRESULT _hr = put_SaveDataOption(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSamplingPtr _IAgCrdnEventIntervalListCondition::GetSampling ( ) {
    struct IAgCrdnSampling * _result = 0;
    HRESULT _hr = get_Sampling(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSamplingPtr(_result, false);
}

void _IAgCrdnEventIntervalListCondition::PutSampling ( struct IAgCrdnSampling * ppRetVal ) {
    HRESULT _hr = put_Sampling(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnConvergePtr _IAgCrdnEventIntervalListCondition::GetConvergence ( ) {
    struct IAgCrdnConverge * _result = 0;
    HRESULT _hr = get_Convergence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConvergePtr(_result, false);
}

void _IAgCrdnEventIntervalListCondition::PutConvergence ( struct IAgCrdnConverge * ppRetVal ) {
    HRESULT _hr = put_Convergence(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnEventIntervalListCondition::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventIntervalListCondition::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnEventIntervalListCondition::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnEventIntervalListCondition::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalListCondition::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalListCondition::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalListCondition::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnEventIntervalListCondition::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnEventIntervalListCondition::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnEventIntervalListCondition::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalListCondition::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalListCondition::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalListCondition::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnEventIntervalListCondition::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnEventIntervalListCondition::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalListCondition::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnEventIntervalListCondition::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnEventIntervalListCondition::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventIntervalListCondition::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnEventIntervalListFile wrapper method implementations
//

enum AgECrdnEventIntervalListType _IAgCrdnEventIntervalListFile::GetType ( ) {
    enum AgECrdnEventIntervalListType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnEventIntervalListFile::GetLabels ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnEventIntervalListFile::GetDescriptions ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Descriptions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalListResultPtr _IAgCrdnEventIntervalListFile::FindIntervals ( ) {
    struct IAgCrdnIntervalListResult * _result = 0;
    HRESULT _hr = raw_FindIntervals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalListResultPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalListFile::Occurred ( const _variant_t & Epoch ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Occurred(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventIntervalListFile::GetFilename ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Filename(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnEventIntervalListFile::PutFilename ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Filename(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgCrdnEventIntervalListFile::Reload ( ) {
    HRESULT _hr = raw_Reload();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnEventIntervalResultPtr _IAgCrdnEventIntervalListFile::GetFileSpan ( ) {
    struct IAgCrdnEventIntervalResult * _result = 0;
    HRESULT _hr = raw_GetFileSpan(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalResultPtr(_result, false);
}

enum AgECrdnKind _IAgCrdnEventIntervalListFile::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventIntervalListFile::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnEventIntervalListFile::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnEventIntervalListFile::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalListFile::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalListFile::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalListFile::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnEventIntervalListFile::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnEventIntervalListFile::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnEventIntervalListFile::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalListFile::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalListFile::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalListFile::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnEventIntervalListFile::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnEventIntervalListFile::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalListFile::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnEventIntervalListFile::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnEventIntervalListFile::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventIntervalListFile::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnEventIntervalListFiltered wrapper method implementations
//

enum AgECrdnEventIntervalListType _IAgCrdnEventIntervalListFiltered::GetType ( ) {
    enum AgECrdnEventIntervalListType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnEventIntervalListFiltered::GetLabels ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnEventIntervalListFiltered::GetDescriptions ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Descriptions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalListResultPtr _IAgCrdnEventIntervalListFiltered::FindIntervals ( ) {
    struct IAgCrdnIntervalListResult * _result = 0;
    HRESULT _hr = raw_FindIntervals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalListResultPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalListFiltered::Occurred ( const _variant_t & Epoch ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Occurred(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEventIntervalListPtr _IAgCrdnEventIntervalListFiltered::GetOriginalIntervals ( ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = get_OriginalIntervals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

void _IAgCrdnEventIntervalListFiltered::PutOriginalIntervals ( struct IAgCrdnEventIntervalList * ppRetVal ) {
    HRESULT _hr = put_OriginalIntervals(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPruneFilterFactoryPtr _IAgCrdnEventIntervalListFiltered::GetFilterFactory ( ) {
    struct IAgCrdnPruneFilterFactory * _result = 0;
    HRESULT _hr = get_FilterFactory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPruneFilterFactoryPtr(_result, false);
}

IAgCrdnPruneFilterPtr _IAgCrdnEventIntervalListFiltered::GetFilter ( ) {
    struct IAgCrdnPruneFilter * _result = 0;
    HRESULT _hr = get_Filter(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPruneFilterPtr(_result, false);
}

void _IAgCrdnEventIntervalListFiltered::PutFilter ( struct IAgCrdnPruneFilter * ppRetVal ) {
    HRESULT _hr = put_Filter(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnEventIntervalListFiltered::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventIntervalListFiltered::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnEventIntervalListFiltered::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnEventIntervalListFiltered::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalListFiltered::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalListFiltered::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalListFiltered::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnEventIntervalListFiltered::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnEventIntervalListFiltered::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnEventIntervalListFiltered::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalListFiltered::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalListFiltered::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalListFiltered::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnEventIntervalListFiltered::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnEventIntervalListFiltered::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalListFiltered::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnEventIntervalListFiltered::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnEventIntervalListFiltered::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventIntervalListFiltered::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnEventIntervalListFixed wrapper method implementations
//

enum AgECrdnEventIntervalListType _IAgCrdnEventIntervalListFixed::GetType ( ) {
    enum AgECrdnEventIntervalListType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnEventIntervalListFixed::GetLabels ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnEventIntervalListFixed::GetDescriptions ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Descriptions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalListResultPtr _IAgCrdnEventIntervalListFixed::FindIntervals ( ) {
    struct IAgCrdnIntervalListResult * _result = 0;
    HRESULT _hr = raw_FindIntervals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalListResultPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalListFixed::Occurred ( const _variant_t & Epoch ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Occurred(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnEventIntervalListFixed::GetIntervals ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetIntervals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgCrdnEventIntervalListFixed::SetIntervals ( SAFEARRAY * * Intervals ) {
    HRESULT _hr = raw_SetIntervals(Intervals);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

enum AgECrdnKind _IAgCrdnEventIntervalListFixed::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventIntervalListFixed::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnEventIntervalListFixed::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnEventIntervalListFixed::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalListFixed::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalListFixed::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalListFixed::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnEventIntervalListFixed::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnEventIntervalListFixed::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnEventIntervalListFixed::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalListFixed::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalListFixed::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalListFixed::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnEventIntervalListFixed::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnEventIntervalListFixed::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalListFixed::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnEventIntervalListFixed::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnEventIntervalListFixed::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventIntervalListFixed::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnEventIntervalListMerged wrapper method implementations
//

enum AgECrdnEventIntervalListType _IAgCrdnEventIntervalListMerged::GetType ( ) {
    enum AgECrdnEventIntervalListType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnEventIntervalListMerged::GetLabels ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnEventIntervalListMerged::GetDescriptions ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Descriptions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalListResultPtr _IAgCrdnEventIntervalListMerged::FindIntervals ( ) {
    struct IAgCrdnIntervalListResult * _result = 0;
    HRESULT _hr = raw_FindIntervals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalListResultPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalListMerged::Occurred ( const _variant_t & Epoch ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Occurred(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnEventIntervalListMerged::GetIntervalListOrIntervalA ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = get_IntervalListOrIntervalA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnEventIntervalListMerged::GetIntervalListOrIntervalB ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = get_IntervalListOrIntervalB(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

enum AgECrdnEventListMergeOperation _IAgCrdnEventIntervalListMerged::GetMergeOperation ( ) {
    enum AgECrdnEventListMergeOperation _result;
    HRESULT _hr = get_MergeOperation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventIntervalListMerged::PutMergeOperation ( enum AgECrdnEventListMergeOperation pRetVal ) {
    HRESULT _hr = put_MergeOperation(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgCrdnEventIntervalListMerged::SetIntervalListA ( struct IAgCrdnEventIntervalList * RefIntervals ) {
    HRESULT _hr = raw_SetIntervalListA(RefIntervals);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventIntervalListMerged::SetIntervalA ( struct IAgCrdnEventInterval * RefIntervals ) {
    HRESULT _hr = raw_SetIntervalA(RefIntervals);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventIntervalListMerged::SetIntervalListB ( struct IAgCrdnEventIntervalList * RefIntervals ) {
    HRESULT _hr = raw_SetIntervalListB(RefIntervals);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventIntervalListMerged::SetIntervalB ( struct IAgCrdnEventInterval * RefIntervals ) {
    HRESULT _hr = raw_SetIntervalB(RefIntervals);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

enum AgECrdnKind _IAgCrdnEventIntervalListMerged::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventIntervalListMerged::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnEventIntervalListMerged::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnEventIntervalListMerged::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalListMerged::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalListMerged::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalListMerged::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnEventIntervalListMerged::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnEventIntervalListMerged::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnEventIntervalListMerged::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalListMerged::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalListMerged::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalListMerged::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnEventIntervalListMerged::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnEventIntervalListMerged::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalListMerged::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnEventIntervalListMerged::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnEventIntervalListMerged::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventIntervalListMerged::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnEventIntervalListScaled wrapper method implementations
//

enum AgECrdnEventIntervalListType _IAgCrdnEventIntervalListScaled::GetType ( ) {
    enum AgECrdnEventIntervalListType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnEventIntervalListScaled::GetLabels ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnEventIntervalListScaled::GetDescriptions ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Descriptions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalListResultPtr _IAgCrdnEventIntervalListScaled::FindIntervals ( ) {
    struct IAgCrdnIntervalListResult * _result = 0;
    HRESULT _hr = raw_FindIntervals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalListResultPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalListScaled::Occurred ( const _variant_t & Epoch ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Occurred(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEventIntervalListPtr _IAgCrdnEventIntervalListScaled::GetOriginalIntervals ( ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = get_OriginalIntervals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

void _IAgCrdnEventIntervalListScaled::PutOriginalIntervals ( struct IAgCrdnEventIntervalList * ppRetVal ) {
    HRESULT _hr = put_OriginalIntervals(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnEventIntervalListScaled::GetAbsoluteIncrement ( ) {
    double _result = 0;
    HRESULT _hr = get_AbsoluteIncrement(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventIntervalListScaled::PutAbsoluteIncrement ( double pRetVal ) {
    HRESULT _hr = put_AbsoluteIncrement(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnEventIntervalListScaled::GetRelativeIncrement ( ) {
    double _result = 0;
    HRESULT _hr = get_RelativeIncrement(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventIntervalListScaled::PutRelativeIncrement ( double pRetVal ) {
    HRESULT _hr = put_RelativeIncrement(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnEventIntervalListScaled::GetUseAbsoluteIncrement ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseAbsoluteIncrement(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventIntervalListScaled::PutUseAbsoluteIncrement ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseAbsoluteIncrement(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnEventIntervalListScaled::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventIntervalListScaled::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnEventIntervalListScaled::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnEventIntervalListScaled::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalListScaled::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalListScaled::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalListScaled::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnEventIntervalListScaled::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnEventIntervalListScaled::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnEventIntervalListScaled::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalListScaled::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalListScaled::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalListScaled::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnEventIntervalListScaled::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnEventIntervalListScaled::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalListScaled::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnEventIntervalListScaled::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnEventIntervalListScaled::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventIntervalListScaled::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnEventIntervalListSignaled wrapper method implementations
//

enum AgECrdnEventIntervalListType _IAgCrdnEventIntervalListSignaled::GetType ( ) {
    enum AgECrdnEventIntervalListType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnEventIntervalListSignaled::GetLabels ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnEventIntervalListSignaled::GetDescriptions ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Descriptions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalListResultPtr _IAgCrdnEventIntervalListSignaled::FindIntervals ( ) {
    struct IAgCrdnIntervalListResult * _result = 0;
    HRESULT _hr = raw_FindIntervals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalListResultPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalListSignaled::Occurred ( const _variant_t & Epoch ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Occurred(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEventIntervalListPtr _IAgCrdnEventIntervalListSignaled::GetOriginalIntervals ( ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = get_OriginalIntervals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

void _IAgCrdnEventIntervalListSignaled::PutOriginalIntervals ( struct IAgCrdnEventIntervalList * ppRetVal ) {
    HRESULT _hr = put_OriginalIntervals(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSignalSense _IAgCrdnEventIntervalListSignaled::GetSignalSense ( ) {
    enum AgECrdnSignalSense _result;
    HRESULT _hr = get_SignalSense(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventIntervalListSignaled::PutSignalSense ( enum AgECrdnSignalSense pRetVal ) {
    HRESULT _hr = put_SignalSense(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPointPtr _IAgCrdnEventIntervalListSignaled::GetBaseClockLocation ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = get_BaseClockLocation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

void _IAgCrdnEventIntervalListSignaled::PutBaseClockLocation ( struct IAgCrdnPoint * ppRetVal ) {
    HRESULT _hr = put_BaseClockLocation(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPointPtr _IAgCrdnEventIntervalListSignaled::GetTargetClockLocation ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = get_TargetClockLocation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

void _IAgCrdnEventIntervalListSignaled::PutTargetClockLocation ( struct IAgCrdnPoint * ppRetVal ) {
    HRESULT _hr = put_TargetClockLocation(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSignalDelayPtr _IAgCrdnEventIntervalListSignaled::GetSignalDelay ( ) {
    struct IAgCrdnSignalDelay * _result = 0;
    HRESULT _hr = get_SignalDelay(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSignalDelayPtr(_result, false);
}

void _IAgCrdnEventIntervalListSignaled::PutSignalDelay ( struct IAgCrdnSignalDelay * ppRetVal ) {
    HRESULT _hr = put_SignalDelay(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnEventIntervalListSignaled::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventIntervalListSignaled::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnEventIntervalListSignaled::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnEventIntervalListSignaled::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalListSignaled::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalListSignaled::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalListSignaled::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnEventIntervalListSignaled::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnEventIntervalListSignaled::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnEventIntervalListSignaled::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalListSignaled::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalListSignaled::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalListSignaled::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnEventIntervalListSignaled::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnEventIntervalListSignaled::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalListSignaled::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnEventIntervalListSignaled::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnEventIntervalListSignaled::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventIntervalListSignaled::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnEventIntervalListTimeOffset wrapper method implementations
//

enum AgECrdnEventIntervalListType _IAgCrdnEventIntervalListTimeOffset::GetType ( ) {
    enum AgECrdnEventIntervalListType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnEventIntervalListTimeOffset::GetLabels ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnEventIntervalListTimeOffset::GetDescriptions ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Descriptions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalListResultPtr _IAgCrdnEventIntervalListTimeOffset::FindIntervals ( ) {
    struct IAgCrdnIntervalListResult * _result = 0;
    HRESULT _hr = raw_FindIntervals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalListResultPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalListTimeOffset::Occurred ( const _variant_t & Epoch ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Occurred(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEventIntervalListPtr _IAgCrdnEventIntervalListTimeOffset::GetReferenceIntervals ( ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = get_ReferenceIntervals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

void _IAgCrdnEventIntervalListTimeOffset::PutReferenceIntervals ( struct IAgCrdnEventIntervalList * ppRetVal ) {
    HRESULT _hr = put_ReferenceIntervals(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnEventIntervalListTimeOffset::GetTimeOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_TimeOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventIntervalListTimeOffset::PutTimeOffset ( double pRetVal ) {
    HRESULT _hr = put_TimeOffset(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnEventIntervalListTimeOffset::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventIntervalListTimeOffset::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnEventIntervalListTimeOffset::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnEventIntervalListTimeOffset::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalListTimeOffset::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalListTimeOffset::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalListTimeOffset::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnEventIntervalListTimeOffset::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnEventIntervalListTimeOffset::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnEventIntervalListTimeOffset::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalListTimeOffset::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalListTimeOffset::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalListTimeOffset::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnEventIntervalListTimeOffset::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnEventIntervalListTimeOffset::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalListTimeOffset::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnEventIntervalListTimeOffset::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnEventIntervalListTimeOffset::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventIntervalListTimeOffset::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnEventIntervalScaled wrapper method implementations
//

enum AgECrdnEventIntervalType _IAgCrdnEventIntervalScaled::GetType ( ) {
    enum AgECrdnEventIntervalType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventIntervalScaled::GetLabelStartDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelStartDescription(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalScaled::GetLabelStopDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelStopDescription(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalScaled::GetLabelStart ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelStart(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalScaled::GetLabelStop ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelStop(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

IAgCrdnEventIntervalResultPtr _IAgCrdnEventIntervalScaled::FindInterval ( ) {
    struct IAgCrdnEventIntervalResult * _result = 0;
    HRESULT _hr = raw_FindInterval(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalResultPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalScaled::Occurred ( const _variant_t & Epoch ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Occurred(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEventIntervalPtr _IAgCrdnEventIntervalScaled::GetOriginalInterval ( ) {
    struct IAgCrdnEventInterval * _result = 0;
    HRESULT _hr = get_OriginalInterval(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalPtr(_result, false);
}

void _IAgCrdnEventIntervalScaled::PutOriginalInterval ( struct IAgCrdnEventInterval * ppRetVal ) {
    HRESULT _hr = put_OriginalInterval(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnEventIntervalScaled::GetAbsoluteIncrement ( ) {
    double _result = 0;
    HRESULT _hr = get_AbsoluteIncrement(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventIntervalScaled::PutAbsoluteIncrement ( double pRetVal ) {
    HRESULT _hr = put_AbsoluteIncrement(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnEventIntervalScaled::GetRelativeIncrement ( ) {
    double _result = 0;
    HRESULT _hr = get_RelativeIncrement(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventIntervalScaled::PutRelativeIncrement ( double pRetVal ) {
    HRESULT _hr = put_RelativeIncrement(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnEventIntervalScaled::GetUseAbsoluteIncrement ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseAbsoluteIncrement(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventIntervalScaled::PutUseAbsoluteIncrement ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseAbsoluteIncrement(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnEventIntervalScaled::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventIntervalScaled::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnEventIntervalScaled::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnEventIntervalScaled::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalScaled::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalScaled::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalScaled::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnEventIntervalScaled::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnEventIntervalScaled::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnEventIntervalScaled::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalScaled::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalScaled::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalScaled::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnEventIntervalScaled::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnEventIntervalScaled::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalScaled::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnEventIntervalScaled::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnEventIntervalScaled::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventIntervalScaled::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnEventIntervalSignaled wrapper method implementations
//

enum AgECrdnEventIntervalType _IAgCrdnEventIntervalSignaled::GetType ( ) {
    enum AgECrdnEventIntervalType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventIntervalSignaled::GetLabelStartDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelStartDescription(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalSignaled::GetLabelStopDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelStopDescription(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalSignaled::GetLabelStart ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelStart(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalSignaled::GetLabelStop ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelStop(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

IAgCrdnEventIntervalResultPtr _IAgCrdnEventIntervalSignaled::FindInterval ( ) {
    struct IAgCrdnEventIntervalResult * _result = 0;
    HRESULT _hr = raw_FindInterval(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalResultPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalSignaled::Occurred ( const _variant_t & Epoch ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Occurred(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEventIntervalPtr _IAgCrdnEventIntervalSignaled::GetOriginalInterval ( ) {
    struct IAgCrdnEventInterval * _result = 0;
    HRESULT _hr = get_OriginalInterval(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalPtr(_result, false);
}

void _IAgCrdnEventIntervalSignaled::PutOriginalInterval ( struct IAgCrdnEventInterval * ppRetVal ) {
    HRESULT _hr = put_OriginalInterval(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSignalSense _IAgCrdnEventIntervalSignaled::GetSignalSense ( ) {
    enum AgECrdnSignalSense _result;
    HRESULT _hr = get_SignalSense(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventIntervalSignaled::PutSignalSense ( enum AgECrdnSignalSense pRetVal ) {
    HRESULT _hr = put_SignalSense(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPointPtr _IAgCrdnEventIntervalSignaled::GetBaseClockLocation ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = get_BaseClockLocation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

void _IAgCrdnEventIntervalSignaled::PutBaseClockLocation ( struct IAgCrdnPoint * ppRetVal ) {
    HRESULT _hr = put_BaseClockLocation(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPointPtr _IAgCrdnEventIntervalSignaled::GetTargetClockLocation ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = get_TargetClockLocation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

void _IAgCrdnEventIntervalSignaled::PutTargetClockLocation ( struct IAgCrdnPoint * ppRetVal ) {
    HRESULT _hr = put_TargetClockLocation(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSignalDelayPtr _IAgCrdnEventIntervalSignaled::GetSignalDelay ( ) {
    struct IAgCrdnSignalDelay * _result = 0;
    HRESULT _hr = get_SignalDelay(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSignalDelayPtr(_result, false);
}

void _IAgCrdnEventIntervalSignaled::PutSignalDelay ( struct IAgCrdnSignalDelay * ppRetVal ) {
    HRESULT _hr = put_SignalDelay(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnEventIntervalSignaled::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventIntervalSignaled::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnEventIntervalSignaled::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnEventIntervalSignaled::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalSignaled::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalSignaled::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalSignaled::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnEventIntervalSignaled::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnEventIntervalSignaled::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnEventIntervalSignaled::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalSignaled::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalSignaled::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalSignaled::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnEventIntervalSignaled::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnEventIntervalSignaled::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalSignaled::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnEventIntervalSignaled::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnEventIntervalSignaled::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventIntervalSignaled::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnEventIntervalSmartInterval wrapper method implementations
//

enum AgECrdnEventIntervalType _IAgCrdnEventIntervalSmartInterval::GetType ( ) {
    enum AgECrdnEventIntervalType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventIntervalSmartInterval::GetLabelStartDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelStartDescription(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalSmartInterval::GetLabelStopDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelStopDescription(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalSmartInterval::GetLabelStart ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelStart(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalSmartInterval::GetLabelStop ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelStop(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

IAgCrdnEventIntervalResultPtr _IAgCrdnEventIntervalSmartInterval::FindInterval ( ) {
    struct IAgCrdnEventIntervalResult * _result = 0;
    HRESULT _hr = raw_FindInterval(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalResultPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalSmartInterval::Occurred ( const _variant_t & Epoch ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Occurred(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEventIntervalPtr _IAgCrdnEventIntervalSmartInterval::GetReferenceInterval ( ) {
    struct IAgCrdnEventInterval * _result = 0;
    HRESULT _hr = get_ReferenceInterval(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalPtr(_result, false);
}

_bstr_t _IAgCrdnEventIntervalSmartInterval::GetDurationAsString ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DurationAsString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnEventIntervalSmartInterval::PutDurationAsString ( _bstr_t pRetVal ) {
    HRESULT _hr = put_DurationAsString(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSmartIntervalState _IAgCrdnEventIntervalSmartInterval::GetState ( ) {
    enum AgECrdnSmartIntervalState _result;
    HRESULT _hr = get_State(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventIntervalSmartInterval::PutState ( enum AgECrdnSmartIntervalState pRetVal ) {
    HRESULT _hr = put_State(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgCrdnEventIntervalSmartInterval::SetImplicitInterval ( struct IAgCrdnEventInterval * EventInterval ) {
    HRESULT _hr = raw_SetImplicitInterval(EventInterval);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_variant_t _IAgCrdnEventIntervalSmartInterval::FindStartTime ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_FindStartTime(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

_variant_t _IAgCrdnEventIntervalSmartInterval::FindStopTime ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_FindStopTime(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

IAgCrdnEventSmartEpochPtr _IAgCrdnEventIntervalSmartInterval::GetStartEpoch ( ) {
    struct IAgCrdnEventSmartEpoch * _result = 0;
    HRESULT _hr = raw_GetStartEpoch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventSmartEpochPtr(_result, false);
}

HRESULT _IAgCrdnEventIntervalSmartInterval::SetStartEpoch ( struct IAgCrdnEventSmartEpoch * StartEpoch ) {
    HRESULT _hr = raw_SetStartEpoch(StartEpoch);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnEventSmartEpochPtr _IAgCrdnEventIntervalSmartInterval::GetStopEpoch ( ) {
    struct IAgCrdnEventSmartEpoch * _result = 0;
    HRESULT _hr = raw_GetStopEpoch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventSmartEpochPtr(_result, false);
}

HRESULT _IAgCrdnEventIntervalSmartInterval::SetStopEpoch ( struct IAgCrdnEventSmartEpoch * StopEpoch ) {
    HRESULT _hr = raw_SetStopEpoch(StopEpoch);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventIntervalSmartInterval::SetExplicitInterval ( const _variant_t & Start, const _variant_t & Stop ) {
    HRESULT _hr = raw_SetExplicitInterval(Start, Stop);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventIntervalSmartInterval::SetStartAndStopEpochs ( struct IAgCrdnEventSmartEpoch * RefStartEpoch, struct IAgCrdnEventSmartEpoch * RefStopEpoch ) {
    HRESULT _hr = raw_SetStartAndStopEpochs(RefStartEpoch, RefStopEpoch);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventIntervalSmartInterval::SetStartAndStopTimes ( const _variant_t & StartTime, const _variant_t & StopTime ) {
    HRESULT _hr = raw_SetStartAndStopTimes(StartTime, StopTime);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventIntervalSmartInterval::SetStartEpochAndDuration ( struct IAgCrdnEventSmartEpoch * RefStartEpoch, _bstr_t DurationStr ) {
    HRESULT _hr = raw_SetStartEpochAndDuration(RefStartEpoch, DurationStr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventIntervalSmartInterval::SetStartTimeAndDuration ( const _variant_t & Epoch, _bstr_t DurationStr ) {
    HRESULT _hr = raw_SetStartTimeAndDuration(Epoch, DurationStr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

enum AgECrdnKind _IAgCrdnEventIntervalSmartInterval::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventIntervalSmartInterval::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnEventIntervalSmartInterval::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnEventIntervalSmartInterval::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalSmartInterval::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalSmartInterval::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalSmartInterval::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnEventIntervalSmartInterval::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnEventIntervalSmartInterval::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnEventIntervalSmartInterval::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalSmartInterval::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalSmartInterval::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalSmartInterval::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnEventIntervalSmartInterval::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnEventIntervalSmartInterval::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalSmartInterval::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnEventIntervalSmartInterval::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnEventIntervalSmartInterval::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventIntervalSmartInterval::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnEventIntervalTimeOffset wrapper method implementations
//

enum AgECrdnEventIntervalType _IAgCrdnEventIntervalTimeOffset::GetType ( ) {
    enum AgECrdnEventIntervalType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventIntervalTimeOffset::GetLabelStartDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelStartDescription(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalTimeOffset::GetLabelStopDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelStopDescription(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalTimeOffset::GetLabelStart ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelStart(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalTimeOffset::GetLabelStop ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LabelStop(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

IAgCrdnEventIntervalResultPtr _IAgCrdnEventIntervalTimeOffset::FindInterval ( ) {
    struct IAgCrdnEventIntervalResult * _result = 0;
    HRESULT _hr = raw_FindInterval(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalResultPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalTimeOffset::Occurred ( const _variant_t & Epoch ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Occurred(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEventIntervalPtr _IAgCrdnEventIntervalTimeOffset::GetReferenceInterval ( ) {
    struct IAgCrdnEventInterval * _result = 0;
    HRESULT _hr = get_ReferenceInterval(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalPtr(_result, false);
}

void _IAgCrdnEventIntervalTimeOffset::PutReferenceInterval ( struct IAgCrdnEventInterval * ppRetVal ) {
    HRESULT _hr = put_ReferenceInterval(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnEventIntervalTimeOffset::GetTimeOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_TimeOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventIntervalTimeOffset::PutTimeOffset ( double pRetVal ) {
    HRESULT _hr = put_TimeOffset(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnEventIntervalTimeOffset::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventIntervalTimeOffset::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnEventIntervalTimeOffset::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnEventIntervalTimeOffset::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalTimeOffset::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventIntervalTimeOffset::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalTimeOffset::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnEventIntervalTimeOffset::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnEventIntervalTimeOffset::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnEventIntervalTimeOffset::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalTimeOffset::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalTimeOffset::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventIntervalTimeOffset::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnEventIntervalTimeOffset::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnEventIntervalTimeOffset::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventIntervalTimeOffset::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnEventIntervalTimeOffset::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnEventIntervalTimeOffset::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventIntervalTimeOffset::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnEventSignaled wrapper method implementations
//

enum AgECrdnEventType _IAgCrdnEventSignaled::GetType ( ) {
    enum AgECrdnEventType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEventPtr _IAgCrdnEventSignaled::GetToday ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_Today(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventPtr _IAgCrdnEventSignaled::GetTomorrow ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_Tomorrow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventPtr _IAgCrdnEventSignaled::GetNoonToday ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_NoonToday(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventPtr _IAgCrdnEventSignaled::GetNoonTomorrow ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_NoonTomorrow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventFindOccurrenceResultPtr _IAgCrdnEventSignaled::FindOccurrence ( ) {
    struct IAgCrdnEventFindOccurrenceResult * _result = 0;
    HRESULT _hr = raw_FindOccurrence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventFindOccurrenceResultPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventSignaled::OccursBefore ( const _variant_t & Epoch ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_OccursBefore(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEventPtr _IAgCrdnEventSignaled::GetOriginalTimeInstant ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_OriginalTimeInstant(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

void _IAgCrdnEventSignaled::PutOriginalTimeInstant ( struct IAgCrdnEvent * ppRetVal ) {
    HRESULT _hr = put_OriginalTimeInstant(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSignalSense _IAgCrdnEventSignaled::GetSignalSense ( ) {
    enum AgECrdnSignalSense _result;
    HRESULT _hr = get_SignalSense(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventSignaled::PutSignalSense ( enum AgECrdnSignalSense pRetVal ) {
    HRESULT _hr = put_SignalSense(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPointPtr _IAgCrdnEventSignaled::GetBaseClockLocation ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = get_BaseClockLocation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

void _IAgCrdnEventSignaled::PutBaseClockLocation ( struct IAgCrdnPoint * ppRetVal ) {
    HRESULT _hr = put_BaseClockLocation(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPointPtr _IAgCrdnEventSignaled::GetTargetClockLocation ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = get_TargetClockLocation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

void _IAgCrdnEventSignaled::PutTargetClockLocation ( struct IAgCrdnPoint * ppRetVal ) {
    HRESULT _hr = put_TargetClockLocation(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSignalDelayPtr _IAgCrdnEventSignaled::GetSignalDelay ( ) {
    struct IAgCrdnSignalDelay * _result = 0;
    HRESULT _hr = get_SignalDelay(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSignalDelayPtr(_result, false);
}

void _IAgCrdnEventSignaled::PutSignalDelay ( struct IAgCrdnSignalDelay * ppRetVal ) {
    HRESULT _hr = put_SignalDelay(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnEventSignaled::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventSignaled::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnEventSignaled::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnEventSignaled::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventSignaled::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventSignaled::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventSignaled::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnEventSignaled::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnEventSignaled::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnEventSignaled::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventSignaled::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventSignaled::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventSignaled::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnEventSignaled::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnEventSignaled::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventSignaled::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnEventSignaled::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnEventSignaled::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventSignaled::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnEventSmartEpoch wrapper method implementations
//

enum AgECrdnEventType _IAgCrdnEventSmartEpoch::GetType ( ) {
    enum AgECrdnEventType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEventPtr _IAgCrdnEventSmartEpoch::GetToday ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_Today(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventPtr _IAgCrdnEventSmartEpoch::GetTomorrow ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_Tomorrow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventPtr _IAgCrdnEventSmartEpoch::GetNoonToday ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_NoonToday(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventPtr _IAgCrdnEventSmartEpoch::GetNoonTomorrow ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_NoonTomorrow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventFindOccurrenceResultPtr _IAgCrdnEventSmartEpoch::FindOccurrence ( ) {
    struct IAgCrdnEventFindOccurrenceResult * _result = 0;
    HRESULT _hr = raw_FindOccurrence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventFindOccurrenceResultPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventSmartEpoch::OccursBefore ( const _variant_t & Epoch ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_OccursBefore(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_variant_t _IAgCrdnEventSmartEpoch::GetTimeInstant ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_TimeInstant(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

IAgCrdnEventPtr _IAgCrdnEventSmartEpoch::GetReferenceEvent ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_ReferenceEvent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

enum AgECrdnSmartEpochState _IAgCrdnEventSmartEpoch::GetState ( ) {
    enum AgECrdnSmartEpochState _result;
    HRESULT _hr = get_State(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventSmartEpoch::PutState ( enum AgECrdnSmartEpochState pRetVal ) {
    HRESULT _hr = put_State(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgCrdnEventSmartEpoch::SetExplicitTime ( const _variant_t & Epoch ) {
    HRESULT _hr = raw_SetExplicitTime(Epoch);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventSmartEpoch::SetImplicitTime ( struct IAgCrdnEvent * EventEpoch ) {
    HRESULT _hr = raw_SetImplicitTime(EventEpoch);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

enum AgECrdnKind _IAgCrdnEventSmartEpoch::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventSmartEpoch::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnEventSmartEpoch::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnEventSmartEpoch::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventSmartEpoch::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventSmartEpoch::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventSmartEpoch::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnEventSmartEpoch::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnEventSmartEpoch::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnEventSmartEpoch::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventSmartEpoch::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventSmartEpoch::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventSmartEpoch::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnEventSmartEpoch::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnEventSmartEpoch::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventSmartEpoch::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnEventSmartEpoch::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnEventSmartEpoch::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventSmartEpoch::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnEventStartStopTime wrapper method implementations
//

enum AgECrdnEventType _IAgCrdnEventStartStopTime::GetType ( ) {
    enum AgECrdnEventType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEventPtr _IAgCrdnEventStartStopTime::GetToday ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_Today(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventPtr _IAgCrdnEventStartStopTime::GetTomorrow ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_Tomorrow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventPtr _IAgCrdnEventStartStopTime::GetNoonToday ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_NoonToday(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventPtr _IAgCrdnEventStartStopTime::GetNoonTomorrow ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_NoonTomorrow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventFindOccurrenceResultPtr _IAgCrdnEventStartStopTime::FindOccurrence ( ) {
    struct IAgCrdnEventFindOccurrenceResult * _result = 0;
    HRESULT _hr = raw_FindOccurrence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventFindOccurrenceResultPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventStartStopTime::OccursBefore ( const _variant_t & Epoch ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_OccursBefore(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventStartStopTime::GetUseStart ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseStart(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventStartStopTime::PutUseStart ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseStart(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnEventIntervalPtr _IAgCrdnEventStartStopTime::GetReferenceEventInterval ( ) {
    struct IAgCrdnEventInterval * _result = 0;
    HRESULT _hr = get_ReferenceEventInterval(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalPtr(_result, false);
}

void _IAgCrdnEventStartStopTime::PutReferenceEventInterval ( struct IAgCrdnEventInterval * ppRetVal ) {
    HRESULT _hr = put_ReferenceEventInterval(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnEventStartStopTime::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventStartStopTime::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnEventStartStopTime::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnEventStartStopTime::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventStartStopTime::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventStartStopTime::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventStartStopTime::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnEventStartStopTime::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnEventStartStopTime::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnEventStartStopTime::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventStartStopTime::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventStartStopTime::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventStartStopTime::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnEventStartStopTime::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnEventStartStopTime::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventStartStopTime::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnEventStartStopTime::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnEventStartStopTime::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventStartStopTime::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnEventTimeOffset wrapper method implementations
//

enum AgECrdnEventType _IAgCrdnEventTimeOffset::GetType ( ) {
    enum AgECrdnEventType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnEventPtr _IAgCrdnEventTimeOffset::GetToday ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_Today(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventPtr _IAgCrdnEventTimeOffset::GetTomorrow ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_Tomorrow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventPtr _IAgCrdnEventTimeOffset::GetNoonToday ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_NoonToday(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventPtr _IAgCrdnEventTimeOffset::GetNoonTomorrow ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_NoonTomorrow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

IAgCrdnEventFindOccurrenceResultPtr _IAgCrdnEventTimeOffset::FindOccurrence ( ) {
    struct IAgCrdnEventFindOccurrenceResult * _result = 0;
    HRESULT _hr = raw_FindOccurrence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventFindOccurrenceResultPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventTimeOffset::OccursBefore ( const _variant_t & Epoch ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_OccursBefore(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

double _IAgCrdnEventTimeOffset::GetTimeOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_TimeOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventTimeOffset::PutTimeOffset ( double pRetVal ) {
    HRESULT _hr = put_TimeOffset(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnEventPtr _IAgCrdnEventTimeOffset::GetReferenceTimeInstant ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_ReferenceTimeInstant(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

void _IAgCrdnEventTimeOffset::PutReferenceTimeInstant ( struct IAgCrdnEvent * ppRetVal ) {
    HRESULT _hr = put_ReferenceTimeInstant(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnEventTimeOffset::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnEventTimeOffset::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnEventTimeOffset::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnEventTimeOffset::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventTimeOffset::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnEventTimeOffset::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventTimeOffset::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnEventTimeOffset::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnEventTimeOffset::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnEventTimeOffset::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnEventTimeOffset::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventTimeOffset::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnEventTimeOffset::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnEventTimeOffset::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnEventTimeOffset::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnEventTimeOffset::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnEventTimeOffset::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnEventTimeOffset::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnEventTimeOffset::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

double _IAgCrdnEventTimeOffset::GetTimeOffset2 ( ) {
    double _result = 0;
    HRESULT _hr = get_TimeOffset2(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnEventTimeOffset::PutTimeOffset2 ( double pRetVal ) {
    HRESULT _hr = put_TimeOffset2(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnIntegral wrapper method implementations
//

enum AgECrdnKind _IAgCrdnIntegral::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnIntegral::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnIntegral::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnIntegral::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnIntegral::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnIntegral::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnIntegral::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnIntegral::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnIntegral::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnIntegral::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnIntegral::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnIntegral::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnIntegral::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnIntegral::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnIntegral::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnIntegral::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnIntegral::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnIntegral::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnIntegral::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnIntegralBasic wrapper method implementations
//

enum AgECrdnIntegralType _IAgCrdnIntegralBasic::GetType ( ) {
    enum AgECrdnIntegralType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnIntegralBasic::PutType ( enum AgECrdnIntegralType pRetVal ) {
    HRESULT _hr = put_Type(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnIntegralBasic::GetTolerance ( ) {
    double _result = 0;
    HRESULT _hr = get_Tolerance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnIntegralBasic::PutTolerance ( double pRetVal ) {
    HRESULT _hr = put_Tolerance(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

int _IAgCrdnIntegralBasic::GetMaximumIterations ( ) {
    int _result = 0;
    HRESULT _hr = get_MaximumIterations(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnIntegralBasic::PutMaximumIterations ( int pRetVal ) {
    HRESULT _hr = put_MaximumIterations(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnIntegralBasic::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnIntegralBasic::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnIntegralBasic::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnIntegralBasic::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnIntegralBasic::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnIntegralBasic::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnIntegralBasic::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnIntegralBasic::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnIntegralBasic::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnIntegralBasic::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnIntegralBasic::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnIntegralBasic::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnIntegralBasic::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnIntegralBasic::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnIntegralBasic::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnIntegralBasic::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnIntegralBasic::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnIntegralBasic::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnIntegralBasic::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnInterp wrapper method implementations
//

enum AgECrdnKind _IAgCrdnInterp::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnInterp::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnInterp::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnInterp::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnInterp::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnInterp::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnInterp::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnInterp::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnInterp::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnInterp::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnInterp::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnInterp::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnInterp::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnInterp::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnInterp::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnInterp::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnInterp::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnInterp::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnInterp::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnInterpBasic wrapper method implementations
//

enum AgECrdnInterpolatorType _IAgCrdnInterpBasic::GetType ( ) {
    enum AgECrdnInterpolatorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnInterpBasic::PutType ( enum AgECrdnInterpolatorType pRetVal ) {
    HRESULT _hr = put_Type(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

int _IAgCrdnInterpBasic::GetOrder ( ) {
    int _result = 0;
    HRESULT _hr = get_Order(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnInterpBasic::PutOrder ( int pRetVal ) {
    HRESULT _hr = put_Order(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnInterpBasic::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnInterpBasic::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnInterpBasic::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnInterpBasic::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnInterpBasic::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnInterpBasic::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnInterpBasic::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnInterpBasic::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnInterpBasic::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnInterpBasic::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnInterpBasic::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnInterpBasic::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnInterpBasic::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnInterpBasic::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnInterpBasic::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnInterpBasic::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnInterpBasic::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnInterpBasic::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnInterpBasic::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnParameterSet wrapper method implementations
//

enum AgECrdnParameterSetType _IAgCrdnParameterSet::GetType ( ) {
    enum AgECrdnParameterSetType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnParameterSet::GetLabels ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnParameterSet::GetDimensions ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Dimensions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnParameterSet::GetScalarNames ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_ScalarNames(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnParameterSet::Calculate ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_Calculate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnParameterSet::CalculateWithDerivative ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_CalculateWithDerivative(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

enum AgECrdnKind _IAgCrdnParameterSet::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnParameterSet::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnParameterSet::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnParameterSet::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnParameterSet::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnParameterSet::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnParameterSet::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnParameterSet::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnParameterSet::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnParameterSet::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnParameterSet::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnParameterSet::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnParameterSet::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnParameterSet::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnParameterSet::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnParameterSet::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnParameterSet::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnParameterSet::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnParameterSet::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnParameterSetAttitude wrapper method implementations
//

enum AgECrdnParameterSetType _IAgCrdnParameterSetAttitude::GetType ( ) {
    enum AgECrdnParameterSetType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnParameterSetAttitude::GetLabels ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnParameterSetAttitude::GetDimensions ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Dimensions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnParameterSetAttitude::GetScalarNames ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_ScalarNames(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnParameterSetAttitude::Calculate ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_Calculate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnParameterSetAttitude::CalculateWithDerivative ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_CalculateWithDerivative(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAxesPtr _IAgCrdnParameterSetAttitude::GetAxes ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_Axes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

void _IAgCrdnParameterSetAttitude::PutAxes ( struct IAgCrdnAxes * ppRetVal ) {
    HRESULT _hr = put_Axes(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnAxesPtr _IAgCrdnParameterSetAttitude::GetReferenceAxes ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

void _IAgCrdnParameterSetAttitude::PutReferenceAxes ( struct IAgCrdnAxes * ppRetVal ) {
    HRESULT _hr = put_ReferenceAxes(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnParameterSetAttitude::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnParameterSetAttitude::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnParameterSetAttitude::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnParameterSetAttitude::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnParameterSetAttitude::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnParameterSetAttitude::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnParameterSetAttitude::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnParameterSetAttitude::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnParameterSetAttitude::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnParameterSetAttitude::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnParameterSetAttitude::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnParameterSetAttitude::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnParameterSetAttitude::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnParameterSetAttitude::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnParameterSetAttitude::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnParameterSetAttitude::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnParameterSetAttitude::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnParameterSetAttitude::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnParameterSetAttitude::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnParameterSetGroundTrajectory wrapper method implementations
//

enum AgECrdnParameterSetType _IAgCrdnParameterSetGroundTrajectory::GetType ( ) {
    enum AgECrdnParameterSetType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnParameterSetGroundTrajectory::GetLabels ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnParameterSetGroundTrajectory::GetDimensions ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Dimensions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnParameterSetGroundTrajectory::GetScalarNames ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_ScalarNames(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnParameterSetGroundTrajectory::Calculate ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_Calculate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnParameterSetGroundTrajectory::CalculateWithDerivative ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_CalculateWithDerivative(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointPtr _IAgCrdnParameterSetGroundTrajectory::GetLocation ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = get_Location(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

void _IAgCrdnParameterSetGroundTrajectory::PutLocation ( struct IAgCrdnPoint * ppRetVal ) {
    HRESULT _hr = put_Location(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnParameterSetGroundTrajectory::GetCentralBody ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnParameterSetGroundTrajectory::PutCentralBody ( _bstr_t pRetVal ) {
    HRESULT _hr = put_CentralBody(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnParameterSetGroundTrajectory::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnParameterSetGroundTrajectory::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnParameterSetGroundTrajectory::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnParameterSetGroundTrajectory::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnParameterSetGroundTrajectory::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnParameterSetGroundTrajectory::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnParameterSetGroundTrajectory::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnParameterSetGroundTrajectory::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnParameterSetGroundTrajectory::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnParameterSetGroundTrajectory::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnParameterSetGroundTrajectory::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnParameterSetGroundTrajectory::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnParameterSetGroundTrajectory::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnParameterSetGroundTrajectory::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnParameterSetGroundTrajectory::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnParameterSetGroundTrajectory::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnParameterSetGroundTrajectory::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnParameterSetGroundTrajectory::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnParameterSetGroundTrajectory::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnParameterSetOrbit wrapper method implementations
//

enum AgECrdnParameterSetType _IAgCrdnParameterSetOrbit::GetType ( ) {
    enum AgECrdnParameterSetType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnParameterSetOrbit::GetLabels ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnParameterSetOrbit::GetDimensions ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Dimensions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnParameterSetOrbit::GetScalarNames ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_ScalarNames(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnParameterSetOrbit::Calculate ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_Calculate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnParameterSetOrbit::CalculateWithDerivative ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_CalculateWithDerivative(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointPtr _IAgCrdnParameterSetOrbit::GetOrbitingPoint ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = get_OrbitingPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

void _IAgCrdnParameterSetOrbit::PutOrbitingPoint ( struct IAgCrdnPoint * ppRetVal ) {
    HRESULT _hr = put_OrbitingPoint(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSystemPtr _IAgCrdnParameterSetOrbit::GetReferenceSystem ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_ReferenceSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

void _IAgCrdnParameterSetOrbit::PutReferenceSystem ( struct IAgCrdnSystem * ppRetVal ) {
    HRESULT _hr = put_ReferenceSystem(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnParameterSetOrbit::GetGravitationalParameter ( ) {
    double _result = 0;
    HRESULT _hr = get_GravitationalParameter(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnParameterSetOrbit::PutGravitationalParameter ( double pRetVal ) {
    HRESULT _hr = put_GravitationalParameter(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnParameterSetOrbit::GetCentralBody ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnParameterSetOrbit::PutCentralBody ( _bstr_t pRetVal ) {
    HRESULT _hr = put_CentralBody(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnParameterSetOrbit::GetUseCentralBodyGravitationalParameter ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseCentralBodyGravitationalParameter(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnParameterSetOrbit::PutUseCentralBodyGravitationalParameter ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseCentralBodyGravitationalParameter(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnParameterSetOrbit::GetUseCentralBodyInertial ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseCentralBodyInertial(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnParameterSetOrbit::PutUseCentralBodyInertial ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseCentralBodyInertial(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnParameterSetOrbit::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnParameterSetOrbit::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnParameterSetOrbit::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnParameterSetOrbit::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnParameterSetOrbit::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnParameterSetOrbit::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnParameterSetOrbit::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnParameterSetOrbit::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnParameterSetOrbit::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnParameterSetOrbit::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnParameterSetOrbit::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnParameterSetOrbit::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnParameterSetOrbit::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnParameterSetOrbit::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnParameterSetOrbit::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnParameterSetOrbit::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnParameterSetOrbit::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnParameterSetOrbit::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnParameterSetOrbit::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnParameterSetTrajectory wrapper method implementations
//

enum AgECrdnParameterSetType _IAgCrdnParameterSetTrajectory::GetType ( ) {
    enum AgECrdnParameterSetType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnParameterSetTrajectory::GetLabels ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnParameterSetTrajectory::GetDimensions ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Dimensions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnParameterSetTrajectory::GetScalarNames ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_ScalarNames(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnParameterSetTrajectory::Calculate ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_Calculate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnParameterSetTrajectory::CalculateWithDerivative ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_CalculateWithDerivative(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointPtr _IAgCrdnParameterSetTrajectory::GetPoint ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = get_Point(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

void _IAgCrdnParameterSetTrajectory::PutPoint ( struct IAgCrdnPoint * ppRetVal ) {
    HRESULT _hr = put_Point(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSystemPtr _IAgCrdnParameterSetTrajectory::GetReferenceSystem ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_ReferenceSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

void _IAgCrdnParameterSetTrajectory::PutReferenceSystem ( struct IAgCrdnSystem * ppRetVal ) {
    HRESULT _hr = put_ReferenceSystem(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnParameterSetTrajectory::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnParameterSetTrajectory::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnParameterSetTrajectory::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnParameterSetTrajectory::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnParameterSetTrajectory::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnParameterSetTrajectory::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnParameterSetTrajectory::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnParameterSetTrajectory::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnParameterSetTrajectory::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnParameterSetTrajectory::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnParameterSetTrajectory::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnParameterSetTrajectory::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnParameterSetTrajectory::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnParameterSetTrajectory::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnParameterSetTrajectory::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnParameterSetTrajectory::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnParameterSetTrajectory::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnParameterSetTrajectory::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnParameterSetTrajectory::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnParameterSetVector wrapper method implementations
//

enum AgECrdnParameterSetType _IAgCrdnParameterSetVector::GetType ( ) {
    enum AgECrdnParameterSetType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnParameterSetVector::GetLabels ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnParameterSetVector::GetDimensions ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Dimensions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnParameterSetVector::GetScalarNames ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_ScalarNames(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnParameterSetVector::Calculate ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_Calculate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnParameterSetVector::CalculateWithDerivative ( const _variant_t & Epoch ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_CalculateWithDerivative(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorPtr _IAgCrdnParameterSetVector::GetVector ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_Vector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

void _IAgCrdnParameterSetVector::PutVector ( struct IAgCrdnVector * ppRetVal ) {
    HRESULT _hr = put_Vector(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnAxesPtr _IAgCrdnParameterSetVector::GetReferenceAxes ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

void _IAgCrdnParameterSetVector::PutReferenceAxes ( struct IAgCrdnAxes * ppRetVal ) {
    HRESULT _hr = put_ReferenceAxes(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnParameterSetVector::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnParameterSetVector::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnParameterSetVector::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnParameterSetVector::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnParameterSetVector::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnParameterSetVector::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnParameterSetVector::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnParameterSetVector::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnParameterSetVector::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnParameterSetVector::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnParameterSetVector::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnParameterSetVector::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnParameterSetVector::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnParameterSetVector::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnParameterSetVector::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnParameterSetVector::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnParameterSetVector::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnParameterSetVector::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnParameterSetVector::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnSampling wrapper method implementations
//

enum AgECrdnKind _IAgCrdnSampling::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnSampling::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnSampling::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnSampling::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnSampling::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnSampling::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnSampling::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnSampling::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnSampling::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnSampling::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnSampling::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnSampling::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnSampling::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnSampling::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnSampling::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnSampling::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnSampling::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnSampling::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnSampling::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnSamplingBasic wrapper method implementations
//

IAgCrdnSamplingMethodPtr _IAgCrdnSamplingBasic::GetSamplingMethod ( ) {
    struct IAgCrdnSamplingMethod * _result = 0;
    HRESULT _hr = get_SamplingMethod(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSamplingMethodPtr(_result, false);
}

void _IAgCrdnSamplingBasic::PutSamplingMethod ( struct IAgCrdnSamplingMethod * ppRetVal ) {
    HRESULT _hr = put_SamplingMethod(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSamplingMethodFactoryPtr _IAgCrdnSamplingBasic::GetMethodFactory ( ) {
    struct IAgCrdnSamplingMethodFactory * _result = 0;
    HRESULT _hr = get_MethodFactory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSamplingMethodFactoryPtr(_result, false);
}

enum AgECrdnKind _IAgCrdnSamplingBasic::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnSamplingBasic::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnSamplingBasic::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnSamplingBasic::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnSamplingBasic::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnSamplingBasic::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnSamplingBasic::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnSamplingBasic::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnSamplingBasic::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnSamplingBasic::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnSamplingBasic::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnSamplingBasic::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnSamplingBasic::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnSamplingBasic::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnSamplingBasic::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnSamplingBasic::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnSamplingBasic::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnSamplingBasic::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnSamplingBasic::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnSignalDelay wrapper method implementations
//

enum AgECrdnKind _IAgCrdnSignalDelay::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnSignalDelay::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnSignalDelay::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnSignalDelay::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnSignalDelay::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnSignalDelay::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnSignalDelay::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnSignalDelay::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnSignalDelay::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnSignalDelay::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnSignalDelay::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnSignalDelay::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnSignalDelay::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnSignalDelay::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnSignalDelay::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnSignalDelay::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnSignalDelay::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnSignalDelay::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnSignalDelay::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnSignalDelayBasic wrapper method implementations
//

enum AgECrdnSignalPathReferenceSystem _IAgCrdnSignalDelayBasic::GetSignalPathReferenceSystem ( ) {
    enum AgECrdnSignalPathReferenceSystem _result;
    HRESULT _hr = get_SignalPathReferenceSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnSignalDelayBasic::PutSignalPathReferenceSystem ( enum AgECrdnSignalPathReferenceSystem pRetVal ) {
    HRESULT _hr = put_SignalPathReferenceSystem(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSystemPtr _IAgCrdnSignalDelayBasic::GetReferenceSystem ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_ReferenceSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

void _IAgCrdnSignalDelayBasic::PutReferenceSystem ( struct IAgCrdnSystem * ppRetVal ) {
    HRESULT _hr = put_ReferenceSystem(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSpeedOptions _IAgCrdnSignalDelayBasic::GetSpeedOption ( ) {
    enum AgECrdnSpeedOptions _result;
    HRESULT _hr = get_SpeedOption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnSignalDelayBasic::PutSpeedOption ( enum AgECrdnSpeedOptions pRetVal ) {
    HRESULT _hr = put_SpeedOption(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnSignalDelayBasic::GetTransferSpeed ( ) {
    double _result = 0;
    HRESULT _hr = get_TransferSpeed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnSignalDelayBasic::PutTransferSpeed ( double pRetVal ) {
    HRESULT _hr = put_TransferSpeed(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnSignalDelayBasic::GetTimeDelayConvergence ( ) {
    double _result = 0;
    HRESULT _hr = get_TimeDelayConvergence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnSignalDelayBasic::PutTimeDelayConvergence ( double pRetVal ) {
    HRESULT _hr = put_TimeDelayConvergence(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnSignalDelayBasic::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnSignalDelayBasic::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnSignalDelayBasic::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnSignalDelayBasic::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnSignalDelayBasic::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnSignalDelayBasic::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnSignalDelayBasic::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnSignalDelayBasic::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnSignalDelayBasic::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnSignalDelayBasic::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnSignalDelayBasic::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnSignalDelayBasic::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnSignalDelayBasic::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnSignalDelayBasic::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnSignalDelayBasic::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnSignalDelayBasic::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnSignalDelayBasic::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnSignalDelayBasic::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnSignalDelayBasic::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVolume wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVolume::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVolume::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVolume::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVolume::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVolume::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVolume::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVolume::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVolume::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVolume::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVolume::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVolume::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVolume::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVolume::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnVolume::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVolume::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVolume::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVolume::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVolume::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVolume::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVolumeCombined wrapper method implementations
//

enum AgECrdnVolumeCombinedOperationType _IAgCrdnVolumeCombined::GetCombineOperation ( ) {
    enum AgECrdnVolumeCombinedOperationType _result;
    HRESULT _hr = get_CombineOperation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVolumeCombined::PutCombineOperation ( enum AgECrdnVolumeCombinedOperationType pRetVal ) {
    HRESULT _hr = put_CombineOperation(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

int _IAgCrdnVolumeCombined::GetConditionCount ( ) {
    int _result = 0;
    HRESULT _hr = get_ConditionCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

SAFEARRAY * _IAgCrdnVolumeCombined::GetAllConditions ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetAllConditions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgCrdnVolumeCombined::SetAllConditions ( SAFEARRAY * * Conditions ) {
    HRESULT _hr = raw_SetAllConditions(Conditions);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVolumeCombined::SetCondition ( struct IAgCrdnVolume * Ref, int Pos ) {
    HRESULT _hr = raw_SetCondition(Ref, Pos);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnVolumePtr _IAgCrdnVolumeCombined::GetCondition ( int Pos ) {
    struct IAgCrdnVolume * _result = 0;
    HRESULT _hr = raw_GetCondition(Pos, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumePtr(_result, false);
}

HRESULT _IAgCrdnVolumeCombined::RemoveCondition ( int Pos ) {
    HRESULT _hr = raw_RemoveCondition(Pos);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

enum AgECrdnKind _IAgCrdnVolumeCombined::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVolumeCombined::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVolumeCombined::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVolumeCombined::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVolumeCombined::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVolumeCombined::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeCombined::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVolumeCombined::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVolumeCombined::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVolumeCombined::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeCombined::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVolumeCombined::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVolumeCombined::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnVolumeCombined::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVolumeCombined::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeCombined::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVolumeCombined::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVolumeCombined::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVolumeCombined::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVolumeFromCalc wrapper method implementations
//

enum AgECrdnConditionThresholdOption _IAgCrdnVolumeFromCalc::GetOperation ( ) {
    enum AgECrdnConditionThresholdOption _result;
    HRESULT _hr = get_Operation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVolumeFromCalc::PutOperation ( enum AgECrdnConditionThresholdOption pRetVal ) {
    HRESULT _hr = put_Operation(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

STKUtil::IAgQuantityPtr _IAgCrdnVolumeFromCalc::GetMinimum ( ) {
    struct STKUtil::IAgQuantity * _result = 0;
    HRESULT _hr = raw_GetMinimum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgQuantityPtr(_result, false);
}

HRESULT _IAgCrdnVolumeFromCalc::SetMinimum ( struct STKUtil::IAgQuantity * Value ) {
    HRESULT _hr = raw_SetMinimum(Value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

STKUtil::IAgQuantityPtr _IAgCrdnVolumeFromCalc::GetMaximum ( ) {
    struct STKUtil::IAgQuantity * _result = 0;
    HRESULT _hr = raw_GetMaximum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgQuantityPtr(_result, false);
}

HRESULT _IAgCrdnVolumeFromCalc::SetMaximum ( struct STKUtil::IAgQuantity * Value ) {
    HRESULT _hr = raw_SetMaximum(Value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVolumeFromCalc::Set ( struct STKUtil::IAgQuantity * Min, struct STKUtil::IAgQuantity * Max ) {
    HRESULT _hr = raw_Set(Min, Max);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

enum AgECrdnKind _IAgCrdnVolumeFromCalc::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVolumeFromCalc::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVolumeFromCalc::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVolumeFromCalc::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVolumeFromCalc::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVolumeFromCalc::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeFromCalc::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVolumeFromCalc::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVolumeFromCalc::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVolumeFromCalc::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeFromCalc::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVolumeFromCalc::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVolumeFromCalc::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnVolumeFromCalc::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVolumeFromCalc::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeFromCalc::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVolumeFromCalc::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVolumeFromCalc::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVolumeFromCalc::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVolumeFromCondition wrapper method implementations
//

IAgCrdnConditionPtr _IAgCrdnVolumeFromCondition::GetCondition ( ) {
    struct IAgCrdnCondition * _result = 0;
    HRESULT _hr = get_Condition(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConditionPtr(_result, false);
}

void _IAgCrdnVolumeFromCondition::PutCondition ( struct IAgCrdnCondition * ppRetVal ) {
    HRESULT _hr = put_Condition(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnVolumeFromCondition::GetUseCustomTimeLimits ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseCustomTimeLimits(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVolumeFromCondition::PutUseCustomTimeLimits ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseCustomTimeLimits(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnEventIntervalListPtr _IAgCrdnVolumeFromCondition::GetCustomTimeLimits ( ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = get_CustomTimeLimits(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

void _IAgCrdnVolumeFromCondition::PutCustomTimeLimits ( struct IAgCrdnEventIntervalList * ppRetVal ) {
    HRESULT _hr = put_CustomTimeLimits(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSamplingPtr _IAgCrdnVolumeFromCondition::GetSampling ( ) {
    struct IAgCrdnSampling * _result = 0;
    HRESULT _hr = get_Sampling(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSamplingPtr(_result, false);
}

void _IAgCrdnVolumeFromCondition::PutSampling ( struct IAgCrdnSampling * ppRetVal ) {
    HRESULT _hr = put_Sampling(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnConvergePtr _IAgCrdnVolumeFromCondition::GetConvergence ( ) {
    struct IAgCrdnConverge * _result = 0;
    HRESULT _hr = get_Convergence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConvergePtr(_result, false);
}

void _IAgCrdnVolumeFromCondition::PutConvergence ( struct IAgCrdnConverge * ppRetVal ) {
    HRESULT _hr = put_Convergence(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnVolumeFromCondition::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVolumeFromCondition::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVolumeFromCondition::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVolumeFromCondition::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVolumeFromCondition::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVolumeFromCondition::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeFromCondition::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVolumeFromCondition::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVolumeFromCondition::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVolumeFromCondition::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeFromCondition::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVolumeFromCondition::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVolumeFromCondition::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnVolumeFromCondition::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVolumeFromCondition::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeFromCondition::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVolumeFromCondition::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVolumeFromCondition::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVolumeFromCondition::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVolumeFromGrid wrapper method implementations
//

enum AgECrdnVolumeFromGridEdgeType _IAgCrdnVolumeFromGrid::GetEdgeType ( ) {
    enum AgECrdnVolumeFromGridEdgeType _result;
    HRESULT _hr = get_EdgeType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVolumeFromGrid::PutEdgeType ( enum AgECrdnVolumeFromGridEdgeType pRetVal ) {
    HRESULT _hr = put_EdgeType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnVolumeGridPtr _IAgCrdnVolumeFromGrid::GetVolumeGrid ( ) {
    struct IAgCrdnVolumeGrid * _result = 0;
    HRESULT _hr = get_VolumeGrid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumeGridPtr(_result, false);
}

void _IAgCrdnVolumeFromGrid::PutVolumeGrid ( struct IAgCrdnVolumeGrid * ppRetVal ) {
    HRESULT _hr = put_VolumeGrid(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnVolumeFromGrid::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVolumeFromGrid::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVolumeFromGrid::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVolumeFromGrid::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVolumeFromGrid::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVolumeFromGrid::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeFromGrid::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVolumeFromGrid::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVolumeFromGrid::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVolumeFromGrid::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeFromGrid::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVolumeFromGrid::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVolumeFromGrid::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnVolumeFromGrid::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVolumeFromGrid::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeFromGrid::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVolumeFromGrid::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVolumeFromGrid::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVolumeFromGrid::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVolumeFromTimeSatisfaction wrapper method implementations
//

IAgCrdnEventIntervalListPtr _IAgCrdnVolumeFromTimeSatisfaction::GetTimeSatisfaction ( ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = get_TimeSatisfaction(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

void _IAgCrdnVolumeFromTimeSatisfaction::PutTimeSatisfaction ( struct IAgCrdnEventIntervalList * ppRetVal ) {
    HRESULT _hr = put_TimeSatisfaction(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnVolumeFromTimeSatisfaction::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVolumeFromTimeSatisfaction::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVolumeFromTimeSatisfaction::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVolumeFromTimeSatisfaction::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVolumeFromTimeSatisfaction::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVolumeFromTimeSatisfaction::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeFromTimeSatisfaction::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVolumeFromTimeSatisfaction::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVolumeFromTimeSatisfaction::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVolumeFromTimeSatisfaction::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeFromTimeSatisfaction::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVolumeFromTimeSatisfaction::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVolumeFromTimeSatisfaction::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnVolumeFromTimeSatisfaction::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVolumeFromTimeSatisfaction::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeFromTimeSatisfaction::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVolumeFromTimeSatisfaction::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVolumeFromTimeSatisfaction::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVolumeFromTimeSatisfaction::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVolumeGrid wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVolumeGrid::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVolumeGrid::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVolumeGrid::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVolumeGrid::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVolumeGrid::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVolumeGrid::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeGrid::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVolumeGrid::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVolumeGrid::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVolumeGrid::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeGrid::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVolumeGrid::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVolumeGrid::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnVolumeGrid::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVolumeGrid::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeGrid::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVolumeGrid::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVolumeGrid::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVolumeGrid::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVolumeGridBearingAlt wrapper method implementations
//

_bstr_t _IAgCrdnVolumeGridBearingAlt::GetReferenceCentralBody ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ReferenceCentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVolumeGridBearingAlt::PutReferenceCentralBody ( _bstr_t pRetVal ) {
    HRESULT _hr = put_ReferenceCentralBody(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnGridCoordinateDefinitionPtr _IAgCrdnVolumeGridBearingAlt::GetAlongBearingCoordinates ( ) {
    struct IAgCrdnGridCoordinateDefinition * _result = 0;
    HRESULT _hr = get_AlongBearingCoordinates(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnGridCoordinateDefinitionPtr(_result, false);
}

IAgCrdnGridCoordinateDefinitionPtr _IAgCrdnVolumeGridBearingAlt::GetCrossBearingCoordinates ( ) {
    struct IAgCrdnGridCoordinateDefinition * _result = 0;
    HRESULT _hr = get_CrossBearingCoordinates(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnGridCoordinateDefinitionPtr(_result, false);
}

IAgCrdnGridCoordinateDefinitionPtr _IAgCrdnVolumeGridBearingAlt::GetAltitudeCoordinates ( ) {
    struct IAgCrdnGridCoordinateDefinition * _result = 0;
    HRESULT _hr = get_AltitudeCoordinates(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnGridCoordinateDefinitionPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeGridBearingAlt::GetAutoFitBounds ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AutoFitBounds(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVolumeGridBearingAlt::PutAutoFitBounds ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_AutoFitBounds(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnVolumeGridBearingAlt::GetBearingAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_BearingAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVolumeGridBearingAlt::PutBearingAngle ( double pRetVal ) {
    HRESULT _hr = put_BearingAngle(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

SAFEARRAY * _IAgCrdnVolumeGridBearingAlt::GetReferenceLocation ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_ReferenceLocation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVolumeGridBearingAlt::PutReferenceLocation ( SAFEARRAY * ppRetVal ) {
    HRESULT _hr = put_ReferenceLocation(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnVolumeGridBearingAlt::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVolumeGridBearingAlt::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVolumeGridBearingAlt::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVolumeGridBearingAlt::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVolumeGridBearingAlt::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVolumeGridBearingAlt::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeGridBearingAlt::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVolumeGridBearingAlt::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVolumeGridBearingAlt::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVolumeGridBearingAlt::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeGridBearingAlt::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVolumeGridBearingAlt::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVolumeGridBearingAlt::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnVolumeGridBearingAlt::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVolumeGridBearingAlt::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeGridBearingAlt::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVolumeGridBearingAlt::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVolumeGridBearingAlt::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVolumeGridBearingAlt::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVolumeGridCartesian wrapper method implementations
//

IAgCrdnSystemPtr _IAgCrdnVolumeGridCartesian::GetReferenceSystem ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_ReferenceSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

void _IAgCrdnVolumeGridCartesian::PutReferenceSystem ( struct IAgCrdnSystem * ppRetVal ) {
    HRESULT _hr = put_ReferenceSystem(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnGridCoordinateDefinitionPtr _IAgCrdnVolumeGridCartesian::GetXCoordinates ( ) {
    struct IAgCrdnGridCoordinateDefinition * _result = 0;
    HRESULT _hr = get_XCoordinates(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnGridCoordinateDefinitionPtr(_result, false);
}

IAgCrdnGridCoordinateDefinitionPtr _IAgCrdnVolumeGridCartesian::GetYCoordinates ( ) {
    struct IAgCrdnGridCoordinateDefinition * _result = 0;
    HRESULT _hr = get_YCoordinates(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnGridCoordinateDefinitionPtr(_result, false);
}

IAgCrdnGridCoordinateDefinitionPtr _IAgCrdnVolumeGridCartesian::GetZCoordinates ( ) {
    struct IAgCrdnGridCoordinateDefinition * _result = 0;
    HRESULT _hr = get_ZCoordinates(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnGridCoordinateDefinitionPtr(_result, false);
}

enum AgECrdnKind _IAgCrdnVolumeGridCartesian::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVolumeGridCartesian::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVolumeGridCartesian::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVolumeGridCartesian::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVolumeGridCartesian::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVolumeGridCartesian::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeGridCartesian::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVolumeGridCartesian::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVolumeGridCartesian::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVolumeGridCartesian::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeGridCartesian::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVolumeGridCartesian::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVolumeGridCartesian::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnVolumeGridCartesian::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVolumeGridCartesian::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeGridCartesian::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVolumeGridCartesian::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVolumeGridCartesian::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVolumeGridCartesian::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVolumeGridConstrained wrapper method implementations
//

IAgCrdnVolumeGridPtr _IAgCrdnVolumeGridConstrained::GetReferenceGrid ( ) {
    struct IAgCrdnVolumeGrid * _result = 0;
    HRESULT _hr = get_ReferenceGrid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumeGridPtr(_result, false);
}

void _IAgCrdnVolumeGridConstrained::PutReferenceGrid ( struct IAgCrdnVolumeGrid * ppRetVal ) {
    HRESULT _hr = put_ReferenceGrid(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnVolumePtr _IAgCrdnVolumeGridConstrained::GetConstraint ( ) {
    struct IAgCrdnVolume * _result = 0;
    HRESULT _hr = get_Constraint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumePtr(_result, false);
}

void _IAgCrdnVolumeGridConstrained::PutConstraint ( struct IAgCrdnVolume * ppRetVal ) {
    HRESULT _hr = put_Constraint(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnVolumeGridConstrained::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVolumeGridConstrained::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVolumeGridConstrained::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVolumeGridConstrained::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVolumeGridConstrained::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVolumeGridConstrained::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeGridConstrained::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVolumeGridConstrained::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVolumeGridConstrained::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVolumeGridConstrained::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeGridConstrained::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVolumeGridConstrained::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVolumeGridConstrained::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnVolumeGridConstrained::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVolumeGridConstrained::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeGridConstrained::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVolumeGridConstrained::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVolumeGridConstrained::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVolumeGridConstrained::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVolumeGridCylindrical wrapper method implementations
//

IAgCrdnSystemPtr _IAgCrdnVolumeGridCylindrical::GetReferenceSystem ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_ReferenceSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

void _IAgCrdnVolumeGridCylindrical::PutReferenceSystem ( struct IAgCrdnSystem * ppRetVal ) {
    HRESULT _hr = put_ReferenceSystem(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnGridCoordinateDefinitionPtr _IAgCrdnVolumeGridCylindrical::GetThetaCoordinates ( ) {
    struct IAgCrdnGridCoordinateDefinition * _result = 0;
    HRESULT _hr = get_ThetaCoordinates(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnGridCoordinateDefinitionPtr(_result, false);
}

IAgCrdnGridCoordinateDefinitionPtr _IAgCrdnVolumeGridCylindrical::GetRadiusCoordinates ( ) {
    struct IAgCrdnGridCoordinateDefinition * _result = 0;
    HRESULT _hr = get_RadiusCoordinates(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnGridCoordinateDefinitionPtr(_result, false);
}

IAgCrdnGridCoordinateDefinitionPtr _IAgCrdnVolumeGridCylindrical::GetHeightCoordinates ( ) {
    struct IAgCrdnGridCoordinateDefinition * _result = 0;
    HRESULT _hr = get_HeightCoordinates(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnGridCoordinateDefinitionPtr(_result, false);
}

enum AgECrdnKind _IAgCrdnVolumeGridCylindrical::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVolumeGridCylindrical::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVolumeGridCylindrical::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVolumeGridCylindrical::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVolumeGridCylindrical::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVolumeGridCylindrical::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeGridCylindrical::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVolumeGridCylindrical::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVolumeGridCylindrical::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVolumeGridCylindrical::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeGridCylindrical::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVolumeGridCylindrical::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVolumeGridCylindrical::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnVolumeGridCylindrical::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVolumeGridCylindrical::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeGridCylindrical::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVolumeGridCylindrical::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVolumeGridCylindrical::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVolumeGridCylindrical::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVolumeGridLatLonAlt wrapper method implementations
//

_bstr_t _IAgCrdnVolumeGridLatLonAlt::GetReferenceCentralBody ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ReferenceCentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVolumeGridLatLonAlt::PutReferenceCentralBody ( _bstr_t pRetVal ) {
    HRESULT _hr = put_ReferenceCentralBody(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnGridCoordinateDefinitionPtr _IAgCrdnVolumeGridLatLonAlt::GetLatitudeCoordinates ( ) {
    struct IAgCrdnGridCoordinateDefinition * _result = 0;
    HRESULT _hr = get_LatitudeCoordinates(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnGridCoordinateDefinitionPtr(_result, false);
}

IAgCrdnGridCoordinateDefinitionPtr _IAgCrdnVolumeGridLatLonAlt::GetLongitudeCoordinates ( ) {
    struct IAgCrdnGridCoordinateDefinition * _result = 0;
    HRESULT _hr = get_LongitudeCoordinates(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnGridCoordinateDefinitionPtr(_result, false);
}

IAgCrdnGridCoordinateDefinitionPtr _IAgCrdnVolumeGridLatLonAlt::GetAltitudeCoordinates ( ) {
    struct IAgCrdnGridCoordinateDefinition * _result = 0;
    HRESULT _hr = get_AltitudeCoordinates(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnGridCoordinateDefinitionPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeGridLatLonAlt::GetAutoFitBounds ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AutoFitBounds(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVolumeGridLatLonAlt::PutAutoFitBounds ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_AutoFitBounds(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnVolumeGridLatLonAlt::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVolumeGridLatLonAlt::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVolumeGridLatLonAlt::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVolumeGridLatLonAlt::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVolumeGridLatLonAlt::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVolumeGridLatLonAlt::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeGridLatLonAlt::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVolumeGridLatLonAlt::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVolumeGridLatLonAlt::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVolumeGridLatLonAlt::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeGridLatLonAlt::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVolumeGridLatLonAlt::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVolumeGridLatLonAlt::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnVolumeGridLatLonAlt::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVolumeGridLatLonAlt::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeGridLatLonAlt::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVolumeGridLatLonAlt::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVolumeGridLatLonAlt::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVolumeGridLatLonAlt::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVolumeGridSpherical wrapper method implementations
//

IAgCrdnSystemPtr _IAgCrdnVolumeGridSpherical::GetReferenceSystem ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_ReferenceSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

void _IAgCrdnVolumeGridSpherical::PutReferenceSystem ( struct IAgCrdnSystem * ppRetVal ) {
    HRESULT _hr = put_ReferenceSystem(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnGridCoordinateDefinitionPtr _IAgCrdnVolumeGridSpherical::GetAzimuthCoordinates ( ) {
    struct IAgCrdnGridCoordinateDefinition * _result = 0;
    HRESULT _hr = get_AzimuthCoordinates(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnGridCoordinateDefinitionPtr(_result, false);
}

IAgCrdnGridCoordinateDefinitionPtr _IAgCrdnVolumeGridSpherical::GetElevationCoordinates ( ) {
    struct IAgCrdnGridCoordinateDefinition * _result = 0;
    HRESULT _hr = get_ElevationCoordinates(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnGridCoordinateDefinitionPtr(_result, false);
}

IAgCrdnGridCoordinateDefinitionPtr _IAgCrdnVolumeGridSpherical::GetRangeCoordinates ( ) {
    struct IAgCrdnGridCoordinateDefinition * _result = 0;
    HRESULT _hr = get_RangeCoordinates(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnGridCoordinateDefinitionPtr(_result, false);
}

enum AgECrdnKind _IAgCrdnVolumeGridSpherical::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVolumeGridSpherical::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVolumeGridSpherical::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVolumeGridSpherical::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVolumeGridSpherical::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVolumeGridSpherical::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeGridSpherical::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVolumeGridSpherical::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVolumeGridSpherical::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVolumeGridSpherical::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeGridSpherical::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVolumeGridSpherical::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVolumeGridSpherical::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnVolumeGridSpherical::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVolumeGridSpherical::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeGridSpherical::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVolumeGridSpherical::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVolumeGridSpherical::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVolumeGridSpherical::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVolumeInview wrapper method implementations
//

_variant_t _IAgCrdnVolumeInview::GetConstraintObject ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_ConstraintObject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgCrdnVolumeInview::PutConstraintObject ( const _variant_t & pRetVal ) {
    HRESULT _hr = put_ConstraintObject(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnLightTimeDelayPtr _IAgCrdnVolumeInview::GetLightTimeDelay ( ) {
    struct IAgCrdnLightTimeDelay * _result = 0;
    HRESULT _hr = get_LightTimeDelay(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnLightTimeDelayPtr(_result, false);
}

enum AgECrdnKind _IAgCrdnVolumeInview::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVolumeInview::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVolumeInview::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVolumeInview::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVolumeInview::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVolumeInview::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeInview::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVolumeInview::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVolumeInview::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVolumeInview::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeInview::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVolumeInview::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVolumeInview::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnVolumeInview::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVolumeInview::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeInview::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVolumeInview::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVolumeInview::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVolumeInview::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVolumeLighting wrapper method implementations
//

SAFEARRAY * _IAgCrdnVolumeLighting::GetEclipsingBodies ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_EclipsingBodies(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVolumeLighting::PutEclipsingBodies ( SAFEARRAY * ppRetVal ) {
    HRESULT _hr = put_EclipsingBodies(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnVolumeLighting::GetUseObjectEclipsingBodies ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseObjectEclipsingBodies(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVolumeLighting::PutUseObjectEclipsingBodies ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseObjectEclipsingBodies(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnVolumeLightingConditionsType _IAgCrdnVolumeLighting::GetLightingConditions ( ) {
    enum AgECrdnVolumeLightingConditionsType _result;
    HRESULT _hr = get_LightingConditions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVolumeLighting::PutLightingConditions ( enum AgECrdnVolumeLightingConditionsType pRetVal ) {
    HRESULT _hr = put_LightingConditions(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnVolumeLighting::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVolumeLighting::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVolumeLighting::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVolumeLighting::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVolumeLighting::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVolumeLighting::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeLighting::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVolumeLighting::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVolumeLighting::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVolumeLighting::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeLighting::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVolumeLighting::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVolumeLighting::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnVolumeLighting::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVolumeLighting::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeLighting::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVolumeLighting::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVolumeLighting::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVolumeLighting::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVolumeOverTime wrapper method implementations
//

enum AgECrdnVolumeOverTimeDurationType _IAgCrdnVolumeOverTime::GetDurationType ( ) {
    enum AgECrdnVolumeOverTimeDurationType _result;
    HRESULT _hr = get_DurationType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVolumeOverTime::PutDurationType ( enum AgECrdnVolumeOverTimeDurationType pRetVal ) {
    HRESULT _hr = put_DurationType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnVolumePtr _IAgCrdnVolumeOverTime::GetReferenceVolume ( ) {
    struct IAgCrdnVolume * _result = 0;
    HRESULT _hr = get_ReferenceVolume(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumePtr(_result, false);
}

void _IAgCrdnVolumeOverTime::PutReferenceVolume ( struct IAgCrdnVolume * ppRetVal ) {
    HRESULT _hr = put_ReferenceVolume(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnEventIntervalListPtr _IAgCrdnVolumeOverTime::GetReferenceIntervals ( ) {
    struct IAgCrdnEventIntervalList * _result = 0;
    HRESULT _hr = get_ReferenceIntervals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListPtr(_result, false);
}

void _IAgCrdnVolumeOverTime::PutReferenceIntervals ( struct IAgCrdnEventIntervalList * ppRetVal ) {
    HRESULT _hr = put_ReferenceIntervals(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnVolumeOverTime::GetStartOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_StartOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVolumeOverTime::PutStartOffset ( double pRetVal ) {
    HRESULT _hr = put_StartOffset(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnVolumeOverTime::GetStopOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_StopOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVolumeOverTime::PutStopOffset ( double pRetVal ) {
    HRESULT _hr = put_StopOffset(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnKind _IAgCrdnVolumeOverTime::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVolumeOverTime::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVolumeOverTime::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVolumeOverTime::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVolumeOverTime::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVolumeOverTime::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeOverTime::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVolumeOverTime::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVolumeOverTime::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVolumeOverTime::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeOverTime::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVolumeOverTime::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVolumeOverTime::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdnVolumeOverTime::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVolumeOverTime::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVolumeOverTime::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVolumeOverTime::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVolumeOverTime::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVolumeOverTime::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IAgCrdnEventIntervalListMerged wrapper method implementations
//

IAgCrdnPtr IAgCrdnEventIntervalListMerged::GetIntervalListOrIntervalA ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = get_IntervalListOrIntervalA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr IAgCrdnEventIntervalListMerged::GetIntervalListOrIntervalB ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = get_IntervalListOrIntervalB(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

enum AgECrdnEventListMergeOperation IAgCrdnEventIntervalListMerged::GetMergeOperation ( ) {
    enum AgECrdnEventListMergeOperation _result;
    HRESULT _hr = get_MergeOperation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void IAgCrdnEventIntervalListMerged::PutMergeOperation ( enum AgECrdnEventListMergeOperation pRetVal ) {
    HRESULT _hr = put_MergeOperation(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT IAgCrdnEventIntervalListMerged::SetIntervalListA ( struct IAgCrdnEventIntervalList * RefIntervals ) {
    HRESULT _hr = raw_SetIntervalListA(RefIntervals);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgCrdnEventIntervalListMerged::SetIntervalA ( struct IAgCrdnEventInterval * RefIntervals ) {
    HRESULT _hr = raw_SetIntervalA(RefIntervals);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgCrdnEventIntervalListMerged::SetIntervalListB ( struct IAgCrdnEventIntervalList * RefIntervals ) {
    HRESULT _hr = raw_SetIntervalListB(RefIntervals);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT IAgCrdnEventIntervalListMerged::SetIntervalB ( struct IAgCrdnEventInterval * RefIntervals ) {
    HRESULT _hr = raw_SetIntervalB(RefIntervals);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IAgCrdnInstance wrapper method implementations
//

_bstr_t IAgCrdnInstance::GetInstancePath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_InstancePath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

IAgCrdnPtr IAgCrdnInstance::GetTemplate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = get_Template(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

//
// interface IAgCrdnProvider wrapper method implementations
//

IAgCrdnVectorGroupPtr IAgCrdnProvider::GetVectors ( ) {
    struct IAgCrdnVectorGroup * _result = 0;
    HRESULT _hr = get_Vectors(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorGroupPtr(_result, false);
}

IAgCrdnPointGroupPtr IAgCrdnProvider::GetPoints ( ) {
    struct IAgCrdnPointGroup * _result = 0;
    HRESULT _hr = get_Points(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointGroupPtr(_result, false);
}

IAgCrdnAngleGroupPtr IAgCrdnProvider::GetAngles ( ) {
    struct IAgCrdnAngleGroup * _result = 0;
    HRESULT _hr = get_Angles(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleGroupPtr(_result, false);
}

IAgCrdnAxesGroupPtr IAgCrdnProvider::GetAxes ( ) {
    struct IAgCrdnAxesGroup * _result = 0;
    HRESULT _hr = get_Axes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesGroupPtr(_result, false);
}

IAgCrdnPlaneGroupPtr IAgCrdnProvider::GetPlanes ( ) {
    struct IAgCrdnPlaneGroup * _result = 0;
    HRESULT _hr = get_Planes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneGroupPtr(_result, false);
}

IAgCrdnSystemGroupPtr IAgCrdnProvider::GetSystems ( ) {
    struct IAgCrdnSystemGroup * _result = 0;
    HRESULT _hr = get_Systems(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemGroupPtr(_result, false);
}

IAgCrdnWellKnownSystemsPtr IAgCrdnProvider::GetWellKnownSystems ( ) {
    struct IAgCrdnWellKnownSystems * _result = 0;
    HRESULT _hr = get_WellKnownSystems(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnWellKnownSystemsPtr(_result, false);
}

IAgCrdnWellKnownAxesPtr IAgCrdnProvider::GetWellKnownAxes ( ) {
    struct IAgCrdnWellKnownAxes * _result = 0;
    HRESULT _hr = get_WellKnownAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnWellKnownAxesPtr(_result, false);
}

IAgCrdnEventGroupPtr IAgCrdnProvider::GetEvents ( ) {
    struct IAgCrdnEventGroup * _result = 0;
    HRESULT _hr = get_Events(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventGroupPtr(_result, false);
}

IAgCrdnEventIntervalGroupPtr IAgCrdnProvider::GetEventIntervals ( ) {
    struct IAgCrdnEventIntervalGroup * _result = 0;
    HRESULT _hr = get_EventIntervals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalGroupPtr(_result, false);
}

IAgCrdnCalcScalarGroupPtr IAgCrdnProvider::GetCalcScalars ( ) {
    struct IAgCrdnCalcScalarGroup * _result = 0;
    HRESULT _hr = get_CalcScalars(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarGroupPtr(_result, false);
}

IAgCrdnEventArrayGroupPtr IAgCrdnProvider::GetEventArrays ( ) {
    struct IAgCrdnEventArrayGroup * _result = 0;
    HRESULT _hr = get_EventArrays(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventArrayGroupPtr(_result, false);
}

IAgCrdnEventIntervalListGroupPtr IAgCrdnProvider::GetEventIntervalLists ( ) {
    struct IAgCrdnEventIntervalListGroup * _result = 0;
    HRESULT _hr = get_EventIntervalLists(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListGroupPtr(_result, false);
}

IAgCrdnEventIntervalCollectionGroupPtr IAgCrdnProvider::GetEventIntervalCollections ( ) {
    struct IAgCrdnEventIntervalCollectionGroup * _result = 0;
    HRESULT _hr = get_EventIntervalCollections(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalCollectionGroupPtr(_result, false);
}

IAgCrdnParameterSetGroupPtr IAgCrdnProvider::GetParameterSets ( ) {
    struct IAgCrdnParameterSetGroup * _result = 0;
    HRESULT _hr = get_ParameterSets(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnParameterSetGroupPtr(_result, false);
}

IAgCrdnConditionGroupPtr IAgCrdnProvider::GetConditions ( ) {
    struct IAgCrdnConditionGroup * _result = 0;
    HRESULT _hr = get_Conditions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConditionGroupPtr(_result, false);
}

VARIANT_BOOL IAgCrdnProvider::Supports ( enum AgECrdnKind Feature ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Supports(Feature, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnConditionSetGroupPtr IAgCrdnProvider::GetConditionSets ( ) {
    struct IAgCrdnConditionSetGroup * _result = 0;
    HRESULT _hr = get_ConditionSets(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConditionSetGroupPtr(_result, false);
}

IAgCrdnCollectionPtr IAgCrdnProvider::Import ( _bstr_t Filename ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = raw_Import(Filename, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

IAgCrdnVolumeGridGroupPtr IAgCrdnProvider::GetVolumeGrids ( ) {
    struct IAgCrdnVolumeGridGroup * _result = 0;
    HRESULT _hr = get_VolumeGrids(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumeGridGroupPtr(_result, false);
}

IAgCrdnVolumeGroupPtr IAgCrdnProvider::GetVolumes ( ) {
    struct IAgCrdnVolumeGroup * _result = 0;
    HRESULT _hr = get_Volumes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumeGroupPtr(_result, false);
}

//
// interface IAgCrdnRoot wrapper method implementations
//

IAgCrdnProviderPtr IAgCrdnRoot::GetTemplateProvider ( _bstr_t ClassName ) {
    struct IAgCrdnProvider * _result = 0;
    HRESULT _hr = raw_GetTemplateProvider(ClassName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnProviderPtr(_result, false);
}

IAgCrdnProviderPtr IAgCrdnRoot::GetProvider ( _bstr_t InstPath ) {
    struct IAgCrdnProvider * _result = 0;
    HRESULT _hr = raw_GetProvider(InstPath, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnProviderPtr(_result, false);
}

IAgCrdnWellKnownSystemsPtr IAgCrdnRoot::GetWellKnownSystems ( ) {
    struct IAgCrdnWellKnownSystems * _result = 0;
    HRESULT _hr = get_WellKnownSystems(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnWellKnownSystemsPtr(_result, false);
}

IAgCrdnWellKnownAxesPtr IAgCrdnRoot::GetWellKnownAxes ( ) {
    struct IAgCrdnWellKnownAxes * _result = 0;
    HRESULT _hr = get_WellKnownAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnWellKnownAxesPtr(_result, false);
}

//
// interface _IAgCrdn wrapper method implementations
//

enum AgECrdnKind _IAgCrdn::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdn::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdn::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdn::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdn::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdn::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdn::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdn::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdn::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdn::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdn::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdn::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdn::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPtr _IAgCrdn::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdn::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdn::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdn::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdn::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdn::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnInstance wrapper method implementations
//

VARIANT_BOOL _IAgCrdnInstance::GetIsTemplate ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsTemplate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnInstance::GetInstancePath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_InstancePath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

IAgCrdnPtr _IAgCrdnInstance::GetTemplate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = get_Template(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

//
// interface _IAgCrdnVector wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVector::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVector::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVector::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVector::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVector::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVector::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVector::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVector::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVector::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVector::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVector::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVector::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVector::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVector::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVector::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVector::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVector::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVector::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVector::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVector::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVector::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVector::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVector::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnAxes wrapper method implementations
//

enum AgECrdnKind _IAgCrdnAxes::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnAxes::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAxes::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAxes::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxes::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxes::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxes::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnAxes::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnAxes::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnAxes::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxes::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxes::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxes::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnAxes::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnAxesType _IAgCrdnAxes::GetType ( ) {
    enum AgECrdnAxesType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAxesFindInAxesWithRateResultPtr _IAgCrdnAxes::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesResultPtr _IAgCrdnAxes::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesResultPtr(_result, false);
}

IAgCrdnAxesLabelsPtr _IAgCrdnAxes::GetLabels ( ) {
    struct IAgCrdnAxesLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesLabelsPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnAxes::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnAxes::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnAxes::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnAxes::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxes::GetX ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_X(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxes::GetY ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_Y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxes::GetZ ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_Z(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxes::Transform ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_Transform(Epoch, OutputAxes, VectorInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxes::TransformWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes, struct STKUtil::IAgCartesian3Vector * RateInMyAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformWithRate(Epoch, OutputAxes, VectorInMyAxes, RateInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

HRESULT _IAgCrdnAxes::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnAxes::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnPoint wrapper method implementations
//

enum AgECrdnKind _IAgCrdnPoint::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnPoint::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPoint::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnPoint::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPoint::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPoint::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPoint::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnPoint::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnPoint::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnPoint::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPoint::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPoint::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPoint::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnPoint::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnPointType _IAgCrdnPoint::GetType ( ) {
    enum AgECrdnPointType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointLocateInSystemWithRateResultPtr _IAgCrdnPoint::LocateInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_LocateInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPointLocateInSystemResultPtr _IAgCrdnPoint::LocateInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemResult * _result = 0;
    HRESULT _hr = raw_LocateInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemResultPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnPoint::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnPoint::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnPoint::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnPoint::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnPoint::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnPoint::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnSystem wrapper method implementations
//

enum AgECrdnKind _IAgCrdnSystem::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnSystem::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnSystem::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnSystem::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnSystem::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnSystem::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnSystem::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnSystem::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnSystem::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnSystem::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnSystem::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnSystem::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnSystem::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnSystem::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnSystemType _IAgCrdnSystem::GetType ( ) {
    enum AgECrdnSystemType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnSystemFindInSystemResultPtr _IAgCrdnSystem::FindInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnSystemFindInSystemResult * _result = 0;
    HRESULT _hr = raw_FindInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemFindInSystemResultPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnSystem::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnSystem::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnSystem::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnSystem::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

IAgCrdnSystemTransformResultPtr _IAgCrdnSystem::Transform ( const _variant_t & Epoch, struct IAgCrdnSystem * OutputSystem, struct STKUtil::IAgCartesian3Vector * PositionInMySystem ) {
    struct IAgCrdnSystemTransformResult * _result = 0;
    HRESULT _hr = raw_Transform(Epoch, OutputSystem, PositionInMySystem, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemTransformResultPtr(_result, false);
}

IAgCrdnSystemTransformWithRateResultPtr _IAgCrdnSystem::TransformWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * OutputSystem, struct STKUtil::IAgCartesian3Vector * PositionInMySystem, struct STKUtil::IAgCartesian3Vector * VelocityInMySystem ) {
    struct IAgCrdnSystemTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformWithRate(Epoch, OutputSystem, PositionInMySystem, VelocityInMySystem, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemTransformWithRateResultPtr(_result, false);
}

HRESULT _IAgCrdnSystem::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnSystem::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnAngle wrapper method implementations
//

enum AgECrdnKind _IAgCrdnAngle::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnAngle::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAngle::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAngle::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAngle::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAngle::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAngle::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnAngle::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnAngle::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnAngle::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAngle::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAngle::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAngle::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnAngle::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnAngleType _IAgCrdnAngle::GetType ( ) {
    enum AgECrdnAngleType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAngleFindAngleResultPtr _IAgCrdnAngle::FindAngle ( const _variant_t & Epoch ) {
    struct IAgCrdnAngleFindAngleResult * _result = 0;
    HRESULT _hr = raw_FindAngle(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindAngleResultPtr(_result, false);
}

IAgCrdnAngleFindAngleWithRateResultPtr _IAgCrdnAngle::FindAngleWithRate ( const _variant_t & Epoch ) {
    struct IAgCrdnAngleFindAngleWithRateResult * _result = 0;
    HRESULT _hr = raw_FindAngleWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindAngleWithRateResultPtr(_result, false);
}

IAgCrdnAngleFindResultPtr _IAgCrdnAngle::FindCoordinates ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAngleFindResult * _result = 0;
    HRESULT _hr = raw_FindCoordinates(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindResultPtr(_result, false);
}

IAgCrdnAngleFindWithRateResultPtr _IAgCrdnAngle::FindCoordinatesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAngleFindWithRateResult * _result = 0;
    HRESULT _hr = raw_FindCoordinatesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindWithRateResultPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnAngle::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnAngle::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnAngle::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnAngle::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnAngle::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnAngle::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnPlane wrapper method implementations
//

enum AgECrdnKind _IAgCrdnPlane::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnPlane::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPlane::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnPlane::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPlane::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPlane::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPlane::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnPlane::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnPlane::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnPlane::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPlane::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPlane::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPlane::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnPlane::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnPlaneType _IAgCrdnPlane::GetType ( ) {
    enum AgECrdnPlaneType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPlaneFindInAxesResultPtr _IAgCrdnPlane::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnPlaneFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInAxesResultPtr(_result, false);
}

IAgCrdnPlaneFindInAxesWithRateResultPtr _IAgCrdnPlane::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnPlaneFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnPlaneFindInSystemResultPtr _IAgCrdnPlane::FindInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPlaneFindInSystemResult * _result = 0;
    HRESULT _hr = raw_FindInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInSystemResultPtr(_result, false);
}

IAgCrdnPlaneFindInSystemWithRateResultPtr _IAgCrdnPlane::FindInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPlaneFindInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPlaneLabelsPtr _IAgCrdnPlane::GetLabels ( ) {
    struct IAgCrdnPlaneLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneLabelsPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnPlane::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnPlane::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnPlane::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnPlane::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnPlane::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnPlane::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnAxesAlignedAndConstrained wrapper method implementations
//

enum AgECrdnKind _IAgCrdnAxesAlignedAndConstrained::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnAxesAlignedAndConstrained::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAxesAlignedAndConstrained::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAxesAlignedAndConstrained::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesAlignedAndConstrained::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesAlignedAndConstrained::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesAlignedAndConstrained::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnAxesAlignedAndConstrained::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnAxesAlignedAndConstrained::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnAxesAlignedAndConstrained::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesAlignedAndConstrained::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesAlignedAndConstrained::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesAlignedAndConstrained::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnAxesAlignedAndConstrained::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnAxesType _IAgCrdnAxesAlignedAndConstrained::GetType ( ) {
    enum AgECrdnAxesType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAxesFindInAxesWithRateResultPtr _IAgCrdnAxesAlignedAndConstrained::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesResultPtr _IAgCrdnAxesAlignedAndConstrained::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesResultPtr(_result, false);
}

IAgCrdnAxesLabelsPtr _IAgCrdnAxesAlignedAndConstrained::GetLabels ( ) {
    struct IAgCrdnAxesLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesLabelsPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnAxesAlignedAndConstrained::GetAlignmentReferenceVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_AlignmentReferenceVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnAxesAlignedAndConstrained::GetConstraintReferenceVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_ConstraintReferenceVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

STKUtil::IAgDirectionPtr _IAgCrdnAxesAlignedAndConstrained::GetAlignmentDirection ( ) {
    struct STKUtil::IAgDirection * _result = 0;
    HRESULT _hr = get_AlignmentDirection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgDirectionPtr(_result, false);
}

STKUtil::IAgDirectionPtr _IAgCrdnAxesAlignedAndConstrained::GetConstraintDirection ( ) {
    struct STKUtil::IAgDirection * _result = 0;
    HRESULT _hr = get_ConstraintDirection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgDirectionPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnAxesAlignedAndConstrained::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnAxesAlignedAndConstrained::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesAlignedAndConstrained::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnAxesAlignedAndConstrained::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesAlignedAndConstrained::GetX ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_X(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesAlignedAndConstrained::GetY ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_Y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesAlignedAndConstrained::GetZ ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_Z(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxesAlignedAndConstrained::Transform ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_Transform(Epoch, OutputAxes, VectorInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxesAlignedAndConstrained::TransformWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes, struct STKUtil::IAgCartesian3Vector * RateInMyAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformWithRate(Epoch, OutputAxes, VectorInMyAxes, RateInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

HRESULT _IAgCrdnAxesAlignedAndConstrained::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnAxesAlignedAndConstrained::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnAxesAngularOffset wrapper method implementations
//

enum AgECrdnKind _IAgCrdnAxesAngularOffset::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnAxesAngularOffset::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAxesAngularOffset::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAxesAngularOffset::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesAngularOffset::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesAngularOffset::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesAngularOffset::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnAxesAngularOffset::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnAxesAngularOffset::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnAxesAngularOffset::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesAngularOffset::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesAngularOffset::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesAngularOffset::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnAxesAngularOffset::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnAxesType _IAgCrdnAxesAngularOffset::GetType ( ) {
    enum AgECrdnAxesType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAxesFindInAxesWithRateResultPtr _IAgCrdnAxesAngularOffset::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesResultPtr _IAgCrdnAxesAngularOffset::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesResultPtr(_result, false);
}

IAgCrdnAxesLabelsPtr _IAgCrdnAxesAngularOffset::GetLabels ( ) {
    struct IAgCrdnAxesLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesLabelsPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnAxesAngularOffset::GetSpinVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_SpinVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnAngleRefToPtr _IAgCrdnAxesAngularOffset::GetRotationAngle ( ) {
    struct IAgCrdnAngleRefTo * _result = 0;
    HRESULT _hr = get_RotationAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleRefToPtr(_result, false);
}

IAgCrdnAxesRefToPtr _IAgCrdnAxesAngularOffset::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

double _IAgCrdnAxesAngularOffset::GetFixedOffsetAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_FixedOffsetAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnAxesAngularOffset::PutFixedOffsetAngle ( double pRetVal ) {
    HRESULT _hr = put_FixedOffsetAngle(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPtr _IAgCrdnAxesAngularOffset::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnAxesAngularOffset::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesAngularOffset::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnAxesAngularOffset::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesAngularOffset::GetX ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_X(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesAngularOffset::GetY ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_Y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesAngularOffset::GetZ ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_Z(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxesAngularOffset::Transform ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_Transform(Epoch, OutputAxes, VectorInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxesAngularOffset::TransformWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes, struct STKUtil::IAgCartesian3Vector * RateInMyAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformWithRate(Epoch, OutputAxes, VectorInMyAxes, RateInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

HRESULT _IAgCrdnAxesAngularOffset::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnAxesAngularOffset::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnAxesFixedAtEpoch wrapper method implementations
//

enum AgECrdnKind _IAgCrdnAxesFixedAtEpoch::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnAxesFixedAtEpoch::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAxesFixedAtEpoch::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAxesFixedAtEpoch::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesFixedAtEpoch::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesFixedAtEpoch::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesFixedAtEpoch::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnAxesFixedAtEpoch::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnAxesFixedAtEpoch::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnAxesFixedAtEpoch::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesFixedAtEpoch::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesFixedAtEpoch::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesFixedAtEpoch::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnAxesFixedAtEpoch::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnAxesType _IAgCrdnAxesFixedAtEpoch::GetType ( ) {
    enum AgECrdnAxesType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAxesFindInAxesWithRateResultPtr _IAgCrdnAxesFixedAtEpoch::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesResultPtr _IAgCrdnAxesFixedAtEpoch::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesResultPtr(_result, false);
}

IAgCrdnAxesLabelsPtr _IAgCrdnAxesFixedAtEpoch::GetLabels ( ) {
    struct IAgCrdnAxesLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesLabelsPtr(_result, false);
}

IAgCrdnAxesRefToPtr _IAgCrdnAxesFixedAtEpoch::GetSourceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_SourceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

IAgCrdnAxesRefToPtr _IAgCrdnAxesFixedAtEpoch::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

_variant_t _IAgCrdnAxesFixedAtEpoch::GetEpoch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Epoch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgCrdnAxesFixedAtEpoch::PutEpoch ( const _variant_t & pRetVal ) {
    HRESULT _hr = put_Epoch(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPtr _IAgCrdnAxesFixedAtEpoch::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnAxesFixedAtEpoch::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesFixedAtEpoch::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnAxesFixedAtEpoch::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesFixedAtEpoch::GetX ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_X(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesFixedAtEpoch::GetY ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_Y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesFixedAtEpoch::GetZ ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_Z(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxesFixedAtEpoch::Transform ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_Transform(Epoch, OutputAxes, VectorInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxesFixedAtEpoch::TransformWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes, struct STKUtil::IAgCartesian3Vector * RateInMyAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformWithRate(Epoch, OutputAxes, VectorInMyAxes, RateInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

HRESULT _IAgCrdnAxesFixedAtEpoch::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnAxesFixedAtEpoch::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnAxesBPlane wrapper method implementations
//

enum AgECrdnKind _IAgCrdnAxesBPlane::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnAxesBPlane::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAxesBPlane::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAxesBPlane::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesBPlane::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesBPlane::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesBPlane::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnAxesBPlane::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnAxesBPlane::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnAxesBPlane::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesBPlane::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesBPlane::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesBPlane::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnAxesBPlane::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnAxesType _IAgCrdnAxesBPlane::GetType ( ) {
    enum AgECrdnAxesType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAxesFindInAxesWithRateResultPtr _IAgCrdnAxesBPlane::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesResultPtr _IAgCrdnAxesBPlane::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesResultPtr(_result, false);
}

IAgCrdnAxesLabelsPtr _IAgCrdnAxesBPlane::GetLabels ( ) {
    struct IAgCrdnAxesLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesLabelsPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnAxesBPlane::GetTrajectory ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_Trajectory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnAxesBPlane::GetReferenceVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_ReferenceVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnCentralBodyRefToPtr _IAgCrdnAxesBPlane::GetTargetBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_TargetBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

enum AgECrdnDirectionType _IAgCrdnAxesBPlane::GetDirection ( ) {
    enum AgECrdnDirectionType _result;
    HRESULT _hr = get_Direction(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnAxesBPlane::PutDirection ( enum AgECrdnDirectionType pRetVal ) {
    HRESULT _hr = put_Direction(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPtr _IAgCrdnAxesBPlane::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnAxesBPlane::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesBPlane::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnAxesBPlane::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesBPlane::GetX ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_X(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesBPlane::GetY ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_Y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesBPlane::GetZ ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_Z(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxesBPlane::Transform ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_Transform(Epoch, OutputAxes, VectorInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxesBPlane::TransformWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes, struct STKUtil::IAgCartesian3Vector * RateInMyAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformWithRate(Epoch, OutputAxes, VectorInMyAxes, RateInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

HRESULT _IAgCrdnAxesBPlane::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnAxesBPlane::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnAxesCustomScript wrapper method implementations
//

enum AgECrdnKind _IAgCrdnAxesCustomScript::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnAxesCustomScript::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAxesCustomScript::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAxesCustomScript::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesCustomScript::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesCustomScript::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesCustomScript::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnAxesCustomScript::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnAxesCustomScript::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnAxesCustomScript::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesCustomScript::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesCustomScript::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesCustomScript::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnAxesCustomScript::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnAxesType _IAgCrdnAxesCustomScript::GetType ( ) {
    enum AgECrdnAxesType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAxesFindInAxesWithRateResultPtr _IAgCrdnAxesCustomScript::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesResultPtr _IAgCrdnAxesCustomScript::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesResultPtr(_result, false);
}

IAgCrdnAxesLabelsPtr _IAgCrdnAxesCustomScript::GetLabels ( ) {
    struct IAgCrdnAxesLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesLabelsPtr(_result, false);
}

IAgCrdnAxesRefToPtr _IAgCrdnAxesCustomScript::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

_bstr_t _IAgCrdnAxesCustomScript::GetFilename ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Filename(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAxesCustomScript::PutFilename ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Filename(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPtr _IAgCrdnAxesCustomScript::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnAxesCustomScript::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesCustomScript::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnAxesCustomScript::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesCustomScript::GetX ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_X(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesCustomScript::GetY ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_Y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesCustomScript::GetZ ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_Z(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxesCustomScript::Transform ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_Transform(Epoch, OutputAxes, VectorInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxesCustomScript::TransformWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes, struct STKUtil::IAgCartesian3Vector * RateInMyAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformWithRate(Epoch, OutputAxes, VectorInMyAxes, RateInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

HRESULT _IAgCrdnAxesCustomScript::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnAxesCustomScript::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnAxesAttitudeFile wrapper method implementations
//

enum AgECrdnKind _IAgCrdnAxesAttitudeFile::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnAxesAttitudeFile::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAxesAttitudeFile::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAxesAttitudeFile::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesAttitudeFile::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesAttitudeFile::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesAttitudeFile::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnAxesAttitudeFile::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnAxesAttitudeFile::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnAxesAttitudeFile::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesAttitudeFile::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesAttitudeFile::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesAttitudeFile::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnAxesAttitudeFile::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnAxesType _IAgCrdnAxesAttitudeFile::GetType ( ) {
    enum AgECrdnAxesType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAxesFindInAxesWithRateResultPtr _IAgCrdnAxesAttitudeFile::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesResultPtr _IAgCrdnAxesAttitudeFile::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesResultPtr(_result, false);
}

IAgCrdnAxesLabelsPtr _IAgCrdnAxesAttitudeFile::GetLabels ( ) {
    struct IAgCrdnAxesLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesLabelsPtr(_result, false);
}

_bstr_t _IAgCrdnAxesAttitudeFile::GetFilename ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Filename(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAxesAttitudeFile::PutFilename ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Filename(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPtr _IAgCrdnAxesAttitudeFile::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnAxesAttitudeFile::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesAttitudeFile::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnAxesAttitudeFile::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesAttitudeFile::GetX ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_X(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesAttitudeFile::GetY ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_Y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesAttitudeFile::GetZ ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_Z(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxesAttitudeFile::Transform ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_Transform(Epoch, OutputAxes, VectorInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxesAttitudeFile::TransformWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes, struct STKUtil::IAgCartesian3Vector * RateInMyAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformWithRate(Epoch, OutputAxes, VectorInMyAxes, RateInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

HRESULT _IAgCrdnAxesAttitudeFile::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnAxesAttitudeFile::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnAxesFixed wrapper method implementations
//

enum AgECrdnKind _IAgCrdnAxesFixed::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnAxesFixed::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAxesFixed::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAxesFixed::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesFixed::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesFixed::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesFixed::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnAxesFixed::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnAxesFixed::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnAxesFixed::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesFixed::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesFixed::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesFixed::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnAxesFixed::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnAxesType _IAgCrdnAxesFixed::GetType ( ) {
    enum AgECrdnAxesType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAxesFindInAxesWithRateResultPtr _IAgCrdnAxesFixed::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesResultPtr _IAgCrdnAxesFixed::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesResultPtr(_result, false);
}

IAgCrdnAxesLabelsPtr _IAgCrdnAxesFixed::GetLabels ( ) {
    struct IAgCrdnAxesLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesLabelsPtr(_result, false);
}

IAgCrdnAxesRefToPtr _IAgCrdnAxesFixed::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

STKUtil::IAgOrientationPtr _IAgCrdnAxesFixed::GetFixedOrientation ( ) {
    struct STKUtil::IAgOrientation * _result = 0;
    HRESULT _hr = get_FixedOrientation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgOrientationPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnAxesFixed::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnAxesFixed::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesFixed::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnAxesFixed::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesFixed::GetX ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_X(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesFixed::GetY ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_Y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesFixed::GetZ ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_Z(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxesFixed::Transform ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_Transform(Epoch, OutputAxes, VectorInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxesFixed::TransformWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes, struct STKUtil::IAgCartesian3Vector * RateInMyAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformWithRate(Epoch, OutputAxes, VectorInMyAxes, RateInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

HRESULT _IAgCrdnAxesFixed::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnAxesFixed::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnAxesModelAttach wrapper method implementations
//

enum AgECrdnKind _IAgCrdnAxesModelAttach::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnAxesModelAttach::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAxesModelAttach::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAxesModelAttach::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesModelAttach::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesModelAttach::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesModelAttach::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnAxesModelAttach::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnAxesModelAttach::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnAxesModelAttach::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesModelAttach::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesModelAttach::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesModelAttach::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnAxesModelAttach::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnAxesType _IAgCrdnAxesModelAttach::GetType ( ) {
    enum AgECrdnAxesType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAxesFindInAxesWithRateResultPtr _IAgCrdnAxesModelAttach::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesResultPtr _IAgCrdnAxesModelAttach::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesResultPtr(_result, false);
}

IAgCrdnAxesLabelsPtr _IAgCrdnAxesModelAttach::GetLabels ( ) {
    struct IAgCrdnAxesLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesLabelsPtr(_result, false);
}

_bstr_t _IAgCrdnAxesModelAttach::GetPointableElementName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_PointableElementName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAxesModelAttach::PutPointableElementName ( _bstr_t pRetVal ) {
    HRESULT _hr = put_PointableElementName(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPtr _IAgCrdnAxesModelAttach::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnAxesModelAttach::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesModelAttach::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnAxesModelAttach::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesModelAttach::GetX ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_X(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesModelAttach::GetY ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_Y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesModelAttach::GetZ ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_Z(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxesModelAttach::Transform ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_Transform(Epoch, OutputAxes, VectorInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxesModelAttach::TransformWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes, struct STKUtil::IAgCartesian3Vector * RateInMyAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformWithRate(Epoch, OutputAxes, VectorInMyAxes, RateInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

HRESULT _IAgCrdnAxesModelAttach::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnAxesModelAttach::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnAxesSpinning wrapper method implementations
//

enum AgECrdnKind _IAgCrdnAxesSpinning::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnAxesSpinning::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAxesSpinning::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAxesSpinning::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesSpinning::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesSpinning::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesSpinning::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnAxesSpinning::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnAxesSpinning::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnAxesSpinning::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesSpinning::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesSpinning::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesSpinning::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnAxesSpinning::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnAxesType _IAgCrdnAxesSpinning::GetType ( ) {
    enum AgECrdnAxesType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAxesFindInAxesWithRateResultPtr _IAgCrdnAxesSpinning::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesResultPtr _IAgCrdnAxesSpinning::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesResultPtr(_result, false);
}

IAgCrdnAxesLabelsPtr _IAgCrdnAxesSpinning::GetLabels ( ) {
    struct IAgCrdnAxesLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesLabelsPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnAxesSpinning::GetSpinVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_SpinVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnAxesRefToPtr _IAgCrdnAxesSpinning::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

_variant_t _IAgCrdnAxesSpinning::GetEpoch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Epoch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgCrdnAxesSpinning::PutEpoch ( const _variant_t & pRetVal ) {
    HRESULT _hr = put_Epoch(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnAxesSpinning::GetInitialOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_InitialOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnAxesSpinning::PutInitialOffset ( double pRetVal ) {
    HRESULT _hr = put_InitialOffset(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnAxesSpinning::GetSpinRate ( ) {
    double _result = 0;
    HRESULT _hr = get_SpinRate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnAxesSpinning::PutSpinRate ( double pRetVal ) {
    HRESULT _hr = put_SpinRate(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPtr _IAgCrdnAxesSpinning::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnAxesSpinning::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesSpinning::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnAxesSpinning::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesSpinning::GetX ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_X(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesSpinning::GetY ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_Y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesSpinning::GetZ ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_Z(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxesSpinning::Transform ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_Transform(Epoch, OutputAxes, VectorInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxesSpinning::TransformWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes, struct STKUtil::IAgCartesian3Vector * RateInMyAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformWithRate(Epoch, OutputAxes, VectorInMyAxes, RateInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

HRESULT _IAgCrdnAxesSpinning::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnAxesSpinning::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnAxesOnSurface wrapper method implementations
//

enum AgECrdnKind _IAgCrdnAxesOnSurface::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnAxesOnSurface::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAxesOnSurface::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAxesOnSurface::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesOnSurface::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesOnSurface::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesOnSurface::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnAxesOnSurface::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnAxesOnSurface::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnAxesOnSurface::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesOnSurface::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesOnSurface::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesOnSurface::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnAxesOnSurface::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnAxesType _IAgCrdnAxesOnSurface::GetType ( ) {
    enum AgECrdnAxesType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAxesFindInAxesWithRateResultPtr _IAgCrdnAxesOnSurface::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesResultPtr _IAgCrdnAxesOnSurface::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesResultPtr(_result, false);
}

IAgCrdnAxesLabelsPtr _IAgCrdnAxesOnSurface::GetLabels ( ) {
    struct IAgCrdnAxesLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesLabelsPtr(_result, false);
}

IAgCrdnCentralBodyRefToPtr _IAgCrdnAxesOnSurface::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnAxesOnSurface::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesOnSurface::GetUseMSL ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseMSL(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnAxesOnSurface::PutUseMSL ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseMSL(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPtr _IAgCrdnAxesOnSurface::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnAxesOnSurface::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesOnSurface::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnAxesOnSurface::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesOnSurface::GetX ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_X(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesOnSurface::GetY ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_Y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesOnSurface::GetZ ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_Z(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxesOnSurface::Transform ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_Transform(Epoch, OutputAxes, VectorInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxesOnSurface::TransformWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes, struct STKUtil::IAgCartesian3Vector * RateInMyAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformWithRate(Epoch, OutputAxes, VectorInMyAxes, RateInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

HRESULT _IAgCrdnAxesOnSurface::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnAxesOnSurface::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnAxesTrajectory wrapper method implementations
//

enum AgECrdnKind _IAgCrdnAxesTrajectory::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnAxesTrajectory::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAxesTrajectory::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAxesTrajectory::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesTrajectory::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesTrajectory::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesTrajectory::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnAxesTrajectory::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnAxesTrajectory::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnAxesTrajectory::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesTrajectory::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesTrajectory::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesTrajectory::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnAxesTrajectory::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnAxesType _IAgCrdnAxesTrajectory::GetType ( ) {
    enum AgECrdnAxesType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAxesFindInAxesWithRateResultPtr _IAgCrdnAxesTrajectory::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesResultPtr _IAgCrdnAxesTrajectory::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesResultPtr(_result, false);
}

IAgCrdnAxesLabelsPtr _IAgCrdnAxesTrajectory::GetLabels ( ) {
    struct IAgCrdnAxesLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesLabelsPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnAxesTrajectory::GetTrajectoryPoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_TrajectoryPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnSystemRefToPtr _IAgCrdnAxesTrajectory::GetReferenceSystem ( ) {
    struct IAgCrdnSystemRefTo * _result = 0;
    HRESULT _hr = get_ReferenceSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemRefToPtr(_result, false);
}

enum AgECrdnTrajectoryAxesType _IAgCrdnAxesTrajectory::GetTrajectoryAxesType ( ) {
    enum AgECrdnTrajectoryAxesType _result;
    HRESULT _hr = get_TrajectoryAxesType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnAxesTrajectory::PutTrajectoryAxesType ( enum AgECrdnTrajectoryAxesType pRetVal ) {
    HRESULT _hr = put_TrajectoryAxesType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPtr _IAgCrdnAxesTrajectory::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnAxesTrajectory::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesTrajectory::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnAxesTrajectory::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesTrajectory::GetX ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_X(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesTrajectory::GetY ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_Y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesTrajectory::GetZ ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_Z(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxesTrajectory::Transform ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_Transform(Epoch, OutputAxes, VectorInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxesTrajectory::TransformWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes, struct STKUtil::IAgCartesian3Vector * RateInMyAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformWithRate(Epoch, OutputAxes, VectorInMyAxes, RateInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

HRESULT _IAgCrdnAxesTrajectory::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnAxesTrajectory::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnAxesLagrangeLibration wrapper method implementations
//

enum AgECrdnKind _IAgCrdnAxesLagrangeLibration::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnAxesLagrangeLibration::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAxesLagrangeLibration::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAxesLagrangeLibration::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesLagrangeLibration::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesLagrangeLibration::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesLagrangeLibration::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnAxesLagrangeLibration::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnAxesLagrangeLibration::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnAxesLagrangeLibration::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesLagrangeLibration::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesLagrangeLibration::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesLagrangeLibration::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnAxesLagrangeLibration::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnAxesType _IAgCrdnAxesLagrangeLibration::GetType ( ) {
    enum AgECrdnAxesType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAxesFindInAxesWithRateResultPtr _IAgCrdnAxesLagrangeLibration::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesResultPtr _IAgCrdnAxesLagrangeLibration::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesResultPtr(_result, false);
}

IAgCrdnAxesLabelsPtr _IAgCrdnAxesLagrangeLibration::GetLabels ( ) {
    struct IAgCrdnAxesLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesLabelsPtr(_result, false);
}

IAgCrdnCentralBodyRefToPtr _IAgCrdnAxesLagrangeLibration::GetPrimaryCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_PrimaryCentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

enum AgECrdnLagrangeLibrationPointType _IAgCrdnAxesLagrangeLibration::GetPointType ( ) {
    enum AgECrdnLagrangeLibrationPointType _result;
    HRESULT _hr = get_PointType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnAxesLagrangeLibration::PutPointType ( enum AgECrdnLagrangeLibrationPointType pRetVal ) {
    HRESULT _hr = put_PointType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnCentralBodyCollectionPtr _IAgCrdnAxesLagrangeLibration::GetSecondaryCentralBodies ( ) {
    struct IAgCrdnCentralBodyCollection * _result = 0;
    HRESULT _hr = get_SecondaryCentralBodies(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyCollectionPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnAxesLagrangeLibration::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnAxesLagrangeLibration::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesLagrangeLibration::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnAxesLagrangeLibration::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesLagrangeLibration::GetX ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_X(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesLagrangeLibration::GetY ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_Y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesLagrangeLibration::GetZ ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_Z(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxesLagrangeLibration::Transform ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_Transform(Epoch, OutputAxes, VectorInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxesLagrangeLibration::TransformWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes, struct STKUtil::IAgCartesian3Vector * RateInMyAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformWithRate(Epoch, OutputAxes, VectorInMyAxes, RateInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

HRESULT _IAgCrdnAxesLagrangeLibration::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnAxesLagrangeLibration::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnAxesAtTimeInstant wrapper method implementations
//

enum AgECrdnKind _IAgCrdnAxesAtTimeInstant::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnAxesAtTimeInstant::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAxesAtTimeInstant::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAxesAtTimeInstant::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesAtTimeInstant::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesAtTimeInstant::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesAtTimeInstant::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnAxesAtTimeInstant::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnAxesAtTimeInstant::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnAxesAtTimeInstant::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesAtTimeInstant::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesAtTimeInstant::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesAtTimeInstant::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnAxesAtTimeInstant::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnAxesType _IAgCrdnAxesAtTimeInstant::GetType ( ) {
    enum AgECrdnAxesType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAxesFindInAxesWithRateResultPtr _IAgCrdnAxesAtTimeInstant::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesResultPtr _IAgCrdnAxesAtTimeInstant::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesResultPtr(_result, false);
}

IAgCrdnAxesLabelsPtr _IAgCrdnAxesAtTimeInstant::GetLabels ( ) {
    struct IAgCrdnAxesLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesLabelsPtr(_result, false);
}

IAgCrdnEventPtr _IAgCrdnAxesAtTimeInstant::GetReferenceTimeInstant ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_ReferenceTimeInstant(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

void _IAgCrdnAxesAtTimeInstant::PutReferenceTimeInstant ( struct IAgCrdnEvent * ppRetVal ) {
    HRESULT _hr = put_ReferenceTimeInstant(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnAxesPtr _IAgCrdnAxesAtTimeInstant::GetSourceAxes ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_SourceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

void _IAgCrdnAxesAtTimeInstant::PutSourceAxes ( struct IAgCrdnAxes * ppRetVal ) {
    HRESULT _hr = put_SourceAxes(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnAxesPtr _IAgCrdnAxesAtTimeInstant::GetReferenceAxes ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

void _IAgCrdnAxesAtTimeInstant::PutReferenceAxes ( struct IAgCrdnAxes * ppRetVal ) {
    HRESULT _hr = put_ReferenceAxes(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPtr _IAgCrdnAxesAtTimeInstant::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnAxesAtTimeInstant::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesAtTimeInstant::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnAxesAtTimeInstant::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesAtTimeInstant::GetX ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_X(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesAtTimeInstant::GetY ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_Y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesAtTimeInstant::GetZ ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_Z(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxesAtTimeInstant::Transform ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_Transform(Epoch, OutputAxes, VectorInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxesAtTimeInstant::TransformWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes, struct STKUtil::IAgCartesian3Vector * RateInMyAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformWithRate(Epoch, OutputAxes, VectorInMyAxes, RateInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

HRESULT _IAgCrdnAxesAtTimeInstant::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnAxesAtTimeInstant::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnAxesPlugin wrapper method implementations
//

enum AgECrdnKind _IAgCrdnAxesPlugin::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnAxesPlugin::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAxesPlugin::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAxesPlugin::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesPlugin::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesPlugin::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesPlugin::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnAxesPlugin::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnAxesPlugin::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnAxesPlugin::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesPlugin::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesPlugin::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAxesPlugin::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnAxesPlugin::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnAxesType _IAgCrdnAxesPlugin::GetType ( ) {
    enum AgECrdnAxesType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAxesFindInAxesWithRateResultPtr _IAgCrdnAxesPlugin::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnAxesFindInAxesResultPtr _IAgCrdnAxesPlugin::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAxesFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesFindInAxesResultPtr(_result, false);
}

IAgCrdnAxesLabelsPtr _IAgCrdnAxesPlugin::GetLabels ( ) {
    struct IAgCrdnAxesLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesLabelsPtr(_result, false);
}

_bstr_t _IAgCrdnAxesPlugin::GetProgID ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ProgID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAxesPlugin::GetDisplayName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DisplayName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

SAFEARRAY * _IAgCrdnAxesPlugin::GetAvailableProperties ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_AvailableProperties(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgCrdnAxesPlugin::Reset ( ) {
    HRESULT _hr = raw_Reset();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnAxesPlugin::SetProperty ( _bstr_t Name, _bstr_t Value ) {
    HRESULT _hr = raw_SetProperty(Name, Value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t _IAgCrdnAxesPlugin::GetProperty ( _bstr_t Name ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetProperty(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

IAgCrdnPtr _IAgCrdnAxesPlugin::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnAxesPlugin::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnAxesPlugin::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnAxesPlugin::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesPlugin::GetX ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_X(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesPlugin::GetY ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_Y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnAxesPlugin::GetZ ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_Z(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

IAgCrdnAxesTransformResultPtr _IAgCrdnAxesPlugin::Transform ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes ) {
    struct IAgCrdnAxesTransformResult * _result = 0;
    HRESULT _hr = raw_Transform(Epoch, OutputAxes, VectorInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformResultPtr(_result, false);
}

IAgCrdnAxesTransformWithRateResultPtr _IAgCrdnAxesPlugin::TransformWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * OutputAxes, struct STKUtil::IAgCartesian3Vector * VectorInMyAxes, struct STKUtil::IAgCartesian3Vector * RateInMyAxes ) {
    struct IAgCrdnAxesTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformWithRate(Epoch, OutputAxes, VectorInMyAxes, RateInMyAxes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesTransformWithRateResultPtr(_result, false);
}

HRESULT _IAgCrdnAxesPlugin::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnAxesPlugin::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnAngleBetweenVectors wrapper method implementations
//

enum AgECrdnKind _IAgCrdnAngleBetweenVectors::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnAngleBetweenVectors::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAngleBetweenVectors::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAngleBetweenVectors::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAngleBetweenVectors::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAngleBetweenVectors::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAngleBetweenVectors::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnAngleBetweenVectors::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnAngleBetweenVectors::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnAngleBetweenVectors::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAngleBetweenVectors::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAngleBetweenVectors::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAngleBetweenVectors::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnAngleBetweenVectors::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnAngleType _IAgCrdnAngleBetweenVectors::GetType ( ) {
    enum AgECrdnAngleType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAngleFindAngleResultPtr _IAgCrdnAngleBetweenVectors::FindAngle ( const _variant_t & Epoch ) {
    struct IAgCrdnAngleFindAngleResult * _result = 0;
    HRESULT _hr = raw_FindAngle(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindAngleResultPtr(_result, false);
}

IAgCrdnAngleFindAngleWithRateResultPtr _IAgCrdnAngleBetweenVectors::FindAngleWithRate ( const _variant_t & Epoch ) {
    struct IAgCrdnAngleFindAngleWithRateResult * _result = 0;
    HRESULT _hr = raw_FindAngleWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindAngleWithRateResultPtr(_result, false);
}

IAgCrdnAngleFindResultPtr _IAgCrdnAngleBetweenVectors::FindCoordinates ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAngleFindResult * _result = 0;
    HRESULT _hr = raw_FindCoordinates(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindResultPtr(_result, false);
}

IAgCrdnAngleFindWithRateResultPtr _IAgCrdnAngleBetweenVectors::FindCoordinatesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAngleFindWithRateResult * _result = 0;
    HRESULT _hr = raw_FindCoordinatesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindWithRateResultPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnAngleBetweenVectors::GetFromVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_FromVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnAngleBetweenVectors::GetToVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_ToVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnAngleBetweenVectors::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnAngleBetweenVectors::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnAngleBetweenVectors::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnAngleBetweenVectors::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnAngleBetweenVectors::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnAngleBetweenVectors::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnAngleBetweenPlanes wrapper method implementations
//

enum AgECrdnKind _IAgCrdnAngleBetweenPlanes::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnAngleBetweenPlanes::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAngleBetweenPlanes::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAngleBetweenPlanes::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAngleBetweenPlanes::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAngleBetweenPlanes::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAngleBetweenPlanes::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnAngleBetweenPlanes::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnAngleBetweenPlanes::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnAngleBetweenPlanes::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAngleBetweenPlanes::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAngleBetweenPlanes::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAngleBetweenPlanes::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnAngleBetweenPlanes::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnAngleType _IAgCrdnAngleBetweenPlanes::GetType ( ) {
    enum AgECrdnAngleType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAngleFindAngleResultPtr _IAgCrdnAngleBetweenPlanes::FindAngle ( const _variant_t & Epoch ) {
    struct IAgCrdnAngleFindAngleResult * _result = 0;
    HRESULT _hr = raw_FindAngle(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindAngleResultPtr(_result, false);
}

IAgCrdnAngleFindAngleWithRateResultPtr _IAgCrdnAngleBetweenPlanes::FindAngleWithRate ( const _variant_t & Epoch ) {
    struct IAgCrdnAngleFindAngleWithRateResult * _result = 0;
    HRESULT _hr = raw_FindAngleWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindAngleWithRateResultPtr(_result, false);
}

IAgCrdnAngleFindResultPtr _IAgCrdnAngleBetweenPlanes::FindCoordinates ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAngleFindResult * _result = 0;
    HRESULT _hr = raw_FindCoordinates(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindResultPtr(_result, false);
}

IAgCrdnAngleFindWithRateResultPtr _IAgCrdnAngleBetweenPlanes::FindCoordinatesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAngleFindWithRateResult * _result = 0;
    HRESULT _hr = raw_FindCoordinatesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindWithRateResultPtr(_result, false);
}

IAgCrdnPlaneRefToPtr _IAgCrdnAngleBetweenPlanes::GetFromPlane ( ) {
    struct IAgCrdnPlaneRefTo * _result = 0;
    HRESULT _hr = get_FromPlane(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneRefToPtr(_result, false);
}

IAgCrdnPlaneRefToPtr _IAgCrdnAngleBetweenPlanes::GetToPlane ( ) {
    struct IAgCrdnPlaneRefTo * _result = 0;
    HRESULT _hr = get_ToPlane(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneRefToPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnAngleBetweenPlanes::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnAngleBetweenPlanes::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnAngleBetweenPlanes::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnAngleBetweenPlanes::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnAngleBetweenPlanes::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnAngleBetweenPlanes::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnAngleDihedral wrapper method implementations
//

enum AgECrdnKind _IAgCrdnAngleDihedral::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnAngleDihedral::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAngleDihedral::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAngleDihedral::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAngleDihedral::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAngleDihedral::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAngleDihedral::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnAngleDihedral::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnAngleDihedral::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnAngleDihedral::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAngleDihedral::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAngleDihedral::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAngleDihedral::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnAngleDihedral::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnAngleType _IAgCrdnAngleDihedral::GetType ( ) {
    enum AgECrdnAngleType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAngleFindAngleResultPtr _IAgCrdnAngleDihedral::FindAngle ( const _variant_t & Epoch ) {
    struct IAgCrdnAngleFindAngleResult * _result = 0;
    HRESULT _hr = raw_FindAngle(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindAngleResultPtr(_result, false);
}

IAgCrdnAngleFindAngleWithRateResultPtr _IAgCrdnAngleDihedral::FindAngleWithRate ( const _variant_t & Epoch ) {
    struct IAgCrdnAngleFindAngleWithRateResult * _result = 0;
    HRESULT _hr = raw_FindAngleWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindAngleWithRateResultPtr(_result, false);
}

IAgCrdnAngleFindResultPtr _IAgCrdnAngleDihedral::FindCoordinates ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAngleFindResult * _result = 0;
    HRESULT _hr = raw_FindCoordinates(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindResultPtr(_result, false);
}

IAgCrdnAngleFindWithRateResultPtr _IAgCrdnAngleDihedral::FindCoordinatesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAngleFindWithRateResult * _result = 0;
    HRESULT _hr = raw_FindCoordinatesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindWithRateResultPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnAngleDihedral::GetFromVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_FromVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnAngleDihedral::GetToVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_ToVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnAngleDihedral::GetPoleAbout ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_PoleAbout(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnAngleDihedral::GetCounterClockwiseRotation ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CounterClockwiseRotation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnAngleDihedral::PutCounterClockwiseRotation ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_CounterClockwiseRotation(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnAngleDihedral::GetSignedAngle ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_SignedAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnAngleDihedral::PutSignedAngle ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_SignedAngle(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPtr _IAgCrdnAngleDihedral::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnAngleDihedral::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnAngleDihedral::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnAngleDihedral::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnAngleDihedral::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnAngleDihedral::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnAngleRotation wrapper method implementations
//

enum AgECrdnKind _IAgCrdnAngleRotation::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnAngleRotation::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAngleRotation::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAngleRotation::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAngleRotation::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAngleRotation::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAngleRotation::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnAngleRotation::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnAngleRotation::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnAngleRotation::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAngleRotation::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAngleRotation::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAngleRotation::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnAngleRotation::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnAngleType _IAgCrdnAngleRotation::GetType ( ) {
    enum AgECrdnAngleType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAngleFindAngleResultPtr _IAgCrdnAngleRotation::FindAngle ( const _variant_t & Epoch ) {
    struct IAgCrdnAngleFindAngleResult * _result = 0;
    HRESULT _hr = raw_FindAngle(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindAngleResultPtr(_result, false);
}

IAgCrdnAngleFindAngleWithRateResultPtr _IAgCrdnAngleRotation::FindAngleWithRate ( const _variant_t & Epoch ) {
    struct IAgCrdnAngleFindAngleWithRateResult * _result = 0;
    HRESULT _hr = raw_FindAngleWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindAngleWithRateResultPtr(_result, false);
}

IAgCrdnAngleFindResultPtr _IAgCrdnAngleRotation::FindCoordinates ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAngleFindResult * _result = 0;
    HRESULT _hr = raw_FindCoordinates(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindResultPtr(_result, false);
}

IAgCrdnAngleFindWithRateResultPtr _IAgCrdnAngleRotation::FindCoordinatesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAngleFindWithRateResult * _result = 0;
    HRESULT _hr = raw_FindCoordinatesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindWithRateResultPtr(_result, false);
}

IAgCrdnAxesRefToPtr _IAgCrdnAngleRotation::GetFromAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_FromAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

IAgCrdnAxesRefToPtr _IAgCrdnAngleRotation::GetToAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ToAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

enum AgECrdnDisplayAxisSelector _IAgCrdnAngleRotation::GetReferenceDirection ( ) {
    enum AgECrdnDisplayAxisSelector _result;
    HRESULT _hr = get_ReferenceDirection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnAngleRotation::PutReferenceDirection ( enum AgECrdnDisplayAxisSelector pRetVal ) {
    HRESULT _hr = put_ReferenceDirection(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPtr _IAgCrdnAngleRotation::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnAngleRotation::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnAngleRotation::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnAngleRotation::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnAngleRotation::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnAngleRotation::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnAngleToPlane wrapper method implementations
//

enum AgECrdnKind _IAgCrdnAngleToPlane::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnAngleToPlane::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnAngleToPlane::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnAngleToPlane::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAngleToPlane::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnAngleToPlane::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAngleToPlane::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnAngleToPlane::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnAngleToPlane::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnAngleToPlane::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnAngleToPlane::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAngleToPlane::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnAngleToPlane::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnAngleToPlane::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnAngleType _IAgCrdnAngleToPlane::GetType ( ) {
    enum AgECrdnAngleType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnAngleFindAngleResultPtr _IAgCrdnAngleToPlane::FindAngle ( const _variant_t & Epoch ) {
    struct IAgCrdnAngleFindAngleResult * _result = 0;
    HRESULT _hr = raw_FindAngle(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindAngleResultPtr(_result, false);
}

IAgCrdnAngleFindAngleWithRateResultPtr _IAgCrdnAngleToPlane::FindAngleWithRate ( const _variant_t & Epoch ) {
    struct IAgCrdnAngleFindAngleWithRateResult * _result = 0;
    HRESULT _hr = raw_FindAngleWithRate(Epoch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindAngleWithRateResultPtr(_result, false);
}

IAgCrdnAngleFindResultPtr _IAgCrdnAngleToPlane::FindCoordinates ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAngleFindResult * _result = 0;
    HRESULT _hr = raw_FindCoordinates(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindResultPtr(_result, false);
}

IAgCrdnAngleFindWithRateResultPtr _IAgCrdnAngleToPlane::FindCoordinatesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnAngleFindWithRateResult * _result = 0;
    HRESULT _hr = raw_FindCoordinatesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleFindWithRateResultPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnAngleToPlane::GetReferenceVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_ReferenceVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnPlaneRefToPtr _IAgCrdnAngleToPlane::GetReferencePlane ( ) {
    struct IAgCrdnPlaneRefTo * _result = 0;
    HRESULT _hr = get_ReferencePlane(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneRefToPtr(_result, false);
}

enum AgECrdnSignedAngleType _IAgCrdnAngleToPlane::GetSigned ( ) {
    enum AgECrdnSignedAngleType _result;
    HRESULT _hr = get_Signed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnAngleToPlane::PutSigned ( enum AgECrdnSignedAngleType pRetVal ) {
    HRESULT _hr = put_Signed(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPtr _IAgCrdnAngleToPlane::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnAngleToPlane::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnAngleToPlane::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnAngleToPlane::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnAngleToPlane::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnAngleToPlane::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnPlaneNormal wrapper method implementations
//

enum AgECrdnKind _IAgCrdnPlaneNormal::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnPlaneNormal::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPlaneNormal::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnPlaneNormal::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPlaneNormal::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPlaneNormal::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPlaneNormal::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnPlaneNormal::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnPlaneNormal::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnPlaneNormal::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPlaneNormal::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPlaneNormal::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPlaneNormal::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnPlaneNormal::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnPlaneType _IAgCrdnPlaneNormal::GetType ( ) {
    enum AgECrdnPlaneType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPlaneFindInAxesResultPtr _IAgCrdnPlaneNormal::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnPlaneFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInAxesResultPtr(_result, false);
}

IAgCrdnPlaneFindInAxesWithRateResultPtr _IAgCrdnPlaneNormal::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnPlaneFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnPlaneFindInSystemResultPtr _IAgCrdnPlaneNormal::FindInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPlaneFindInSystemResult * _result = 0;
    HRESULT _hr = raw_FindInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInSystemResultPtr(_result, false);
}

IAgCrdnPlaneFindInSystemWithRateResultPtr _IAgCrdnPlaneNormal::FindInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPlaneFindInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPlaneLabelsPtr _IAgCrdnPlaneNormal::GetLabels ( ) {
    struct IAgCrdnPlaneLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneLabelsPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnPlaneNormal::GetNormalVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_NormalVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnPlaneNormal::GetReferenceVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_ReferenceVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnPlaneNormal::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnPlaneNormal::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnPlaneNormal::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnPlaneNormal::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnPlaneNormal::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnPlaneNormal::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnPlaneNormal::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnPlaneQuadrant wrapper method implementations
//

enum AgECrdnKind _IAgCrdnPlaneQuadrant::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnPlaneQuadrant::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPlaneQuadrant::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnPlaneQuadrant::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPlaneQuadrant::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPlaneQuadrant::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPlaneQuadrant::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnPlaneQuadrant::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnPlaneQuadrant::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnPlaneQuadrant::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPlaneQuadrant::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPlaneQuadrant::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPlaneQuadrant::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnPlaneQuadrant::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnPlaneType _IAgCrdnPlaneQuadrant::GetType ( ) {
    enum AgECrdnPlaneType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPlaneFindInAxesResultPtr _IAgCrdnPlaneQuadrant::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnPlaneFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInAxesResultPtr(_result, false);
}

IAgCrdnPlaneFindInAxesWithRateResultPtr _IAgCrdnPlaneQuadrant::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnPlaneFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnPlaneFindInSystemResultPtr _IAgCrdnPlaneQuadrant::FindInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPlaneFindInSystemResult * _result = 0;
    HRESULT _hr = raw_FindInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInSystemResultPtr(_result, false);
}

IAgCrdnPlaneFindInSystemWithRateResultPtr _IAgCrdnPlaneQuadrant::FindInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPlaneFindInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPlaneLabelsPtr _IAgCrdnPlaneQuadrant::GetLabels ( ) {
    struct IAgCrdnPlaneLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneLabelsPtr(_result, false);
}

IAgCrdnSystemRefToPtr _IAgCrdnPlaneQuadrant::GetReferenceSystem ( ) {
    struct IAgCrdnSystemRefTo * _result = 0;
    HRESULT _hr = get_ReferenceSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemRefToPtr(_result, false);
}

enum AgECrdnQuadrantType _IAgCrdnPlaneQuadrant::GetQuadrant ( ) {
    enum AgECrdnQuadrantType _result;
    HRESULT _hr = get_Quadrant(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnPlaneQuadrant::PutQuadrant ( enum AgECrdnQuadrantType pRetVal ) {
    HRESULT _hr = put_Quadrant(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPtr _IAgCrdnPlaneQuadrant::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnPlaneQuadrant::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnPlaneQuadrant::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnPlaneQuadrant::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnPlaneQuadrant::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnPlaneQuadrant::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnPlaneTrajectory wrapper method implementations
//

enum AgECrdnKind _IAgCrdnPlaneTrajectory::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnPlaneTrajectory::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPlaneTrajectory::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnPlaneTrajectory::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPlaneTrajectory::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPlaneTrajectory::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPlaneTrajectory::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnPlaneTrajectory::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnPlaneTrajectory::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnPlaneTrajectory::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPlaneTrajectory::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPlaneTrajectory::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPlaneTrajectory::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnPlaneTrajectory::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnPlaneType _IAgCrdnPlaneTrajectory::GetType ( ) {
    enum AgECrdnPlaneType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPlaneFindInAxesResultPtr _IAgCrdnPlaneTrajectory::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnPlaneFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInAxesResultPtr(_result, false);
}

IAgCrdnPlaneFindInAxesWithRateResultPtr _IAgCrdnPlaneTrajectory::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnPlaneFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnPlaneFindInSystemResultPtr _IAgCrdnPlaneTrajectory::FindInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPlaneFindInSystemResult * _result = 0;
    HRESULT _hr = raw_FindInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInSystemResultPtr(_result, false);
}

IAgCrdnPlaneFindInSystemWithRateResultPtr _IAgCrdnPlaneTrajectory::FindInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPlaneFindInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPlaneLabelsPtr _IAgCrdnPlaneTrajectory::GetLabels ( ) {
    struct IAgCrdnPlaneLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneLabelsPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnPlaneTrajectory::GetPoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_Point(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnSystemRefToPtr _IAgCrdnPlaneTrajectory::GetReferenceSystem ( ) {
    struct IAgCrdnSystemRefTo * _result = 0;
    HRESULT _hr = get_ReferenceSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemRefToPtr(_result, false);
}

double _IAgCrdnPlaneTrajectory::GetRotationOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_RotationOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnPlaneTrajectory::PutRotationOffset ( double pRetVal ) {
    HRESULT _hr = put_RotationOffset(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPtr _IAgCrdnPlaneTrajectory::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnPlaneTrajectory::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnPlaneTrajectory::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnPlaneTrajectory::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnPlaneTrajectory::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnPlaneTrajectory::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnPlaneTriad wrapper method implementations
//

enum AgECrdnKind _IAgCrdnPlaneTriad::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnPlaneTriad::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPlaneTriad::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnPlaneTriad::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPlaneTriad::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPlaneTriad::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPlaneTriad::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnPlaneTriad::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnPlaneTriad::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnPlaneTriad::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPlaneTriad::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPlaneTriad::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPlaneTriad::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnPlaneTriad::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnPlaneType _IAgCrdnPlaneTriad::GetType ( ) {
    enum AgECrdnPlaneType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPlaneFindInAxesResultPtr _IAgCrdnPlaneTriad::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnPlaneFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInAxesResultPtr(_result, false);
}

IAgCrdnPlaneFindInAxesWithRateResultPtr _IAgCrdnPlaneTriad::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnPlaneFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnPlaneFindInSystemResultPtr _IAgCrdnPlaneTriad::FindInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPlaneFindInSystemResult * _result = 0;
    HRESULT _hr = raw_FindInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInSystemResultPtr(_result, false);
}

IAgCrdnPlaneFindInSystemWithRateResultPtr _IAgCrdnPlaneTriad::FindInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPlaneFindInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneFindInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPlaneLabelsPtr _IAgCrdnPlaneTriad::GetLabels ( ) {
    struct IAgCrdnPlaneLabels * _result = 0;
    HRESULT _hr = get_Labels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneLabelsPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnPlaneTriad::GetPointA ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_PointA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnPlaneTriad::GetPointB ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_PointB(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnPlaneTriad::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

double _IAgCrdnPlaneTriad::GetRotationOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_RotationOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnPlaneTriad::PutRotationOffset ( double pRetVal ) {
    HRESULT _hr = put_RotationOffset(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPtr _IAgCrdnPlaneTriad::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnPlaneTriad::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnPlaneTriad::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnPlaneTriad::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnPlaneTriad::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnPlaneTriad::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnPointBPlane wrapper method implementations
//

enum AgECrdnKind _IAgCrdnPointBPlane::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnPointBPlane::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPointBPlane::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnPointBPlane::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointBPlane::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointBPlane::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointBPlane::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnPointBPlane::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnPointBPlane::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnPointBPlane::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointBPlane::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointBPlane::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointBPlane::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnPointBPlane::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnPointType _IAgCrdnPointBPlane::GetType ( ) {
    enum AgECrdnPointType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointLocateInSystemWithRateResultPtr _IAgCrdnPointBPlane::LocateInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_LocateInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPointLocateInSystemResultPtr _IAgCrdnPointBPlane::LocateInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemResult * _result = 0;
    HRESULT _hr = raw_LocateInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemResultPtr(_result, false);
}

IAgCrdnCentralBodyRefToPtr _IAgCrdnPointBPlane::GetTargetBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_TargetBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnPointBPlane::GetTrajectory ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_Trajectory(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

enum AgECrdnPointBPlaneType _IAgCrdnPointBPlane::GetPointType ( ) {
    enum AgECrdnPointBPlaneType _result;
    HRESULT _hr = get_PointType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnPointBPlane::PutPointType ( enum AgECrdnPointBPlaneType pRetVal ) {
    HRESULT _hr = put_PointType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnDirectionType _IAgCrdnPointBPlane::GetDirection ( ) {
    enum AgECrdnDirectionType _result;
    HRESULT _hr = get_Direction(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnPointBPlane::PutDirection ( enum AgECrdnDirectionType pRetVal ) {
    HRESULT _hr = put_Direction(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPtr _IAgCrdnPointBPlane::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnPointBPlane::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnPointBPlane::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnPointBPlane::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnPointBPlane::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnPointBPlane::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnPointFile wrapper method implementations
//

enum AgECrdnKind _IAgCrdnPointFile::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnPointFile::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPointFile::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnPointFile::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointFile::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointFile::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointFile::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnPointFile::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnPointFile::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnPointFile::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointFile::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointFile::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointFile::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnPointFile::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnPointType _IAgCrdnPointFile::GetType ( ) {
    enum AgECrdnPointType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointLocateInSystemWithRateResultPtr _IAgCrdnPointFile::LocateInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_LocateInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPointLocateInSystemResultPtr _IAgCrdnPointFile::LocateInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemResult * _result = 0;
    HRESULT _hr = raw_LocateInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemResultPtr(_result, false);
}

_bstr_t _IAgCrdnPointFile::GetFilename ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Filename(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPointFile::PutFilename ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Filename(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPtr _IAgCrdnPointFile::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnPointFile::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnPointFile::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnPointFile::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnPointFile::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnPointFile::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnPointFixedInSystem wrapper method implementations
//

enum AgECrdnKind _IAgCrdnPointFixedInSystem::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnPointFixedInSystem::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPointFixedInSystem::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnPointFixedInSystem::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointFixedInSystem::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointFixedInSystem::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointFixedInSystem::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnPointFixedInSystem::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnPointFixedInSystem::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnPointFixedInSystem::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointFixedInSystem::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointFixedInSystem::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointFixedInSystem::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnPointFixedInSystem::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnPointType _IAgCrdnPointFixedInSystem::GetType ( ) {
    enum AgECrdnPointType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointLocateInSystemWithRateResultPtr _IAgCrdnPointFixedInSystem::LocateInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_LocateInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPointLocateInSystemResultPtr _IAgCrdnPointFixedInSystem::LocateInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemResult * _result = 0;
    HRESULT _hr = raw_LocateInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemResultPtr(_result, false);
}

IAgCrdnSystemRefToPtr _IAgCrdnPointFixedInSystem::GetReference ( ) {
    struct IAgCrdnSystemRefTo * _result = 0;
    HRESULT _hr = get_Reference(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemRefToPtr(_result, false);
}

STKUtil::IAgPositionPtr _IAgCrdnPointFixedInSystem::GetFixedPoint ( ) {
    struct STKUtil::IAgPosition * _result = 0;
    HRESULT _hr = get_FixedPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgPositionPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnPointFixedInSystem::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnPointFixedInSystem::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnPointFixedInSystem::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnPointFixedInSystem::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnPointFixedInSystem::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnPointFixedInSystem::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnPointGrazing wrapper method implementations
//

enum AgECrdnKind _IAgCrdnPointGrazing::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnPointGrazing::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPointGrazing::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnPointGrazing::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointGrazing::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointGrazing::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointGrazing::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnPointGrazing::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnPointGrazing::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnPointGrazing::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointGrazing::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointGrazing::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointGrazing::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnPointGrazing::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnPointType _IAgCrdnPointGrazing::GetType ( ) {
    enum AgECrdnPointType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointLocateInSystemWithRateResultPtr _IAgCrdnPointGrazing::LocateInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_LocateInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPointLocateInSystemResultPtr _IAgCrdnPointGrazing::LocateInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemResult * _result = 0;
    HRESULT _hr = raw_LocateInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemResultPtr(_result, false);
}

IAgCrdnCentralBodyRefToPtr _IAgCrdnPointGrazing::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnPointGrazing::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnPointGrazing::GetDirectionVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_DirectionVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

double _IAgCrdnPointGrazing::GetAltitude ( ) {
    double _result = 0;
    HRESULT _hr = get_Altitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnPointGrazing::PutAltitude ( double pRetVal ) {
    HRESULT _hr = put_Altitude(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPtr _IAgCrdnPointGrazing::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnPointGrazing::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnPointGrazing::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnPointGrazing::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnPointGrazing::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnPointGrazing::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnPointGlint wrapper method implementations
//

enum AgECrdnKind _IAgCrdnPointGlint::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnPointGlint::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPointGlint::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnPointGlint::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointGlint::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointGlint::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointGlint::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnPointGlint::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnPointGlint::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnPointGlint::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointGlint::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointGlint::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointGlint::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnPointGlint::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnPointType _IAgCrdnPointGlint::GetType ( ) {
    enum AgECrdnPointType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointLocateInSystemWithRateResultPtr _IAgCrdnPointGlint::LocateInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_LocateInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPointLocateInSystemResultPtr _IAgCrdnPointGlint::LocateInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemResult * _result = 0;
    HRESULT _hr = raw_LocateInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemResultPtr(_result, false);
}

IAgCrdnCentralBodyRefToPtr _IAgCrdnPointGlint::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnPointGlint::GetSourcePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_SourcePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnPointGlint::GetObserverPoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ObserverPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnPointGlint::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnPointGlint::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnPointGlint::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnPointGlint::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnPointGlint::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnPointGlint::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnPointCovarianceGrazing wrapper method implementations
//

enum AgECrdnKind _IAgCrdnPointCovarianceGrazing::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnPointCovarianceGrazing::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPointCovarianceGrazing::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnPointCovarianceGrazing::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointCovarianceGrazing::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointCovarianceGrazing::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointCovarianceGrazing::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnPointCovarianceGrazing::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnPointCovarianceGrazing::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnPointCovarianceGrazing::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointCovarianceGrazing::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointCovarianceGrazing::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointCovarianceGrazing::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnPointCovarianceGrazing::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnPointType _IAgCrdnPointCovarianceGrazing::GetType ( ) {
    enum AgECrdnPointType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointLocateInSystemWithRateResultPtr _IAgCrdnPointCovarianceGrazing::LocateInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_LocateInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPointLocateInSystemResultPtr _IAgCrdnPointCovarianceGrazing::LocateInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemResult * _result = 0;
    HRESULT _hr = raw_LocateInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemResultPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnPointCovarianceGrazing::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnPointCovarianceGrazing::GetDirectionVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_DirectionVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

_bstr_t _IAgCrdnPointCovarianceGrazing::GetTargetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_TargetName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPointCovarianceGrazing::PutTargetName ( _bstr_t pRetVal ) {
    HRESULT _hr = put_TargetName(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnPointCovarianceGrazing::GetDistance ( ) {
    double _result = 0;
    HRESULT _hr = get_Distance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnPointCovarianceGrazing::PutDistance ( double pRetVal ) {
    HRESULT _hr = put_Distance(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnPointCovarianceGrazing::GetProbability ( ) {
    double _result = 0;
    HRESULT _hr = get_Probability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnPointCovarianceGrazing::PutProbability ( double pRetVal ) {
    HRESULT _hr = put_Probability(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnPointCovarianceGrazing::GetScale ( ) {
    double _result = 0;
    HRESULT _hr = get_Scale(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnPointCovarianceGrazing::PutScale ( double pRetVal ) {
    HRESULT _hr = put_Scale(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnPointCovarianceGrazing::GetUseProbability ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseProbability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnPointCovarianceGrazing::PutUseProbability ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseProbability(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPtr _IAgCrdnPointCovarianceGrazing::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnPointCovarianceGrazing::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnPointCovarianceGrazing::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnPointCovarianceGrazing::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnPointCovarianceGrazing::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnPointCovarianceGrazing::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnPointPlaneIntersection wrapper method implementations
//

enum AgECrdnKind _IAgCrdnPointPlaneIntersection::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnPointPlaneIntersection::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPointPlaneIntersection::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnPointPlaneIntersection::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointPlaneIntersection::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointPlaneIntersection::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointPlaneIntersection::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnPointPlaneIntersection::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnPointPlaneIntersection::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnPointPlaneIntersection::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointPlaneIntersection::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointPlaneIntersection::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointPlaneIntersection::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnPointPlaneIntersection::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnPointType _IAgCrdnPointPlaneIntersection::GetType ( ) {
    enum AgECrdnPointType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointLocateInSystemWithRateResultPtr _IAgCrdnPointPlaneIntersection::LocateInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_LocateInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPointLocateInSystemResultPtr _IAgCrdnPointPlaneIntersection::LocateInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemResult * _result = 0;
    HRESULT _hr = raw_LocateInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemResultPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnPointPlaneIntersection::GetDirectionVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_DirectionVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnPlaneRefToPtr _IAgCrdnPointPlaneIntersection::GetReferencePlane ( ) {
    struct IAgCrdnPlaneRefTo * _result = 0;
    HRESULT _hr = get_ReferencePlane(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnPointPlaneIntersection::GetOriginPoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_OriginPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnPointPlaneIntersection::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnPointPlaneIntersection::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnPointPlaneIntersection::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnPointPlaneIntersection::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnPointPlaneIntersection::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnPointPlaneIntersection::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnPointOnSurface wrapper method implementations
//

enum AgECrdnKind _IAgCrdnPointOnSurface::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnPointOnSurface::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPointOnSurface::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnPointOnSurface::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointOnSurface::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointOnSurface::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointOnSurface::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnPointOnSurface::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnPointOnSurface::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnPointOnSurface::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointOnSurface::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointOnSurface::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointOnSurface::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnPointOnSurface::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnPointType _IAgCrdnPointOnSurface::GetType ( ) {
    enum AgECrdnPointType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointLocateInSystemWithRateResultPtr _IAgCrdnPointOnSurface::LocateInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_LocateInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPointLocateInSystemResultPtr _IAgCrdnPointOnSurface::LocateInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemResult * _result = 0;
    HRESULT _hr = raw_LocateInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemResultPtr(_result, false);
}

IAgCrdnCentralBodyRefToPtr _IAgCrdnPointOnSurface::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnPointOnSurface::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

enum AgECrdnReferenceShapeType _IAgCrdnPointOnSurface::GetReferenceShape ( ) {
    enum AgECrdnReferenceShapeType _result;
    HRESULT _hr = get_ReferenceShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnPointOnSurface::PutReferenceShape ( enum AgECrdnReferenceShapeType pRetVal ) {
    HRESULT _hr = put_ReferenceShape(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSurfaceType _IAgCrdnPointOnSurface::GetSurfaceType ( ) {
    enum AgECrdnSurfaceType _result;
    HRESULT _hr = get_SurfaceType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnPointOnSurface::PutSurfaceType ( enum AgECrdnSurfaceType pRetVal ) {
    HRESULT _hr = put_SurfaceType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPtr _IAgCrdnPointOnSurface::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnPointOnSurface::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnPointOnSurface::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnPointOnSurface::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnPointOnSurface::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnPointOnSurface::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnPointModelAttach wrapper method implementations
//

enum AgECrdnKind _IAgCrdnPointModelAttach::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnPointModelAttach::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPointModelAttach::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnPointModelAttach::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointModelAttach::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointModelAttach::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointModelAttach::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnPointModelAttach::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnPointModelAttach::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnPointModelAttach::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointModelAttach::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointModelAttach::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointModelAttach::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnPointModelAttach::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnPointType _IAgCrdnPointModelAttach::GetType ( ) {
    enum AgECrdnPointType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointLocateInSystemWithRateResultPtr _IAgCrdnPointModelAttach::LocateInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_LocateInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPointLocateInSystemResultPtr _IAgCrdnPointModelAttach::LocateInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemResult * _result = 0;
    HRESULT _hr = raw_LocateInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemResultPtr(_result, false);
}

_bstr_t _IAgCrdnPointModelAttach::GetPointableElementName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_PointableElementName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPointModelAttach::PutPointableElementName ( _bstr_t pRetVal ) {
    HRESULT _hr = put_PointableElementName(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnPointModelAttach::GetUseScale ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseScale(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnPointModelAttach::PutUseScale ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseScale(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPtr _IAgCrdnPointModelAttach::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnPointModelAttach::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnPointModelAttach::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnPointModelAttach::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnPointModelAttach::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnPointModelAttach::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnPointPlaneProjection wrapper method implementations
//

enum AgECrdnKind _IAgCrdnPointPlaneProjection::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnPointPlaneProjection::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPointPlaneProjection::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnPointPlaneProjection::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointPlaneProjection::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointPlaneProjection::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointPlaneProjection::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnPointPlaneProjection::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnPointPlaneProjection::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnPointPlaneProjection::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointPlaneProjection::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointPlaneProjection::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointPlaneProjection::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnPointPlaneProjection::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnPointType _IAgCrdnPointPlaneProjection::GetType ( ) {
    enum AgECrdnPointType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointLocateInSystemWithRateResultPtr _IAgCrdnPointPlaneProjection::LocateInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_LocateInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPointLocateInSystemResultPtr _IAgCrdnPointPlaneProjection::LocateInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemResult * _result = 0;
    HRESULT _hr = raw_LocateInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemResultPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnPointPlaneProjection::GetSourcePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_SourcePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnPlaneRefToPtr _IAgCrdnPointPlaneProjection::GetReferencePlane ( ) {
    struct IAgCrdnPlaneRefTo * _result = 0;
    HRESULT _hr = get_ReferencePlane(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneRefToPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnPointPlaneProjection::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnPointPlaneProjection::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnPointPlaneProjection::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnPointPlaneProjection::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnPointPlaneProjection::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnPointPlaneProjection::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnPointLagrangeLibration wrapper method implementations
//

enum AgECrdnKind _IAgCrdnPointLagrangeLibration::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnPointLagrangeLibration::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPointLagrangeLibration::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnPointLagrangeLibration::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointLagrangeLibration::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointLagrangeLibration::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointLagrangeLibration::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnPointLagrangeLibration::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnPointLagrangeLibration::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnPointLagrangeLibration::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointLagrangeLibration::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointLagrangeLibration::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointLagrangeLibration::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnPointLagrangeLibration::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnPointType _IAgCrdnPointLagrangeLibration::GetType ( ) {
    enum AgECrdnPointType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointLocateInSystemWithRateResultPtr _IAgCrdnPointLagrangeLibration::LocateInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_LocateInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPointLocateInSystemResultPtr _IAgCrdnPointLagrangeLibration::LocateInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemResult * _result = 0;
    HRESULT _hr = raw_LocateInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemResultPtr(_result, false);
}

IAgCrdnCentralBodyRefToPtr _IAgCrdnPointLagrangeLibration::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

enum AgECrdnLagrangeLibrationPointType _IAgCrdnPointLagrangeLibration::GetPointType ( ) {
    enum AgECrdnLagrangeLibrationPointType _result;
    HRESULT _hr = get_PointType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnPointLagrangeLibration::PutPointType ( enum AgECrdnLagrangeLibrationPointType pRetVal ) {
    HRESULT _hr = put_PointType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnCentralBodyCollectionPtr _IAgCrdnPointLagrangeLibration::GetSecondaryCentralBodies ( ) {
    struct IAgCrdnCentralBodyCollection * _result = 0;
    HRESULT _hr = get_SecondaryCentralBodies(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyCollectionPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnPointLagrangeLibration::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnPointLagrangeLibration::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnPointLagrangeLibration::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnPointLagrangeLibration::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnPointLagrangeLibration::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnPointLagrangeLibration::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnPointCentBodyIntersect wrapper method implementations
//

enum AgECrdnKind _IAgCrdnPointCentBodyIntersect::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnPointCentBodyIntersect::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPointCentBodyIntersect::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnPointCentBodyIntersect::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointCentBodyIntersect::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointCentBodyIntersect::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointCentBodyIntersect::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnPointCentBodyIntersect::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnPointCentBodyIntersect::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnPointCentBodyIntersect::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointCentBodyIntersect::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointCentBodyIntersect::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointCentBodyIntersect::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnPointCentBodyIntersect::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnPointType _IAgCrdnPointCentBodyIntersect::GetType ( ) {
    enum AgECrdnPointType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointLocateInSystemWithRateResultPtr _IAgCrdnPointCentBodyIntersect::LocateInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_LocateInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPointLocateInSystemResultPtr _IAgCrdnPointCentBodyIntersect::LocateInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemResult * _result = 0;
    HRESULT _hr = raw_LocateInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemResultPtr(_result, false);
}

_bstr_t _IAgCrdnPointCentBodyIntersect::GetCentralBody ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPointCentBodyIntersect::PutCentralBody ( _bstr_t pRetVal ) {
    HRESULT _hr = put_CentralBody(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPointPtr _IAgCrdnPointCentBodyIntersect::GetReferencePoint ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

void _IAgCrdnPointCentBodyIntersect::PutReferencePoint ( struct IAgCrdnPoint * ppRetVal ) {
    HRESULT _hr = put_ReferencePoint(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnVectorPtr _IAgCrdnPointCentBodyIntersect::GetDirectionVector ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_DirectionVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

void _IAgCrdnPointCentBodyIntersect::PutDirectionVector ( struct IAgCrdnVector * ppRetVal ) {
    HRESULT _hr = put_DirectionVector(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnIntersectionSurface _IAgCrdnPointCentBodyIntersect::GetIntersectionSurface ( ) {
    enum AgECrdnIntersectionSurface _result;
    HRESULT _hr = get_IntersectionSurface(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnPointCentBodyIntersect::PutIntersectionSurface ( enum AgECrdnIntersectionSurface pRetVal ) {
    HRESULT _hr = put_IntersectionSurface(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnPointCentBodyIntersect::GetAltitude ( ) {
    double _result = 0;
    HRESULT _hr = get_Altitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnPointCentBodyIntersect::PutAltitude ( double pRetVal ) {
    HRESULT _hr = put_Altitude(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnPointCentBodyIntersect::GetUseRangeConstraint ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseRangeConstraint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnPointCentBodyIntersect::PutUseRangeConstraint ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseRangeConstraint(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnPointCentBodyIntersect::GetMinimumRange ( ) {
    double _result = 0;
    HRESULT _hr = get_MinimumRange(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnPointCentBodyIntersect::PutMinimumRange ( double pRetVal ) {
    HRESULT _hr = put_MinimumRange(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnPointCentBodyIntersect::GetMaximumRange ( ) {
    double _result = 0;
    HRESULT _hr = get_MaximumRange(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnPointCentBodyIntersect::PutMaximumRange ( double pRetVal ) {
    HRESULT _hr = put_MaximumRange(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnPointCentBodyIntersect::GetUseMinimumRange ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseMinimumRange(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnPointCentBodyIntersect::PutUseMinimumRange ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseMinimumRange(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnPointCentBodyIntersect::GetUseMaximumRange ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseMaximumRange(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnPointCentBodyIntersect::PutUseMaximumRange ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseMaximumRange(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgCrdnPointCentBodyIntersect::SetRange ( double Minimum, double Maximum ) {
    HRESULT _hr = raw_SetRange(Minimum, Maximum);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

IAgCrdnPtr _IAgCrdnPointCentBodyIntersect::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnPointCentBodyIntersect::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnPointCentBodyIntersect::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnPointCentBodyIntersect::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnPointCentBodyIntersect::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnPointCentBodyIntersect::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnPointAtTimeInstant wrapper method implementations
//

enum AgECrdnKind _IAgCrdnPointAtTimeInstant::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnPointAtTimeInstant::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPointAtTimeInstant::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnPointAtTimeInstant::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointAtTimeInstant::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointAtTimeInstant::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointAtTimeInstant::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnPointAtTimeInstant::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnPointAtTimeInstant::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnPointAtTimeInstant::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointAtTimeInstant::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointAtTimeInstant::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointAtTimeInstant::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnPointAtTimeInstant::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnPointType _IAgCrdnPointAtTimeInstant::GetType ( ) {
    enum AgECrdnPointType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointLocateInSystemWithRateResultPtr _IAgCrdnPointAtTimeInstant::LocateInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_LocateInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPointLocateInSystemResultPtr _IAgCrdnPointAtTimeInstant::LocateInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemResult * _result = 0;
    HRESULT _hr = raw_LocateInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemResultPtr(_result, false);
}

IAgCrdnEventPtr _IAgCrdnPointAtTimeInstant::GetReferenceTimeInstant ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_ReferenceTimeInstant(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

void _IAgCrdnPointAtTimeInstant::PutReferenceTimeInstant ( struct IAgCrdnEvent * ppRetVal ) {
    HRESULT _hr = put_ReferenceTimeInstant(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPointPtr _IAgCrdnPointAtTimeInstant::GetSourcePoint ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = get_SourcePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

void _IAgCrdnPointAtTimeInstant::PutSourcePoint ( struct IAgCrdnPoint * ppRetVal ) {
    HRESULT _hr = put_SourcePoint(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSystemPtr _IAgCrdnPointAtTimeInstant::GetReferenceSystem ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_ReferenceSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

void _IAgCrdnPointAtTimeInstant::PutReferenceSystem ( struct IAgCrdnSystem * ppRetVal ) {
    HRESULT _hr = put_ReferenceSystem(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPtr _IAgCrdnPointAtTimeInstant::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnPointAtTimeInstant::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnPointAtTimeInstant::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnPointAtTimeInstant::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnPointAtTimeInstant::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnPointAtTimeInstant::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnPointPlugin wrapper method implementations
//

enum AgECrdnKind _IAgCrdnPointPlugin::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnPointPlugin::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPointPlugin::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnPointPlugin::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointPlugin::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointPlugin::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointPlugin::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnPointPlugin::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnPointPlugin::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnPointPlugin::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointPlugin::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointPlugin::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointPlugin::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnPointPlugin::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnPointType _IAgCrdnPointPlugin::GetType ( ) {
    enum AgECrdnPointType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointLocateInSystemWithRateResultPtr _IAgCrdnPointPlugin::LocateInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_LocateInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPointLocateInSystemResultPtr _IAgCrdnPointPlugin::LocateInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemResult * _result = 0;
    HRESULT _hr = raw_LocateInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemResultPtr(_result, false);
}

_bstr_t _IAgCrdnPointPlugin::GetProgID ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ProgID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointPlugin::GetDisplayName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DisplayName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

SAFEARRAY * _IAgCrdnPointPlugin::GetAvailableProperties ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_AvailableProperties(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgCrdnPointPlugin::Reset ( ) {
    HRESULT _hr = raw_Reset();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnPointPlugin::SetProperty ( _bstr_t Name, _bstr_t Value ) {
    HRESULT _hr = raw_SetProperty(Name, Value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t _IAgCrdnPointPlugin::GetProperty ( _bstr_t Name ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetProperty(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

IAgCrdnPtr _IAgCrdnPointPlugin::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnPointPlugin::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnPointPlugin::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnPointPlugin::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnPointPlugin::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnPointPlugin::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnPointCBFixedOffset wrapper method implementations
//

enum AgECrdnKind _IAgCrdnPointCBFixedOffset::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnPointCBFixedOffset::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPointCBFixedOffset::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnPointCBFixedOffset::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointCBFixedOffset::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnPointCBFixedOffset::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointCBFixedOffset::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnPointCBFixedOffset::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnPointCBFixedOffset::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnPointCBFixedOffset::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnPointCBFixedOffset::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointCBFixedOffset::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnPointCBFixedOffset::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnPointCBFixedOffset::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnPointType _IAgCrdnPointCBFixedOffset::GetType ( ) {
    enum AgECrdnPointType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnPointLocateInSystemWithRateResultPtr _IAgCrdnPointCBFixedOffset::LocateInSystemWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemWithRateResult * _result = 0;
    HRESULT _hr = raw_LocateInSystemWithRate(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemWithRateResultPtr(_result, false);
}

IAgCrdnPointLocateInSystemResultPtr _IAgCrdnPointCBFixedOffset::LocateInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnPointLocateInSystemResult * _result = 0;
    HRESULT _hr = raw_LocateInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointLocateInSystemResultPtr(_result, false);
}

_bstr_t _IAgCrdnPointCBFixedOffset::GetCentralBody ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnPointCBFixedOffset::PutCentralBody ( _bstr_t pRetVal ) {
    HRESULT _hr = put_CentralBody(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnReferenceShapeType _IAgCrdnPointCBFixedOffset::GetReferenceShape ( ) {
    enum AgECrdnReferenceShapeType _result;
    HRESULT _hr = get_ReferenceShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnPointCBFixedOffset::PutReferenceShape ( enum AgECrdnReferenceShapeType pRetVal ) {
    HRESULT _hr = put_ReferenceShape(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

STKUtil::IAgPositionPtr _IAgCrdnPointCBFixedOffset::GetPosition ( ) {
    struct STKUtil::IAgPosition * _result = 0;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgPositionPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnPointCBFixedOffset::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnPointCBFixedOffset::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnPointCBFixedOffset::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnPointCBFixedOffset::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnPointCBFixedOffset::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnPointCBFixedOffset::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnSystemAssembled wrapper method implementations
//

enum AgECrdnKind _IAgCrdnSystemAssembled::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnSystemAssembled::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnSystemAssembled::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnSystemAssembled::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnSystemAssembled::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnSystemAssembled::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnSystemAssembled::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnSystemAssembled::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnSystemAssembled::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnSystemAssembled::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnSystemAssembled::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnSystemAssembled::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnSystemAssembled::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnSystemAssembled::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnSystemType _IAgCrdnSystemAssembled::GetType ( ) {
    enum AgECrdnSystemType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnSystemFindInSystemResultPtr _IAgCrdnSystemAssembled::FindInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnSystemFindInSystemResult * _result = 0;
    HRESULT _hr = raw_FindInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemFindInSystemResultPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnSystemAssembled::GetOriginPoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_OriginPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnAxesRefToPtr _IAgCrdnSystemAssembled::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnSystemAssembled::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnSystemAssembled::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnSystemAssembled::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnSystemAssembled::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

IAgCrdnSystemTransformResultPtr _IAgCrdnSystemAssembled::Transform ( const _variant_t & Epoch, struct IAgCrdnSystem * OutputSystem, struct STKUtil::IAgCartesian3Vector * PositionInMySystem ) {
    struct IAgCrdnSystemTransformResult * _result = 0;
    HRESULT _hr = raw_Transform(Epoch, OutputSystem, PositionInMySystem, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemTransformResultPtr(_result, false);
}

IAgCrdnSystemTransformWithRateResultPtr _IAgCrdnSystemAssembled::TransformWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * OutputSystem, struct STKUtil::IAgCartesian3Vector * PositionInMySystem, struct STKUtil::IAgCartesian3Vector * VelocityInMySystem ) {
    struct IAgCrdnSystemTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformWithRate(Epoch, OutputSystem, PositionInMySystem, VelocityInMySystem, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemTransformWithRateResultPtr(_result, false);
}

HRESULT _IAgCrdnSystemAssembled::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnSystemAssembled::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnSystemOnSurface wrapper method implementations
//

enum AgECrdnKind _IAgCrdnSystemOnSurface::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnSystemOnSurface::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnSystemOnSurface::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnSystemOnSurface::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnSystemOnSurface::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnSystemOnSurface::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnSystemOnSurface::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnSystemOnSurface::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnSystemOnSurface::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnSystemOnSurface::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnSystemOnSurface::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnSystemOnSurface::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnSystemOnSurface::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnSystemOnSurface::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnSystemType _IAgCrdnSystemOnSurface::GetType ( ) {
    enum AgECrdnSystemType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnSystemFindInSystemResultPtr _IAgCrdnSystemOnSurface::FindInSystem ( const _variant_t & Epoch, struct IAgCrdnSystem * System ) {
    struct IAgCrdnSystemFindInSystemResult * _result = 0;
    HRESULT _hr = raw_FindInSystem(Epoch, System, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemFindInSystemResultPtr(_result, false);
}

IAgCrdnCentralBodyRefToPtr _IAgCrdnSystemOnSurface::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

double _IAgCrdnSystemOnSurface::GetAzimuthAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_AzimuthAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnSystemOnSurface::PutAzimuthAngle ( double pRetVal ) {
    HRESULT _hr = put_AzimuthAngle(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnSystemOnSurface::GetUseMSL ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseMSL(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnSystemOnSurface::PutUseMSL ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseMSL(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnLLAPositionPtr _IAgCrdnSystemOnSurface::GetPosition ( ) {
    struct IAgCrdnLLAPosition * _result = 0;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnLLAPositionPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnSystemOnSurface::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnSystemOnSurface::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnSystemOnSurface::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnSystemOnSurface::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

IAgCrdnSystemTransformResultPtr _IAgCrdnSystemOnSurface::Transform ( const _variant_t & Epoch, struct IAgCrdnSystem * OutputSystem, struct STKUtil::IAgCartesian3Vector * PositionInMySystem ) {
    struct IAgCrdnSystemTransformResult * _result = 0;
    HRESULT _hr = raw_Transform(Epoch, OutputSystem, PositionInMySystem, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemTransformResultPtr(_result, false);
}

IAgCrdnSystemTransformWithRateResultPtr _IAgCrdnSystemOnSurface::TransformWithRate ( const _variant_t & Epoch, struct IAgCrdnSystem * OutputSystem, struct STKUtil::IAgCartesian3Vector * PositionInMySystem, struct STKUtil::IAgCartesian3Vector * VelocityInMySystem ) {
    struct IAgCrdnSystemTransformWithRateResult * _result = 0;
    HRESULT _hr = raw_TransformWithRate(Epoch, OutputSystem, PositionInMySystem, VelocityInMySystem, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemTransformWithRateResultPtr(_result, false);
}

HRESULT _IAgCrdnSystemOnSurface::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnSystemOnSurface::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVectorAngleRate wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorAngleRate::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorAngleRate::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorAngleRate::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorAngleRate::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorAngleRate::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorAngleRate::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorAngleRate::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorAngleRate::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorAngleRate::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorAngleRate::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorAngleRate::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorAngleRate::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorAngleRate::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorAngleRate::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorAngleRate::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorAngleRate::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorAngleRate::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnAngleRefToPtr _IAgCrdnVectorAngleRate::GetAngle ( ) {
    struct IAgCrdnAngleRefTo * _result = 0;
    HRESULT _hr = get_Angle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleRefToPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVectorAngleRate::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVectorAngleRate::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorAngleRate::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVectorAngleRate::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

double _IAgCrdnVectorAngleRate::GetDifferencingTimeStep ( ) {
    double _result = 0;
    HRESULT _hr = get_DifferencingTimeStep(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorAngleRate::PutDifferencingTimeStep ( double pRetVal ) {
    HRESULT _hr = put_DifferencingTimeStep(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgCrdnVectorAngleRate::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVectorAngleRate::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVectorApoapsis wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorApoapsis::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorApoapsis::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorApoapsis::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorApoapsis::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorApoapsis::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorApoapsis::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorApoapsis::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorApoapsis::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorApoapsis::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorApoapsis::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorApoapsis::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorApoapsis::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorApoapsis::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorApoapsis::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorApoapsis::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorApoapsis::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorApoapsis::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnVectorApoapsis::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnCentralBodyRefToPtr _IAgCrdnVectorApoapsis::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

enum AgECrdnMeanElementTheory _IAgCrdnVectorApoapsis::GetMeanElementType ( ) {
    enum AgECrdnMeanElementTheory _result;
    HRESULT _hr = get_MeanElementType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorApoapsis::PutMeanElementType ( enum AgECrdnMeanElementTheory pRetVal ) {
    HRESULT _hr = put_MeanElementType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPtr _IAgCrdnVectorApoapsis::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVectorApoapsis::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorApoapsis::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVectorApoapsis::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVectorApoapsis::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVectorApoapsis::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVectorFixedAtEpoch wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorFixedAtEpoch::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorFixedAtEpoch::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorFixedAtEpoch::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorFixedAtEpoch::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorFixedAtEpoch::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorFixedAtEpoch::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorFixedAtEpoch::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorFixedAtEpoch::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorFixedAtEpoch::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorFixedAtEpoch::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorFixedAtEpoch::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorFixedAtEpoch::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorFixedAtEpoch::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorFixedAtEpoch::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorFixedAtEpoch::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorFixedAtEpoch::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorFixedAtEpoch::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

_variant_t _IAgCrdnVectorFixedAtEpoch::GetEpoch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Epoch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgCrdnVectorFixedAtEpoch::PutEpoch ( const _variant_t & pRetVal ) {
    HRESULT _hr = put_Epoch(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnVectorRefToPtr _IAgCrdnVectorFixedAtEpoch::GetSourceVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_SourceVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnAxesRefToPtr _IAgCrdnVectorFixedAtEpoch::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVectorFixedAtEpoch::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVectorFixedAtEpoch::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorFixedAtEpoch::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVectorFixedAtEpoch::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVectorFixedAtEpoch::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVectorFixedAtEpoch::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVectorAngularVelocity wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorAngularVelocity::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorAngularVelocity::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorAngularVelocity::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorAngularVelocity::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorAngularVelocity::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorAngularVelocity::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorAngularVelocity::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorAngularVelocity::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorAngularVelocity::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorAngularVelocity::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorAngularVelocity::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorAngularVelocity::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorAngularVelocity::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorAngularVelocity::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorAngularVelocity::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorAngularVelocity::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorAngularVelocity::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnAxesRefToPtr _IAgCrdnVectorAngularVelocity::GetAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_Axes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

IAgCrdnAxesRefToPtr _IAgCrdnVectorAngularVelocity::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVectorAngularVelocity::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVectorAngularVelocity::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorAngularVelocity::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVectorAngularVelocity::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

double _IAgCrdnVectorAngularVelocity::GetDifferencingTimeStep ( ) {
    double _result = 0;
    HRESULT _hr = get_DifferencingTimeStep(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorAngularVelocity::PutDifferencingTimeStep ( double pRetVal ) {
    HRESULT _hr = put_DifferencingTimeStep(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgCrdnVectorAngularVelocity::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVectorAngularVelocity::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVectorConing wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorConing::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorConing::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorConing::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorConing::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorConing::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorConing::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorConing::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorConing::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorConing::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorConing::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorConing::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorConing::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorConing::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorConing::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorConing::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorConing::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorConing::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnVectorConing::GetAboutVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_AboutVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnVectorConing::GetReferenceVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_ReferenceVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

double _IAgCrdnVectorConing::GetStartClockAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_StartClockAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorConing::PutStartClockAngle ( double pRetVal ) {
    HRESULT _hr = put_StartClockAngle(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnVectorConing::GetStopClockAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_StopClockAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorConing::PutStopClockAngle ( double pRetVal ) {
    HRESULT _hr = put_StopClockAngle(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_variant_t _IAgCrdnVectorConing::GetStartEpoch ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_StartEpoch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

void _IAgCrdnVectorConing::PutStartEpoch ( const _variant_t & pRetVal ) {
    HRESULT _hr = put_StartEpoch(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnVectorConing::GetClockAngleRate ( ) {
    double _result = 0;
    HRESULT _hr = get_ClockAngleRate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorConing::PutClockAngleRate ( double pRetVal ) {
    HRESULT _hr = put_ClockAngleRate(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSweepMode _IAgCrdnVectorConing::GetMode ( ) {
    enum AgECrdnSweepMode _result;
    HRESULT _hr = get_Mode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorConing::PutMode ( enum AgECrdnSweepMode pRetVal ) {
    HRESULT _hr = put_Mode(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPtr _IAgCrdnVectorConing::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVectorConing::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorConing::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVectorConing::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVectorConing::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVectorConing::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVectorCross wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorCross::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorCross::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorCross::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorCross::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorCross::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorCross::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorCross::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorCross::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorCross::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorCross::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorCross::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorCross::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorCross::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorCross::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorCross::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorCross::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorCross::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnVectorCross::GetFrom ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_From(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnVectorCross::GetTo ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_To(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVectorCross::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVectorCross::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorCross::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVectorCross::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVectorCross::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVectorCross::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

VARIANT_BOOL _IAgCrdnVectorCross::GetIsNormalized ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsNormalized(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorCross::PutIsNormalized ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_IsNormalized(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorCross::GetDimension ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Dimension(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorCross::PutDimension ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Dimension(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _IAgCrdnVectorCustomScript wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorCustomScript::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorCustomScript::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorCustomScript::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorCustomScript::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorCustomScript::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorCustomScript::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorCustomScript::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorCustomScript::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorCustomScript::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorCustomScript::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorCustomScript::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorCustomScript::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorCustomScript::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorCustomScript::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorCustomScript::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorCustomScript::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorCustomScript::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnAxesRefToPtr _IAgCrdnVectorCustomScript::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

_bstr_t _IAgCrdnVectorCustomScript::GetScriptFile ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ScriptFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorCustomScript::PutScriptFile ( _bstr_t pRetVal ) {
    HRESULT _hr = put_ScriptFile(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorCustomScript::GetInitializationScriptFile ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_InitializationScriptFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorCustomScript::PutInitializationScriptFile ( _bstr_t pRetVal ) {
    HRESULT _hr = put_InitializationScriptFile(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPtr _IAgCrdnVectorCustomScript::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVectorCustomScript::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorCustomScript::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVectorCustomScript::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVectorCustomScript::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVectorCustomScript::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVectorDerivative wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorDerivative::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorDerivative::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorDerivative::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorDerivative::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorDerivative::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorDerivative::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorDerivative::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorDerivative::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorDerivative::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorDerivative::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorDerivative::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorDerivative::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorDerivative::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorDerivative::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorDerivative::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorDerivative::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorDerivative::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnVectorDerivative::GetVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_Vector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnAxesRefToPtr _IAgCrdnVectorDerivative::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVectorDerivative::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVectorDerivative::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorDerivative::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVectorDerivative::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

double _IAgCrdnVectorDerivative::GetDifferencingTimeStep ( ) {
    double _result = 0;
    HRESULT _hr = get_DifferencingTimeStep(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorDerivative::PutDifferencingTimeStep ( double pRetVal ) {
    HRESULT _hr = put_DifferencingTimeStep(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

HRESULT _IAgCrdnVectorDerivative::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVectorDerivative::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVectorDisplacement wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorDisplacement::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorDisplacement::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorDisplacement::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorDisplacement::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorDisplacement::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorDisplacement::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorDisplacement::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorDisplacement::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorDisplacement::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorDisplacement::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorDisplacement::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorDisplacement::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorDisplacement::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorDisplacement::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorDisplacement::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorDisplacement::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorDisplacement::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnVectorDisplacement::GetOrigin ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_Origin(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnVectorDisplacement::GetDestination ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_Destination(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorDisplacement::GetApparent ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Apparent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorDisplacement::PutApparent ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_Apparent(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnVectorDisplacement::GetIgnoreAbberation ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IgnoreAbberation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorDisplacement::PutIgnoreAbberation ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_IgnoreAbberation(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnSignalSense _IAgCrdnVectorDisplacement::GetSignalSense ( ) {
    enum AgECrdnSignalSense _result;
    HRESULT _hr = get_SignalSense(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorDisplacement::PutSignalSense ( enum AgECrdnSignalSense pRetVal ) {
    HRESULT _hr = put_SignalSense(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnSystemRefToPtr _IAgCrdnVectorDisplacement::GetReferenceSystem ( ) {
    struct IAgCrdnSystemRefTo * _result = 0;
    HRESULT _hr = get_ReferenceSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemRefToPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVectorDisplacement::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVectorDisplacement::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorDisplacement::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVectorDisplacement::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVectorDisplacement::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVectorDisplacement::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVectorTwoPlanesIntersection wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorTwoPlanesIntersection::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorTwoPlanesIntersection::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorTwoPlanesIntersection::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorTwoPlanesIntersection::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorTwoPlanesIntersection::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorTwoPlanesIntersection::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorTwoPlanesIntersection::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorTwoPlanesIntersection::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorTwoPlanesIntersection::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorTwoPlanesIntersection::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorTwoPlanesIntersection::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorTwoPlanesIntersection::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorTwoPlanesIntersection::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorTwoPlanesIntersection::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorTwoPlanesIntersection::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorTwoPlanesIntersection::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorTwoPlanesIntersection::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnPlaneRefToPtr _IAgCrdnVectorTwoPlanesIntersection::GetPlaneA ( ) {
    struct IAgCrdnPlaneRefTo * _result = 0;
    HRESULT _hr = get_PlaneA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneRefToPtr(_result, false);
}

IAgCrdnPlaneRefToPtr _IAgCrdnVectorTwoPlanesIntersection::GetPlaneB ( ) {
    struct IAgCrdnPlaneRefTo * _result = 0;
    HRESULT _hr = get_PlaneB(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneRefToPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVectorTwoPlanesIntersection::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVectorTwoPlanesIntersection::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorTwoPlanesIntersection::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVectorTwoPlanesIntersection::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVectorTwoPlanesIntersection::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVectorTwoPlanesIntersection::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVectorModelAttach wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorModelAttach::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorModelAttach::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorModelAttach::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorModelAttach::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorModelAttach::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorModelAttach::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorModelAttach::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorModelAttach::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorModelAttach::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorModelAttach::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorModelAttach::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorModelAttach::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorModelAttach::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorModelAttach::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorModelAttach::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorModelAttach::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorModelAttach::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

_bstr_t _IAgCrdnVectorModelAttach::GetPointableElementName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_PointableElementName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorModelAttach::PutPointableElementName ( _bstr_t pRetVal ) {
    HRESULT _hr = put_PointableElementName(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPtr _IAgCrdnVectorModelAttach::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVectorModelAttach::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorModelAttach::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVectorModelAttach::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVectorModelAttach::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVectorModelAttach::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVectorProjection wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorProjection::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorProjection::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorProjection::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorProjection::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorProjection::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorProjection::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorProjection::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorProjection::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorProjection::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorProjection::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorProjection::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorProjection::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorProjection::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorProjection::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorProjection::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorProjection::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorProjection::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnVectorProjection::GetSource ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_Source(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

IAgCrdnPlaneRefToPtr _IAgCrdnVectorProjection::GetReferencePlane ( ) {
    struct IAgCrdnPlaneRefTo * _result = 0;
    HRESULT _hr = get_ReferencePlane(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneRefToPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVectorProjection::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVectorProjection::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorProjection::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVectorProjection::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVectorProjection::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVectorProjection::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVectorScaled wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorScaled::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorScaled::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorScaled::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorScaled::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorScaled::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorScaled::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorScaled::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorScaled::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorScaled::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorScaled::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorScaled::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorScaled::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorScaled::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorScaled::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorScaled::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorScaled::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorScaled::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnVectorScaled::GetReferenceVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_ReferenceVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

double _IAgCrdnVectorScaled::GetScale ( ) {
    double _result = 0;
    HRESULT _hr = get_Scale(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorScaled::PutScale ( double pRetVal ) {
    HRESULT _hr = put_Scale(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnVectorScaled::GetIsNormalized ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsNormalized(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorScaled::PutIsNormalized ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_IsNormalized(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPtr _IAgCrdnVectorScaled::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVectorScaled::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorScaled::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVectorScaled::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVectorScaled::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVectorScaled::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVectorEccentricity wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorEccentricity::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorEccentricity::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorEccentricity::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorEccentricity::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorEccentricity::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorEccentricity::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorEccentricity::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorEccentricity::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorEccentricity::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorEccentricity::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorEccentricity::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorEccentricity::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorEccentricity::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorEccentricity::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorEccentricity::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorEccentricity::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorEccentricity::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnCentralBodyRefToPtr _IAgCrdnVectorEccentricity::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnVectorEccentricity::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

enum AgECrdnMeanElementTheory _IAgCrdnVectorEccentricity::GetMeanElementType ( ) {
    enum AgECrdnMeanElementTheory _result;
    HRESULT _hr = get_MeanElementType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorEccentricity::PutMeanElementType ( enum AgECrdnMeanElementTheory pRetVal ) {
    HRESULT _hr = put_MeanElementType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPtr _IAgCrdnVectorEccentricity::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVectorEccentricity::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorEccentricity::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVectorEccentricity::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVectorEccentricity::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVectorEccentricity::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVectorFixedInAxes wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorFixedInAxes::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorFixedInAxes::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorFixedInAxes::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorFixedInAxes::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorFixedInAxes::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorFixedInAxes::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorFixedInAxes::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorFixedInAxes::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorFixedInAxes::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorFixedInAxes::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorFixedInAxes::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorFixedInAxes::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorFixedInAxes::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorFixedInAxes::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorFixedInAxes::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorFixedInAxes::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorFixedInAxes::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnAxesRefToPtr _IAgCrdnVectorFixedInAxes::GetReferenceAxes ( ) {
    struct IAgCrdnAxesRefTo * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesRefToPtr(_result, false);
}

STKUtil::IAgDirectionPtr _IAgCrdnVectorFixedInAxes::GetDirection ( ) {
    struct STKUtil::IAgDirection * _result = 0;
    HRESULT _hr = get_Direction(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return STKUtil::IAgDirectionPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVectorFixedInAxes::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVectorFixedInAxes::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorFixedInAxes::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVectorFixedInAxes::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVectorFixedInAxes::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVectorFixedInAxes::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVectorLineOfNodes wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorLineOfNodes::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorLineOfNodes::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorLineOfNodes::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorLineOfNodes::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorLineOfNodes::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorLineOfNodes::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorLineOfNodes::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorLineOfNodes::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorLineOfNodes::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorLineOfNodes::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorLineOfNodes::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorLineOfNodes::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorLineOfNodes::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorLineOfNodes::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorLineOfNodes::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorLineOfNodes::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorLineOfNodes::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnCentralBodyRefToPtr _IAgCrdnVectorLineOfNodes::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnVectorLineOfNodes::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVectorLineOfNodes::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVectorLineOfNodes::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorLineOfNodes::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVectorLineOfNodes::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVectorLineOfNodes::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVectorLineOfNodes::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVectorOrbitAngularMomentum wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorOrbitAngularMomentum::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorOrbitAngularMomentum::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorOrbitAngularMomentum::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorOrbitAngularMomentum::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorOrbitAngularMomentum::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorOrbitAngularMomentum::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorOrbitAngularMomentum::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorOrbitAngularMomentum::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorOrbitAngularMomentum::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorOrbitAngularMomentum::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorOrbitAngularMomentum::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorOrbitAngularMomentum::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorOrbitAngularMomentum::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorOrbitAngularMomentum::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorOrbitAngularMomentum::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorOrbitAngularMomentum::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorOrbitAngularMomentum::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnCentralBodyRefToPtr _IAgCrdnVectorOrbitAngularMomentum::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnVectorOrbitAngularMomentum::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

enum AgECrdnMeanElementTheory _IAgCrdnVectorOrbitAngularMomentum::GetMeanElementType ( ) {
    enum AgECrdnMeanElementTheory _result;
    HRESULT _hr = get_MeanElementType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorOrbitAngularMomentum::PutMeanElementType ( enum AgECrdnMeanElementTheory pRetVal ) {
    HRESULT _hr = put_MeanElementType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPtr _IAgCrdnVectorOrbitAngularMomentum::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVectorOrbitAngularMomentum::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorOrbitAngularMomentum::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVectorOrbitAngularMomentum::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVectorOrbitAngularMomentum::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVectorOrbitAngularMomentum::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVectorOrbitNormal wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorOrbitNormal::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorOrbitNormal::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorOrbitNormal::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorOrbitNormal::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorOrbitNormal::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorOrbitNormal::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorOrbitNormal::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorOrbitNormal::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorOrbitNormal::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorOrbitNormal::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorOrbitNormal::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorOrbitNormal::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorOrbitNormal::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorOrbitNormal::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorOrbitNormal::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorOrbitNormal::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorOrbitNormal::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnCentralBodyRefToPtr _IAgCrdnVectorOrbitNormal::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnVectorOrbitNormal::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

enum AgECrdnMeanElementTheory _IAgCrdnVectorOrbitNormal::GetMeanElementType ( ) {
    enum AgECrdnMeanElementTheory _result;
    HRESULT _hr = get_MeanElementType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorOrbitNormal::PutMeanElementType ( enum AgECrdnMeanElementTheory pRetVal ) {
    HRESULT _hr = put_MeanElementType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPtr _IAgCrdnVectorOrbitNormal::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVectorOrbitNormal::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorOrbitNormal::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVectorOrbitNormal::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVectorOrbitNormal::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVectorOrbitNormal::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVectorPeriapsis wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorPeriapsis::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorPeriapsis::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorPeriapsis::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorPeriapsis::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorPeriapsis::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorPeriapsis::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorPeriapsis::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorPeriapsis::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorPeriapsis::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorPeriapsis::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorPeriapsis::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorPeriapsis::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorPeriapsis::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorPeriapsis::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorPeriapsis::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorPeriapsis::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorPeriapsis::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnCentralBodyRefToPtr _IAgCrdnVectorPeriapsis::GetCentralBody ( ) {
    struct IAgCrdnCentralBodyRefTo * _result = 0;
    HRESULT _hr = get_CentralBody(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCentralBodyRefToPtr(_result, false);
}

IAgCrdnPointRefToPtr _IAgCrdnVectorPeriapsis::GetReferencePoint ( ) {
    struct IAgCrdnPointRefTo * _result = 0;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointRefToPtr(_result, false);
}

enum AgECrdnMeanElementTheory _IAgCrdnVectorPeriapsis::GetMeanElementType ( ) {
    enum AgECrdnMeanElementTheory _result;
    HRESULT _hr = get_MeanElementType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorPeriapsis::PutMeanElementType ( enum AgECrdnMeanElementTheory pRetVal ) {
    HRESULT _hr = put_MeanElementType(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPtr _IAgCrdnVectorPeriapsis::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVectorPeriapsis::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorPeriapsis::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVectorPeriapsis::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVectorPeriapsis::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVectorPeriapsis::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVectorReflection wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorReflection::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorReflection::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorReflection::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorReflection::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorReflection::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorReflection::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorReflection::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorReflection::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorReflection::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorReflection::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorReflection::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorReflection::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorReflection::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorReflection::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorReflection::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorReflection::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorReflection::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnVectorRefToPtr _IAgCrdnVectorReflection::GetIncomingVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_IncomingVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorReflection::GetUseOppositeOfSelectedVector ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseOppositeOfSelectedVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorReflection::PutUseOppositeOfSelectedVector ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseOppositeOfSelectedVector(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnVectorRefToPtr _IAgCrdnVectorReflection::GetNormalVector ( ) {
    struct IAgCrdnVectorRefTo * _result = 0;
    HRESULT _hr = get_NormalVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorRefToPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorReflection::GetAllowReflectionsOnBackside ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AllowReflectionsOnBackside(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorReflection::PutAllowReflectionsOnBackside ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_AllowReflectionsOnBackside(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnVectorReflection::GetScaleFactor ( ) {
    double _result = 0;
    HRESULT _hr = get_ScaleFactor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorReflection::PutScaleFactor ( double pRetVal ) {
    HRESULT _hr = put_ScaleFactor(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPtr _IAgCrdnVectorReflection::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVectorReflection::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorReflection::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVectorReflection::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVectorReflection::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVectorReflection::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVectorDirectionToStar wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorDirectionToStar::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorDirectionToStar::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorDirectionToStar::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorDirectionToStar::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorDirectionToStar::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorDirectionToStar::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorDirectionToStar::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorDirectionToStar::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorDirectionToStar::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorDirectionToStar::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorDirectionToStar::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorDirectionToStar::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorDirectionToStar::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorDirectionToStar::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorDirectionToStar::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorDirectionToStar::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorDirectionToStar::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

_bstr_t _IAgCrdnVectorDirectionToStar::GetSelectedStar ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_SelectedStar(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorDirectionToStar::PutSelectedStar ( _bstr_t pRetVal ) {
    HRESULT _hr = put_SelectedStar(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPtr _IAgCrdnVectorDirectionToStar::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVectorDirectionToStar::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorDirectionToStar::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVectorDirectionToStar::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVectorDirectionToStar::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVectorDirectionToStar::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVectorFixedAtTimeInstant wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorFixedAtTimeInstant::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorFixedAtTimeInstant::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorFixedAtTimeInstant::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorFixedAtTimeInstant::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorFixedAtTimeInstant::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorFixedAtTimeInstant::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorFixedAtTimeInstant::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorFixedAtTimeInstant::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorFixedAtTimeInstant::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorFixedAtTimeInstant::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorFixedAtTimeInstant::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorFixedAtTimeInstant::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorFixedAtTimeInstant::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorFixedAtTimeInstant::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorFixedAtTimeInstant::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorFixedAtTimeInstant::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorFixedAtTimeInstant::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnEventPtr _IAgCrdnVectorFixedAtTimeInstant::GetReferenceTimeInstant ( ) {
    struct IAgCrdnEvent * _result = 0;
    HRESULT _hr = get_ReferenceTimeInstant(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventPtr(_result, false);
}

void _IAgCrdnVectorFixedAtTimeInstant::PutReferenceTimeInstant ( struct IAgCrdnEvent * ppRetVal ) {
    HRESULT _hr = put_ReferenceTimeInstant(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnVectorPtr _IAgCrdnVectorFixedAtTimeInstant::GetSourceVector ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_SourceVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

void _IAgCrdnVectorFixedAtTimeInstant::PutSourceVector ( struct IAgCrdnVector * ppRetVal ) {
    HRESULT _hr = put_SourceVector(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnAxesPtr _IAgCrdnVectorFixedAtTimeInstant::GetReferenceAxes ( ) {
    struct IAgCrdnAxes * _result = 0;
    HRESULT _hr = get_ReferenceAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesPtr(_result, false);
}

void _IAgCrdnVectorFixedAtTimeInstant::PutReferenceAxes ( struct IAgCrdnAxes * ppRetVal ) {
    HRESULT _hr = put_ReferenceAxes(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPtr _IAgCrdnVectorFixedAtTimeInstant::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVectorFixedAtTimeInstant::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorFixedAtTimeInstant::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVectorFixedAtTimeInstant::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVectorFixedAtTimeInstant::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVectorFixedAtTimeInstant::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVectorLinearCombination wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorLinearCombination::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorLinearCombination::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorLinearCombination::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorLinearCombination::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorLinearCombination::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorLinearCombination::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorLinearCombination::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorLinearCombination::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorLinearCombination::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorLinearCombination::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorLinearCombination::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorLinearCombination::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorLinearCombination::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorLinearCombination::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorLinearCombination::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorLinearCombination::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorLinearCombination::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnVectorLinearCombination::GetVectorA ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_VectorA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

void _IAgCrdnVectorLinearCombination::PutVectorA ( struct IAgCrdnVector * ppRetVal ) {
    HRESULT _hr = put_VectorA(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnVectorLinearCombination::GetScaleFactorA ( ) {
    double _result = 0;
    HRESULT _hr = get_ScaleFactorA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorLinearCombination::PutScaleFactorA ( double pRetVal ) {
    HRESULT _hr = put_ScaleFactorA(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnVectorLinearCombination::GetNormalizeVectorA ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_NormalizeVectorA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorLinearCombination::PutNormalizeVectorA ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_NormalizeVectorA(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnVectorPtr _IAgCrdnVectorLinearCombination::GetVectorB ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_VectorB(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

void _IAgCrdnVectorLinearCombination::PutVectorB ( struct IAgCrdnVector * ppRetVal ) {
    HRESULT _hr = put_VectorB(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnVectorLinearCombination::GetScaleFactorB ( ) {
    double _result = 0;
    HRESULT _hr = get_ScaleFactorB(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorLinearCombination::PutScaleFactorB ( double pRetVal ) {
    HRESULT _hr = put_ScaleFactorB(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnVectorLinearCombination::GetNormalizeVectorB ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_NormalizeVectorB(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorLinearCombination::PutNormalizeVectorB ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_NormalizeVectorB(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnDimensionInheritance _IAgCrdnVectorLinearCombination::GetOutputDimensionInheritance ( ) {
    enum AgECrdnDimensionInheritance _result;
    HRESULT _hr = get_OutputDimensionInheritance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorLinearCombination::PutOutputDimensionInheritance ( enum AgECrdnDimensionInheritance pRetVal ) {
    HRESULT _hr = put_OutputDimensionInheritance(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorLinearCombination::GetOutputDimension ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_OutputDimension(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorLinearCombination::PutOutputDimension ( _bstr_t pRetVal ) {
    HRESULT _hr = put_OutputDimension(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPtr _IAgCrdnVectorLinearCombination::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVectorLinearCombination::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorLinearCombination::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVectorLinearCombination::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVectorLinearCombination::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVectorLinearCombination::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVectorProjectAlongVector wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorProjectAlongVector::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorProjectAlongVector::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorProjectAlongVector::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorProjectAlongVector::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorProjectAlongVector::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorProjectAlongVector::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorProjectAlongVector::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorProjectAlongVector::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorProjectAlongVector::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorProjectAlongVector::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorProjectAlongVector::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorProjectAlongVector::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorProjectAlongVector::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorProjectAlongVector::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorProjectAlongVector::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorProjectAlongVector::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorProjectAlongVector::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnVectorProjectAlongVector::GetSourceVector ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_SourceVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

void _IAgCrdnVectorProjectAlongVector::PutSourceVector ( struct IAgCrdnVector * ppRetVal ) {
    HRESULT _hr = put_SourceVector(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnVectorPtr _IAgCrdnVectorProjectAlongVector::GetAlongVector ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_AlongVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

void _IAgCrdnVectorProjectAlongVector::PutAlongVector ( struct IAgCrdnVector * ppRetVal ) {
    HRESULT _hr = put_AlongVector(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPtr _IAgCrdnVectorProjectAlongVector::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVectorProjectAlongVector::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorProjectAlongVector::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVectorProjectAlongVector::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVectorProjectAlongVector::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVectorProjectAlongVector::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVectorScalarLinearCombination wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorScalarLinearCombination::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorScalarLinearCombination::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorScalarLinearCombination::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorScalarLinearCombination::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorScalarLinearCombination::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorScalarLinearCombination::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorScalarLinearCombination::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorScalarLinearCombination::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorScalarLinearCombination::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorScalarLinearCombination::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorScalarLinearCombination::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorScalarLinearCombination::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorScalarLinearCombination::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorScalarLinearCombination::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorScalarLinearCombination::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorScalarLinearCombination::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorScalarLinearCombination::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnVectorScalarLinearCombination::GetVectorA ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_VectorA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

void _IAgCrdnVectorScalarLinearCombination::PutVectorA ( struct IAgCrdnVector * ppRetVal ) {
    HRESULT _hr = put_VectorA(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnVectorScalarLinearCombination::GetScaleFactorA ( ) {
    double _result = 0;
    HRESULT _hr = get_ScaleFactorA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorScalarLinearCombination::PutScaleFactorA ( double pRetVal ) {
    HRESULT _hr = put_ScaleFactorA(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnVectorScalarLinearCombination::GetNormalizeVectorA ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_NormalizeVectorA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorScalarLinearCombination::PutNormalizeVectorA ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_NormalizeVectorA(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnVectorScalarLinearCombination::GetUseScaleFromScalarA ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseScaleFromScalarA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorScalarLinearCombination::PutUseScaleFromScalarA ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseScaleFromScalarA(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnVectorScalarLinearCombination::GetUseScaleFromScalarB ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseScaleFromScalarB(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorScalarLinearCombination::PutUseScaleFromScalarB ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_UseScaleFromScalarB(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnCalcScalarPtr _IAgCrdnVectorScalarLinearCombination::GetScalarA ( ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = get_ScalarA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

void _IAgCrdnVectorScalarLinearCombination::PutScalarA ( struct IAgCrdnCalcScalar * ppRetVal ) {
    HRESULT _hr = put_ScalarA(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnCalcScalarPtr _IAgCrdnVectorScalarLinearCombination::GetScalarB ( ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = get_ScalarB(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

void _IAgCrdnVectorScalarLinearCombination::PutScalarB ( struct IAgCrdnCalcScalar * ppRetVal ) {
    HRESULT _hr = put_ScalarB(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnVectorPtr _IAgCrdnVectorScalarLinearCombination::GetVectorB ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_VectorB(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

void _IAgCrdnVectorScalarLinearCombination::PutVectorB ( struct IAgCrdnVector * ppRetVal ) {
    HRESULT _hr = put_VectorB(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnVectorScalarLinearCombination::GetScaleFactorB ( ) {
    double _result = 0;
    HRESULT _hr = get_ScaleFactorB(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorScalarLinearCombination::PutScaleFactorB ( double pRetVal ) {
    HRESULT _hr = put_ScaleFactorB(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnVectorScalarLinearCombination::GetNormalizeVectorB ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_NormalizeVectorB(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorScalarLinearCombination::PutNormalizeVectorB ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_NormalizeVectorB(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnDimensionInheritance _IAgCrdnVectorScalarLinearCombination::GetOutputDimensionInheritance ( ) {
    enum AgECrdnDimensionInheritance _result;
    HRESULT _hr = get_OutputDimensionInheritance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorScalarLinearCombination::PutOutputDimensionInheritance ( enum AgECrdnDimensionInheritance pRetVal ) {
    HRESULT _hr = put_OutputDimensionInheritance(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorScalarLinearCombination::GetOutputDimension ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_OutputDimension(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorScalarLinearCombination::PutOutputDimension ( _bstr_t pRetVal ) {
    HRESULT _hr = put_OutputDimension(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPtr _IAgCrdnVectorScalarLinearCombination::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVectorScalarLinearCombination::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorScalarLinearCombination::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVectorScalarLinearCombination::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVectorScalarLinearCombination::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVectorScalarLinearCombination::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVectorScalarScaled wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorScalarScaled::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorScalarScaled::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorScalarScaled::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorScalarScaled::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorScalarScaled::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorScalarScaled::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorScalarScaled::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorScalarScaled::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorScalarScaled::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorScalarScaled::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorScalarScaled::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorScalarScaled::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorScalarScaled::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorScalarScaled::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorScalarScaled::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorScalarScaled::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorScalarScaled::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnVectorPtr _IAgCrdnVectorScalarScaled::GetInputVector ( ) {
    struct IAgCrdnVector * _result = 0;
    HRESULT _hr = get_InputVector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorPtr(_result, false);
}

void _IAgCrdnVectorScalarScaled::PutInputVector ( struct IAgCrdnVector * ppRetVal ) {
    HRESULT _hr = put_InputVector(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnCalcScalarPtr _IAgCrdnVectorScalarScaled::GetInputScalar ( ) {
    struct IAgCrdnCalcScalar * _result = 0;
    HRESULT _hr = get_InputScalar(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarPtr(_result, false);
}

void _IAgCrdnVectorScalarScaled::PutInputScalar ( struct IAgCrdnCalcScalar * ppRetVal ) {
    HRESULT _hr = put_InputScalar(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnVectorScalarScaled::GetScaleFactor ( ) {
    double _result = 0;
    HRESULT _hr = get_ScaleFactor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorScalarScaled::PutScaleFactor ( double pRetVal ) {
    HRESULT _hr = put_ScaleFactor(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

VARIANT_BOOL _IAgCrdnVectorScalarScaled::GetNormalize ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Normalize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorScalarScaled::PutNormalize ( VARIANT_BOOL pRetVal ) {
    HRESULT _hr = put_Normalize(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

enum AgECrdnVectorScaledDimensionInheritance _IAgCrdnVectorScalarScaled::GetDimensionInheritance ( ) {
    enum AgECrdnVectorScaledDimensionInheritance _result;
    HRESULT _hr = get_DimensionInheritance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorScalarScaled::PutDimensionInheritance ( enum AgECrdnVectorScaledDimensionInheritance pRetVal ) {
    HRESULT _hr = put_DimensionInheritance(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorScalarScaled::GetDimension ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Dimension(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorScalarScaled::PutDimension ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Dimension(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPtr _IAgCrdnVectorScalarScaled::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVectorScalarScaled::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorScalarScaled::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVectorScalarScaled::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVectorScalarScaled::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVectorScalarScaled::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVectorVelocityAcceleration wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorVelocityAcceleration::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorVelocityAcceleration::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorVelocityAcceleration::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorVelocityAcceleration::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorVelocityAcceleration::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorVelocityAcceleration::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorVelocityAcceleration::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorVelocityAcceleration::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorVelocityAcceleration::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorVelocityAcceleration::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorVelocityAcceleration::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorVelocityAcceleration::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorVelocityAcceleration::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorVelocityAcceleration::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorVelocityAcceleration::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorVelocityAcceleration::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorVelocityAcceleration::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

IAgCrdnSystemPtr _IAgCrdnVectorVelocityAcceleration::GetReferenceSystem ( ) {
    struct IAgCrdnSystem * _result = 0;
    HRESULT _hr = get_ReferenceSystem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemPtr(_result, false);
}

void _IAgCrdnVectorVelocityAcceleration::PutReferenceSystem ( struct IAgCrdnSystem * ppRetVal ) {
    HRESULT _hr = put_ReferenceSystem(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPointPtr _IAgCrdnVectorVelocityAcceleration::GetPoint ( ) {
    struct IAgCrdnPoint * _result = 0;
    HRESULT _hr = get_Point(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointPtr(_result, false);
}

void _IAgCrdnVectorVelocityAcceleration::PutPoint ( struct IAgCrdnPoint * ppRetVal ) {
    HRESULT _hr = put_Point(ppRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

double _IAgCrdnVectorVelocityAcceleration::GetDifferencingTimeStep ( ) {
    double _result = 0;
    HRESULT _hr = get_DifferencingTimeStep(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

void _IAgCrdnVectorVelocityAcceleration::PutDifferencingTimeStep ( double pRetVal ) {
    HRESULT _hr = put_DifferencingTimeStep(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

IAgCrdnPtr _IAgCrdnVectorVelocityAcceleration::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVectorVelocityAcceleration::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorVelocityAcceleration::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVectorVelocityAcceleration::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVectorVelocityAcceleration::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVectorVelocityAcceleration::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnVectorPlugin wrapper method implementations
//

enum AgECrdnKind _IAgCrdnVectorPlugin::GetKind ( ) {
    enum AgECrdnKind _result;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

_bstr_t _IAgCrdnVectorPlugin::GetCategory ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

void _IAgCrdnVectorPlugin::PutCategory ( _bstr_t pRetVal ) {
    HRESULT _hr = put_Category(pRetVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

_bstr_t _IAgCrdnVectorPlugin::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorPlugin::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorPlugin::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorPlugin::GetIsDuplicable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDuplicable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnContextPtr _IAgCrdnVectorPlugin::GetContext ( ) {
    struct IAgCrdnContext * _result = 0;
    HRESULT _hr = get_Context(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnContextPtr(_result, false);
}

IAgCrdnTypeInfoPtr _IAgCrdnVectorPlugin::GetTypeInfo ( ) {
    struct IAgCrdnTypeInfo * _result = 0;
    HRESULT _hr = get_TypeInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnTypeInfoPtr(_result, false);
}

_bstr_t _IAgCrdnVectorPlugin::GetQualifiedPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_QualifiedPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorPlugin::GetIsValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorPlugin::GetIsReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReady(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

VARIANT_BOOL _IAgCrdnVectorPlugin::GetIsReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnIntervalCollectionPtr _IAgCrdnVectorPlugin::GetAvailability ( ) {
    struct IAgCrdnIntervalCollection * _result = 0;
    HRESULT _hr = raw_GetAvailability(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnIntervalCollectionPtr(_result, false);
}

enum AgECrdnVectorType _IAgCrdnVectorPlugin::GetType ( ) {
    enum AgECrdnVectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnVectorFindInAxesResultPtr _IAgCrdnVectorPlugin::FindInAxes ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesResult * _result = 0;
    HRESULT _hr = raw_FindInAxes(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesResultPtr(_result, false);
}

IAgCrdnVectorFindInAxesWithRateResultPtr _IAgCrdnVectorPlugin::FindInAxesWithRate ( const _variant_t & Epoch, struct IAgCrdnAxes * Axes ) {
    struct IAgCrdnVectorFindInAxesWithRateResult * _result = 0;
    HRESULT _hr = raw_FindInAxesWithRate(Epoch, Axes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorFindInAxesWithRateResultPtr(_result, false);
}

_bstr_t _IAgCrdnVectorPlugin::GetProgID ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ProgID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

_bstr_t _IAgCrdnVectorPlugin::GetDisplayName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DisplayName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

SAFEARRAY * _IAgCrdnVectorPlugin::GetAvailableProperties ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_AvailableProperties(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

HRESULT _IAgCrdnVectorPlugin::Reset ( ) {
    HRESULT _hr = raw_Reset();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVectorPlugin::SetProperty ( _bstr_t Name, _bstr_t Value ) {
    HRESULT _hr = raw_SetProperty(Name, Value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

_bstr_t _IAgCrdnVectorPlugin::GetProperty ( _bstr_t Name ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetProperty(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

IAgCrdnPtr _IAgCrdnVectorPlugin::Duplicate ( _bstr_t NewName, _bstr_t Description ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_Duplicate(NewName, Description, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

IAgCrdnPtr _IAgCrdnVectorPlugin::AnonymousDuplicate ( ) {
    struct IAgCrdn * _result = 0;
    HRESULT _hr = raw_AnonymousDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnVectorPlugin::DependsOn ( struct IAgCrdn * Component ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DependsOn(Component, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnCollectionPtr _IAgCrdnVectorPlugin::GetEmbeddedComponents ( ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = get_EmbeddedComponents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

HRESULT _IAgCrdnVectorPlugin::Export ( _bstr_t Filename, _bstr_t Comments ) {
    HRESULT _hr = raw_Export(Filename, Comments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

HRESULT _IAgCrdnVectorPlugin::Rename ( _bstr_t NewName ) {
    HRESULT _hr = raw_Rename(NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _IAgCrdnProvider wrapper method implementations
//

IAgCrdnVectorGroupPtr _IAgCrdnProvider::GetVectors ( ) {
    struct IAgCrdnVectorGroup * _result = 0;
    HRESULT _hr = get_Vectors(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVectorGroupPtr(_result, false);
}

IAgCrdnPointGroupPtr _IAgCrdnProvider::GetPoints ( ) {
    struct IAgCrdnPointGroup * _result = 0;
    HRESULT _hr = get_Points(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPointGroupPtr(_result, false);
}

IAgCrdnAngleGroupPtr _IAgCrdnProvider::GetAngles ( ) {
    struct IAgCrdnAngleGroup * _result = 0;
    HRESULT _hr = get_Angles(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAngleGroupPtr(_result, false);
}

IAgCrdnAxesGroupPtr _IAgCrdnProvider::GetAxes ( ) {
    struct IAgCrdnAxesGroup * _result = 0;
    HRESULT _hr = get_Axes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnAxesGroupPtr(_result, false);
}

IAgCrdnPlaneGroupPtr _IAgCrdnProvider::GetPlanes ( ) {
    struct IAgCrdnPlaneGroup * _result = 0;
    HRESULT _hr = get_Planes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnPlaneGroupPtr(_result, false);
}

IAgCrdnSystemGroupPtr _IAgCrdnProvider::GetSystems ( ) {
    struct IAgCrdnSystemGroup * _result = 0;
    HRESULT _hr = get_Systems(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnSystemGroupPtr(_result, false);
}

IAgCrdnWellKnownSystemsPtr _IAgCrdnProvider::GetWellKnownSystems ( ) {
    struct IAgCrdnWellKnownSystems * _result = 0;
    HRESULT _hr = get_WellKnownSystems(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnWellKnownSystemsPtr(_result, false);
}

IAgCrdnWellKnownAxesPtr _IAgCrdnProvider::GetWellKnownAxes ( ) {
    struct IAgCrdnWellKnownAxes * _result = 0;
    HRESULT _hr = get_WellKnownAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnWellKnownAxesPtr(_result, false);
}

IAgCrdnEventGroupPtr _IAgCrdnProvider::GetEvents ( ) {
    struct IAgCrdnEventGroup * _result = 0;
    HRESULT _hr = get_Events(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventGroupPtr(_result, false);
}

IAgCrdnEventIntervalGroupPtr _IAgCrdnProvider::GetEventIntervals ( ) {
    struct IAgCrdnEventIntervalGroup * _result = 0;
    HRESULT _hr = get_EventIntervals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalGroupPtr(_result, false);
}

IAgCrdnCalcScalarGroupPtr _IAgCrdnProvider::GetCalcScalars ( ) {
    struct IAgCrdnCalcScalarGroup * _result = 0;
    HRESULT _hr = get_CalcScalars(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCalcScalarGroupPtr(_result, false);
}

IAgCrdnEventArrayGroupPtr _IAgCrdnProvider::GetEventArrays ( ) {
    struct IAgCrdnEventArrayGroup * _result = 0;
    HRESULT _hr = get_EventArrays(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventArrayGroupPtr(_result, false);
}

IAgCrdnEventIntervalListGroupPtr _IAgCrdnProvider::GetEventIntervalLists ( ) {
    struct IAgCrdnEventIntervalListGroup * _result = 0;
    HRESULT _hr = get_EventIntervalLists(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalListGroupPtr(_result, false);
}

IAgCrdnEventIntervalCollectionGroupPtr _IAgCrdnProvider::GetEventIntervalCollections ( ) {
    struct IAgCrdnEventIntervalCollectionGroup * _result = 0;
    HRESULT _hr = get_EventIntervalCollections(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnEventIntervalCollectionGroupPtr(_result, false);
}

IAgCrdnParameterSetGroupPtr _IAgCrdnProvider::GetParameterSets ( ) {
    struct IAgCrdnParameterSetGroup * _result = 0;
    HRESULT _hr = get_ParameterSets(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnParameterSetGroupPtr(_result, false);
}

IAgCrdnConditionGroupPtr _IAgCrdnProvider::GetConditions ( ) {
    struct IAgCrdnConditionGroup * _result = 0;
    HRESULT _hr = get_Conditions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConditionGroupPtr(_result, false);
}

VARIANT_BOOL _IAgCrdnProvider::Supports ( enum AgECrdnKind Feature ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Supports(Feature, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

IAgCrdnConditionSetGroupPtr _IAgCrdnProvider::GetConditionSets ( ) {
    struct IAgCrdnConditionSetGroup * _result = 0;
    HRESULT _hr = get_ConditionSets(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnConditionSetGroupPtr(_result, false);
}

IAgCrdnCollectionPtr _IAgCrdnProvider::Import ( _bstr_t Filename ) {
    struct IAgCrdnCollection * _result = 0;
    HRESULT _hr = raw_Import(Filename, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnCollectionPtr(_result, false);
}

IAgCrdnVolumeGridGroupPtr _IAgCrdnProvider::GetVolumeGrids ( ) {
    struct IAgCrdnVolumeGridGroup * _result = 0;
    HRESULT _hr = get_VolumeGrids(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumeGridGroupPtr(_result, false);
}

IAgCrdnVolumeGroupPtr _IAgCrdnProvider::GetVolumes ( ) {
    struct IAgCrdnVolumeGroup * _result = 0;
    HRESULT _hr = get_Volumes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnVolumeGroupPtr(_result, false);
}

//
// interface _IAgCrdnRoot wrapper method implementations
//

IAgCrdnProviderPtr _IAgCrdnRoot::GetTemplateProvider ( _bstr_t ClassName ) {
    struct IAgCrdnProvider * _result = 0;
    HRESULT _hr = raw_GetTemplateProvider(ClassName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnProviderPtr(_result, false);
}

IAgCrdnProviderPtr _IAgCrdnRoot::GetProvider ( _bstr_t InstPath ) {
    struct IAgCrdnProvider * _result = 0;
    HRESULT _hr = raw_GetProvider(InstPath, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnProviderPtr(_result, false);
}

IAgCrdnWellKnownSystemsPtr _IAgCrdnRoot::GetWellKnownSystems ( ) {
    struct IAgCrdnWellKnownSystems * _result = 0;
    HRESULT _hr = get_WellKnownSystems(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnWellKnownSystemsPtr(_result, false);
}

IAgCrdnWellKnownAxesPtr _IAgCrdnRoot::GetWellKnownAxes ( ) {
    struct IAgCrdnWellKnownAxes * _result = 0;
    HRESULT _hr = get_WellKnownAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IAgCrdnWellKnownAxesPtr(_result, false);
}

} // namespace AgSTKVgtLib
